---
layout:     post
title:      "PHP设计模式-Part1 理论篇"
subtitle:   "概述和六大原则"
date:       2016-11-29
author:     "Clover"
header-img: "img/contact-bg.jpg"
catalog: true
tags:
    - Clover
    - 设计模式
    - PHP

---

> 参考资料《大话设计模式》
> 作者程杰
> 参考 http://blog.csdn.net/jhq0113/article/details/44906491

# 设计模式-概述

## 1.什么是设计模式

设计模式（Design Pattern）是一套`被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结`。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

## 2.设计模式的优点

1. `复用解决方案`：设计模式本身就是对某一类问题的通用解决方案，是更高级别的复用，已经超出了代码复用
2. `确定通用术语`：开发中的交流和协作都需要共同的词汇其础和对问题的共识.
3. `代码更易于修改与维护`：因为设计模式都是久经考验的解决方案,它们的结构都是经过长期的发展形成的，善于应对变化，设计模式本身也是对变化点的封装
4. `模式有助于提高思考层次`。学习模式后,就算不用模式中的方法，也会更好的采取更好的策略去解决问题

## 3.资源
更多详情敬请关注我的视频课程：

 [PHP面向对象设计模式](http://edu.csdn.net/course/detail/602)

 分享一个我在公司内部培训的资料，C#实例源代码及类图：
           
 [设计模式源代码及UML类图](http://pan.baidu.com/s/1qWOE5dy)

 对应23种面向对象设计模式PPT：

  [23种常用面向对象设计模式](http://pan.baidu.com/s/1i3zksE5)

# 设计模式-六大原则

* `单一职责`
* `里氏替换`
* `依赖倒置`
* `接口隔离`
* `迪米特法则`
* `开闭原则`

![六大原则](http://clover.htmhub.com/img/phpdesign/20150406222929184.jpeg)

## 1.单一职责

* **定义**：` 不要存在多于一个导致类变更的原因。`通俗的说，即一个类只负责一项职责。

* **场景**：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障，关系如下图：![p1](http://clover.htmhub.com/img/phpdesign/20150406223705732.jpeg)
* **修改**: `遵循单一职责原则.`分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险，结构如下图： ![p2](http://clover.htmhub.com/img/phpdesign/20150406223805012.jpeg)
* **优点**: 
	* 1)可以降低类的复杂度，一个类只负责一项职责，逻辑简单
	* 2)提高类的可读性，提高系统的可维护性；
	* 3)变更引起的风险降低，变更是必然的

## 2.里氏替换原则

* **定义**：所有引用基类的地方必须能透明地使用其子类的对象，也就是说`子类可以扩展父类的功能，但不能改变父类原有的功能`
* **场景**：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障，如下图 ![p2](http://clover.htmhub.com/img/phpdesign/20150406224441455.jpeg)
 CountPriceByJKL类继承于CountPrice类，CountPriceByJKL重写了Count()方法，这样可能影响到原来Count方法的功能。
 * **修改**: 当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

## 3.依赖倒置原则

* **定义**：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象
	
	此处理解起来是最困难的，一般会在项目框架的搭建的时候用到，例如，业务逻辑层相对于数据层是高层模块，因为业务逻辑层需要调用数据层去连接数据库，但是要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口

* **场景**：类A（高层模块）直接依赖类B（低层模块），假如要将类A改为依赖类C（低层模块），则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。![p2](http://clover.htmhub.com/img/phpdesign/20150406225436362.jpeg)

	AutoSystem类直接依赖于HondaCar与FordCar两个类，这样就产生了一个高耦合，AutoSystem类想操控HondaCar或者FordCar必须直接创建相应对象。
	
* **修改**: 将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率，如下图：![p2](http://clover.htmhub.com/img/phpdesign/20150406225842955.jpeg)
 	
 	经过此番修改，Honda与Ford实现ICar接口，提供了Run、Stop以及Turn功能方法，AutoSystem依赖ICar接口，这样迫使AutoSystem依赖抽象接口，这就使得AutoSystem类能够应对更多的需求变化。
 	
* **优点**: 
	* 1)低层模块尽量都要有抽象类或接口，或者两者都有
	* 2)变量的声明类型尽量是抽象类或接口
	* 3)使用继承时遵循里氏替换原则	

## 4.接口隔离原则

* **定义**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
* **场景**：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法，如下图：![p2](http://clover.htmhub.com/img/phpdesign/20150406231050132.jpeg)
* **修改**:将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则![p2](http://clover.htmhub.com/img/phpdesign/20150406231127388.jpeg)
* **注意**: 
	* 1)`接口尽量小，但是要有限度`。对接口进行细化可以提高程序设计灵活性 ，是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
	* 2)为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系
	* 3)提高内聚，减少对外交互。使接口用`最少的方法去完成最多`的事情

## 5.迪米特法则（最少知道原则）	
 
 * **定义**：一个对象应该对其他对象保持最少的了解
 * **场景**：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大
 	
 	简单的理解就是高内聚，一个类尽量减少对其他对象的依赖，并且这个类的方法和属性能用私有的就尽量私有化
 	
 * **注意**: 	
 	* 1)`只与直接的朋友通信，不要和陌生人说话`
	* 2)过分的使用该原则，将导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合

	
## 6.开闭原则

 * **定义**：一个软件实体如类、模块和函数应该`对扩展开放，对修改关闭`
 * **场景**：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试
 * **建议**: 当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化

 
# 设计模式分类

一般将面向对象设计模式分为三类 `创建型`、`结构型`、`行为型`三种。 

* `创建型` ：创建对象时，不再由我们直接实例化对象；而是根据特定场景，由程序来确定创建对象的方式，从而保证更大的性能、更好的`架构`优势。创建型模式主要有
	* `简单工厂模式（并不是23种设计模式之一）`
	* `工厂方法`
	* `抽象工厂模式`
	* `单例模式`
	* `生成器模式`
	* `原型模式`

* `结构型` ：用于帮助将多个对象组织成更大的结构。结构型模式主要有
	* `适配器模式`
	* `桥接模式`
	* `组合器模式`
	* `装饰器模式`
	* `门面模式`
	* `亨元模式`
	* `代理模式`
	
* `行为型` ：用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。行为型模式主要有
	* `命令模式`
	* `解释器模式`
	* `迭代器模式`
	* `中介者模式`
	* `备忘录模式`
	* `观察者模式`
	* `状态模式`
	* `策略模式`
	* `模板模式`
	* `访问者模式`
	* `职责链模式`


	
