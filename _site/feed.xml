<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clover Blog</title>
    <description>克洛弗，Web &amp; Mobile Lover，Front-End Engineer，UX Designer，PHP&amp;JAVA Engineer | 这里是 @Clover克洛弗 的个人博客，与你一起发现更大的世界。</description>
    <link>http://clover.htmhub.com/</link>
    <atom:link href="http://clover.htmhub.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 04 Jul 2016 11:51:43 +0800</pubDate>
    <lastBuildDate>Mon, 04 Jul 2016 11:51:43 +0800</lastBuildDate>
    <generator>Jekyll v3.0.3</generator>
    
      <item>
        <title>Redis Study 之二 入门指南</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;参考书籍：Redis入门指南（第二版）李子骅 编著 人民邮电出版社&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redis&quot;&gt;启动Redis&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;直接启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; redis-server
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过初始化脚本启动（略过）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/07/04/redis-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/07/04/redis-study/</guid>
        
        <category>Clover</category>
        
        <category>Redis</category>
        
        <category>DB</category>
        
        
      </item>
    
      <item>
        <title>Gulp-前端自动化构建工具</title>
        <description>&lt;h1 id=&quot;gulp-web&quot;&gt;Gulp-Web前端自动化开发工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;入门指南&lt;/h3&gt;

&lt;p&gt;####1. 全局安装 gulp&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --global gulp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####2. 作为项目的开发依赖（devDependencies）安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev gulp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####3. 在项目根目录下创建一个名为 gulpfile.js 的文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);

gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####4. 运行 gulp：&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/06/30/gulp-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/06/30/gulp-study/</guid>
        
        <category>Clover</category>
        
        <category>Web</category>
        
        <category>HTML</category>
        
        <category>Gulp</category>
        
        
      </item>
    
      <item>
        <title>Redis Study</title>
        <description>&lt;h1 id=&quot;redis&quot;&gt;Redis的学习&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。&lt;/p&gt;

&lt;p&gt;对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。&lt;/p&gt;

&lt;p&gt;当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。&lt;/p&gt;

&lt;p&gt;本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;windows&lt;/code&gt;:&lt;a href=&quot;https://github.com/dmajkic/redis/downloads&quot;&gt;https://github.com/dmajkic/redis/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*nix和MacOSX平台&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz
$ tar xzf redis-3.2.0.tar.gz
$ cd redis-3.2.0
$ make
$ make install
$ cp redis.conf /etc/
$ cd /etc
$ vim redis.conf
修改daemonize yes---目的使进程在后台运行
$ cd /usr/local/bin
$./redis-server /etc/redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;检查是否启动成功&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ ps -ef | grep redis
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;服务启动后通过 redis-cli链接&lt;br /&gt;
进入命令行控制台&lt;/p&gt;

&lt;p&gt;（当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）&lt;/p&gt;

&lt;p&gt;如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。&lt;/p&gt;

&lt;h2 id=&quot;redis-1&quot;&gt;运行和连接Redis&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.&lt;/p&gt;

&lt;p&gt;如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。&lt;/p&gt;

&lt;p&gt;然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。&lt;/p&gt;

&lt;p&gt;可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。&lt;/p&gt;

&lt;p&gt;如果在上面的启动步骤里遇到什么问题，我建议你到&lt;code class=&quot;highlighter-rouge&quot;&gt;Redis的官方支持组&lt;/code&gt;里获取帮助。&lt;/p&gt;

&lt;h2 id=&quot;redis-2&quot;&gt;驱动Redis&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的&lt;a href=&quot;http://redis.io/clients&quot;&gt;客户端推荐页面&lt;/a&gt;下载适合的Redis载体。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习-基础知识&lt;/h2&gt;

&lt;hr /&gt;
&lt;p&gt;是什么使Redis显得这么特别？Redis具体能解决什么类型的问题？要实际应用Redis，开发者必须储备什么知识？在我们能回答这么一些问题之前，我们需要明白Redis到底是什么。&lt;/p&gt;

&lt;p&gt;Redis通常被人们认为是一种持久化的存储器关键字-值型存储（in-memory persistent key-value store）。我认为这种对Redis的描述并不太准确。Redis的确是将所有的数据存放于存储器（更多是是按位存储），而且也确实通过将数据写入磁盘来实现持久化，但是Redis的实际意义比单纯的关键字-值型存储要来得深远。纠正脑海里的这种误解观点非常关键，否则你对于Redis之道以及其应用的洞察力就会变得越发狭义。&lt;/p&gt;

&lt;p&gt;事实是，Redis引入了5种不同的数据结构，只有一个是典型的关键字-值型结构。理解Redis的关键就在于搞清楚这5种数据结构，其工作的原理都是如何，有什么关联方法以及你能怎样应用这些数据结构去构建模型。首先，让我们来弄明白这些数据结构的实际意义。&lt;/p&gt;

&lt;p&gt;应用上面提及的数据结构概念到我们熟悉的关系型数据库里，我们可以认为其引入了一个单独的数据结构——表格。表格既复杂又灵活，基于表格的存储和管理，没有多少东西是你不能进行建模的。然而，这种通用性并不是没有缺点。具体来说就是，事情并不是总能达到假设中的简单或者快速。相对于这种普遍适用（one-size-fits-all）的结构体系，我们可以使用更为专门化的结构体系。当然，因此可能有些事情我们会完成不了(至少，达不到很好的程度）。但话说回来，这样做就能确定我们可以获得想象中的简单性和速度吗？&lt;/p&gt;

&lt;p&gt;针对特定类型的问题使用特定的数据结构？我们不就是这样进行编程的吗？你不会使用一个散列表去存储每份数据，也不会使用一个标量变量去存储。对我来说，这正是Redis的做法。如果你需要处理标量、列表、散列或者集合，为什么不直接就用标量、列表、散列和集合去存储他们？为什么不是直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;exists(key)&lt;/code&gt;去检测一个已存在的值，而是要调用其他比O(1)（常量时间查找，不会因为待处理元素的增长而变慢）慢的操作？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;databases&quot;&gt;数据库（Databases）&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。&lt;/p&gt;

&lt;p&gt;在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;。如果你想切换到一个不同的数据库，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;命令来实现。在命令行界面里键入&lt;code class=&quot;highlighter-rouge&quot;&gt;select 1&lt;/code&gt;，Redis应该会回复一条&lt;code class=&quot;highlighter-rouge&quot;&gt;OK&lt;/code&gt;的信息，然后命令行界面里的提示符会变成类似&lt;code class=&quot;highlighter-rouge&quot;&gt;redis 127.0.0.1:6379[1]&amp;gt;&lt;/code&gt;这样。如果你想切换回默认数据库，只要在命令行界面键入&lt;code class=&quot;highlighter-rouge&quot;&gt;select 0&lt;/code&gt;即可。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;commands-keys-and-values&quot;&gt;命令、关键字和值（Commands, Keys and Values）&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Redis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值。在转入其它关于Redis的有用信息之前，我们必须理解关键字和值的概念。&lt;/p&gt;

&lt;p&gt;关键字（Keys）是用来标识数据块。我们将会很常跟关键字打交道，不过在现在，明白关键字就是类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;users:leto&lt;/code&gt;这样的表述就足够了。一般都能很好地理解到，这样关键字包含的信息是一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;leto&lt;/code&gt;的用户。这个关键字里的冒号没有任何特殊含义，对于Redis而言，使用分隔符来组织关键字是很常见的方法。&lt;/p&gt;

&lt;p&gt;值（Values）是关联于关键字的实际值，可以是任何东西。有时候你会存储字符串，有时候是整数，还有时候你会存储序列化对象（使用JSON、XML或其他格式）。在大多数情况下，Redis会把值看做是一个字节序列，而不会关注它们实质上是什么。要注意，不同的Redis载体处理序列化会有所不同（一些会让你自己决定）。因此，在这本书里，我们将仅讨论字符串、整数和JSON。&lt;br /&gt;
现在让我们活动一下手指吧。在命令行界面键入下面的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set users:leto &quot;{name: leto, planet: dune, likes: [spice]}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就是Redis命令的基本构成。首先我们要有一个确定的命令，在上面的语句里就是set。然后就是相应的参数，set命令接受两个参数，包括要设置的关键字，以及相应要设置的值。很多的情况是，命令接受一个关键字（当这种情况出现，其经常是第一个参数）。你能想到如何去获取这个值吗？我想你会说（当然一时拿不准也没什么）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;get users:leto
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关键字和值的是Redis的基本概念，而&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;命令是对此最简单的使用。你可以创建更多的用户，去尝试不同类型的关键字以及不同的值，看看一些不同的组合。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;querying&quot;&gt;查询（Querying）&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;随着学习的持续深入，两件事情将变得清晰起来。对于Redis而言，关键字就是一切，而值是没有任何意义。更通俗来看就是，Redis不允许你通过值来进行查询。回到上面的例子，我们就不能查询生活在&lt;code class=&quot;highlighter-rouge&quot;&gt;dune&lt;/code&gt;行星上的用户。&lt;/p&gt;

&lt;p&gt;对许多人来说，这会引起一些担忧。在我们生活的世界里，数据查询是如此的灵活和强大，而Redis的方式看起来是这么的原始和不高效。不要让这些扰乱你太久。要记住，Redis不是一种普遍使用（one-size-fits-all）的解决方案，确实存在这么一些事情是不应该由Redis来解决的（因为其查询的限制）。事实上，在考虑了这些情况后，你会找到新的方法去构建你的数据。&lt;/p&gt;

&lt;p&gt;很快，我们就能看到更多实际的用例。很重要的一点是，我们要明白关于Redis的这些基本事实。这能帮助我们弄清楚为什么值可以是任何东西，因为Redis从来不需要去读取或理解它们。而且，这也可以帮助我们理清思路，然后去思考如何在这个新世界里建立模型。&lt;/p&gt;

&lt;h3 id=&quot;memory-and-persistence&quot;&gt;存储器和持久化（Memory and Persistence）&lt;/h3&gt;

&lt;p&gt;我们之前提及过，Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。&lt;/p&gt;

&lt;p&gt;除了创建磁盘快照外，Redis可以在附加模式下运行。任何时候，如果有一个关键字变更，一个单一附加（append-only）的文件会在磁盘里进行更新。在一些情况里，虽然硬件或软件可能发生错误，但用那60秒有效数据存储去换取更好性能是可以接受的。而在另一些情况里，这种损失就难以让人接受，Redis为你提供了选择。在第5章里，我们将会看到第三种选择，其将持久化任务减荷到一个从属数据库里。&lt;/p&gt;

&lt;p&gt;至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件。&lt;/p&gt;

&lt;p&gt;我很清楚有一些开发者对即使是一点点的数据空间都是那么的敏感。一本《威廉·莎士比亚全集》需要近5.5MB的存储空间。对于缩放的需求，其它的解决方案趋向于IO-bound或者CPU-bound。这些限制（RAM或者IO）将会需要你去理解更多机器实际依赖的数据类型，以及应该如何去进行存储和查询。除非你是存储大容量的多媒体文件到Redis中，否则存储器内存储应该不会是一个问题。如果这对于一个程序是个问题，你就很可能不会用IO-bound的解决方案。&lt;/p&gt;

&lt;p&gt;Redis有虚拟存储器的支持。然而，这个功能已经被认为是失败的了（通过Redis的开发者），而且它的使用已经被废弃了。&lt;/p&gt;

&lt;p&gt;（从另一个角度来看，一本5.5MB的《威廉·莎士比亚全集》可以通过压缩减小到近2MB。当然，Redis不会自动对值进行压缩，但是因为其将所有值都看作是字节，没有什么限制让你不能对数据进行压缩/解压，通过牺牲处理时间来换取存储空间。）&lt;/p&gt;

&lt;h3 id=&quot;putting-it-together&quot;&gt;整体来看（Putting It Together）&lt;/h3&gt;

&lt;p&gt;我们已经接触了好几个高层次的主题。在继续深入Redis之前，我想做的最后一件事情是将这些主题整合起来。这些主题包括，查询的限制，数据结构以及Redis在存储器内存储数据的方法。&lt;/p&gt;

&lt;p&gt;当你将这3个主题整合起来，你最终会得出一个绝妙的结论：速度。一些人可能会想，当然Redis会很快速，要知道所有的东西都在存储器里。但这仅仅是其中的一部分，让Redis闪耀的真正原因是其不同于其它解决方案的特殊数据结构。&lt;/p&gt;

&lt;p&gt;能有多快速？这依赖于很多东西，包括你正在使用着哪个命令，数据的类型等等。但Redis的性能测试是趋向于数万或数十万次操作&lt;strong&gt;每秒&lt;/strong&gt;。你可以通过运行&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-benchmark&lt;/code&gt;（就在&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-server&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-cli&lt;/code&gt;的同一个文件夹里）来进行测试。&lt;/p&gt;

&lt;p&gt;我曾经试过将一组使用传统模型的代码转向使用Redis。在传统模型里，运行一个我写的载入测试，需要超过5分钟的时间来完成。而在Redis里，只需要150毫秒就完成了。你不会总能得到这么好的收获，但希望这能让你对我们所谈的东西有更清晰的理解。&lt;/p&gt;

&lt;p&gt;理解Redis的这个特性很重要，因为这将影响到你如何去与Redis进行交互。拥有SQL背景的程序员通常会致力于让数据库的数据往返次数减至最小。这对于任何系统都是个好建议，包括Redis。然而，考虑到我们是在处理比较简单的数据结构，有时候我们还是需要与Redis服务器频繁交互，以达到我们的目的。刚开始的时候，可能会对这种数据访问模式感到不太自然。实际上，相对于我们通过Redis获得的高性能而言，这仅仅是微不足道的损失。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;虽然我们只接触和摆弄了Redis的冰山一角，但我们讨论的主题已然覆盖了很大范围内的东西。如果觉得有些事情还是不太清楚（例如查询），不用为此而担心，在下一章我们将会继续深入探讨，希望你的问题都能得到解答。&lt;/p&gt;

&lt;p&gt;这一章的要点包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关键字（Keys）是用于标识一段数据的一个字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Redis展示了（也实现了）5种专门的数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;第2章 - 数据结构&lt;/h2&gt;

&lt;p&gt;现在开始将探究Redis的5种数据结构，我们会解释每种数据结构都是什么，包含了什么有效的方法（Method），以及你能用这些数据结构处理哪些类型的特性和数据。&lt;/p&gt;

&lt;p&gt;目前为止，我们所知道的Redis构成仅包括命令、关键字和值，还没有接触到关于数据结构的具体概念。当我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;命令时，Redis是怎么知道我们是在使用哪个数据结构？其解决方法是，每个命令都相对应于一种特定的数据结构。例如，当你使用&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;命令，你就是将值存储到一个字符串数据结构里。而当你使用&lt;code class=&quot;highlighter-rouge&quot;&gt;hset&lt;/code&gt;命令，你就是将值存储到一个散列数据结构里。考虑到Redis的关键字集很小，这样的机制具有相当的可管理性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://redis.io/commands&quot;&gt;Redis的网站&lt;/a&gt;里有着非常优秀的参考文档，没有任何理由去重造轮子。但为了搞清楚这些数据结构的作用，我们将会覆盖那些必须知道的重要命令。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有什么事情比高兴的玩和试验有趣的东西来得更重要的了。在任何时候，你都能通过键入&lt;code class=&quot;highlighter-rouge&quot;&gt;flushdb&lt;/code&gt;命令将你数据库里的所有值清除掉，因此，不要再那么害羞了，去尝试做些疯狂的事情吧！&lt;/p&gt;

&lt;h3 id=&quot;strings&quot;&gt;字符串（Strings)&lt;/h3&gt;

&lt;p&gt;在Redis里，字符串是最基本的数据结构。当你在思索着关键字-值对时，你就是在思索着字符串数据结构。不要被名字给搞混了，如之前说过的，你的值可以是任何东西。我更喜欢将他们称作“标量”（Scalars），但也许只有我才这样想。&lt;/p&gt;

&lt;p&gt;我们已经看到了一个常见的字符串使用案例，即通过关键字存储对象的实例。有时候，你会频繁地用到这类操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set users:leto &quot;{name: leto, planet: dune, likes: [spice]}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了这些外，Redis还有一些常用的操作。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;strlen &amp;lt;key&amp;gt;&lt;/code&gt;能用来获取一个关键字对应值的长度；&lt;code class=&quot;highlighter-rouge&quot;&gt;getrange &amp;lt;key&amp;gt; &amp;lt;start&amp;gt; &amp;lt;end&amp;gt;&lt;/code&gt;将返回指定范围内的关键字对应值；&lt;code class=&quot;highlighter-rouge&quot;&gt;append &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;会将value附加到已存在的关键字对应值中（如果该关键字并不存在，则会创建一个新的关键字-值对）。不要犹豫，去试试看这些命令吧。下面是我得到的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; strlen users:leto
(integer) 42

&amp;gt; getrange users:leto 27 40
&quot;likes: [spice]&quot;

&amp;gt; append users:leto &quot; OVER 9000!!&quot;
(integer) 54
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在你可能会想，这很好，但似乎没有什么意义。你不能有效地提取出一段范围内的JSON文件，或者为其附加一些值。你是对的，这里的经验是，一些命令，尤其是关于字符串数据结构的，只有在给定了明确的数据类型后，才会有实际意义。&lt;/p&gt;

&lt;p&gt;之前我们知道了，Redis不会去关注你的值是什么东西。通常情况下，这没有错。然而，一些字符串命令是专门为一些类型或值的结构而设计的。作为一个有些含糊的用例，我们可以看到，对于一些自定义的空间效率很高的（space-efficient）串行化对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;append&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getrange&lt;/code&gt;命令将会很有用。对于一个更为具体的用例，我们可以再看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;incr&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;incrby&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;decr&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;decrby&lt;/code&gt;命令。这些命令会增长或者缩减一个字符串数据结构的值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; incr stats:page:about
(integer) 1
&amp;gt; incr stats:page:about
(integer) 2

&amp;gt; incrby ratings:video:12333 5
(integer) 5
&amp;gt; incrby ratings:video:12333 3
(integer) 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由此你可以想象到，Redis的字符串数据结构能很好地用于分析用途。你还可以去尝试增长&lt;code class=&quot;highlighter-rouge&quot;&gt;users:leto&lt;/code&gt;（一个不是整数的值），然后看看会发生什么（应该会得到一个错误）。&lt;/p&gt;

&lt;p&gt;更为进阶的用例是&lt;code class=&quot;highlighter-rouge&quot;&gt;setbit&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getbit&lt;/code&gt;命令。“今天我们有多少个独立用户访问”是个在Web应用里常见的问题，有一篇&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/&quot;&gt;精彩的博文&lt;/a&gt;，在里面可以看到Spool是如何使用这两个命令有效地解决此问题。对于1.28亿个用户，一部笔记本电脑在不到50毫秒的时间里就给出了答复，而且只用了16MB的存储空间。&lt;/p&gt;

&lt;p&gt;最重要的事情不是在于你是否明白位图（Bitmaps)的工作原理，或者Spool是如何去使用这些命令，而是应该要清楚Redis的字符串数据结构比你当初所想的要有用许多。然而，最常见的应用案例还是上面我们给出的：存储对象（简单或复杂）和计数。同时，由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。&lt;/p&gt;

&lt;h3 id=&quot;hashes&quot;&gt;散列（Hashes）&lt;/h3&gt;

&lt;p&gt;我们已经知道把Redis称为一种关键字-值型存储是不太准确的，散列数据结构是一个很好的例证。你会看到，在很多方面里，散列数据结构很像字符串数据结构。两者显著的区别在于，散列数据结构提供了一个额外的间接层：一个域（Field）。因此，散列数据结构中的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hset users:goku powerlevel 9000
hget users:goku powerlevel
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相关的操作还包括在同一时间设置多个域、同一时间获取多个域、获取所有的域和值、列出所有的域或者删除指定的一个域：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如你所见，散列数据结构比普通的字符串数据结构具有更多的可操作性。我们可以使用一个散列数据结构去获得更精确的描述，是存储一个用户，而不是一个序列化对象。从而得到的好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。&lt;/p&gt;

&lt;p&gt;对于散列数据结构，可以从一个经过明确定义的对象的角度来考虑，例如一个用户，关键之处在于要理解他们是如何工作的。从性能上的原因来看，这是正确的，更具粒度化的控制可能会相当有用。在下一章我们将会看到，如何用散列数据结构去组织你的数据，使查询变得更为实效。在我看来，这是散列真正耀眼的地方。&lt;/p&gt;

&lt;h3 id=&quot;lists&quot;&gt;列表（Lists）&lt;/h3&gt;

&lt;p&gt;对于一个给定的关键字，列表数据结构让你可以存储和处理一组值。你可以添加一个值到列表里、获取列表的第一个值或最后一个值以及用给定的索引来处理值。列表数据结构维护了值的顺序，提供了基于索引的高效操作。为了跟踪在网站里注册的最新用户，我们可以维护一个&lt;code class=&quot;highlighter-rouge&quot;&gt;newusers&lt;/code&gt;的列表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lpush newusers goku
ltrim newusers 0 50
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（译注：&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令的具体构成是&lt;code class=&quot;highlighter-rouge&quot;&gt;LTRIM Key start stop&lt;/code&gt;。要理解&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。对于指定的列表，根据所提供的两个范围参数start和stop，&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令会将指定范围外的值都删除掉，只留下范围内的值。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，我们将一个新用户推入到列表的前端，然后对列表进行调整，使得该列表只包含50个最近被推入的用户。这是一种常见的模式。&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。&lt;/p&gt;

&lt;p&gt;这是我们第一次看到一个关键字的对应值索引另一个值。如果我们想要获取最近的10个用户的详细资料，我们可以运行下面的组合操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们之前谈论过关于多次往返数据的模式，上面的两行Ruby代码为我们进行了很好的演示。&lt;/p&gt;

&lt;p&gt;当然，对于存储和索引关键字的功能，并不是只有列表数据结构这种方式。值可以是任意的东西，你可以使用列表数据结构去存储日志，也可以用来跟踪用户浏览网站时的路径。如果你过往曾构建过游戏，你可能会使用列表数据结构去跟踪用户的排队活动。&lt;/p&gt;

&lt;h3 id=&quot;sets&quot;&gt;集合（Sets）&lt;/h3&gt;

&lt;p&gt;集合数据结构常常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如并集。集合数据结构没有对值进行排序，但是其提供了高效的基于值的操作。使用集合数据结构的典型用例是朋友名单的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sismember friends:leto jessica
sismember friends:leto vladimir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而且，我们可以查看两个或更多的人是不是有共同的朋友：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sinter friends:leto friends:duncan
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;甚至可以在一个新的关键字里存储结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sinterstore friends:leto_duncan friends:leto friends:duncan
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。&lt;/p&gt;

&lt;h3 id=&quot;sorted-sets&quot;&gt;分类集合（Sorted Sets）&lt;/h3&gt;

&lt;p&gt;最后也是最强大的数据结构是分类集合数据结构。如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。如果我们想要一个秩分类的朋友名单，可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;duncan&lt;/code&gt;的朋友，要怎样计算出标记（score）为90或更高的人数？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zcount friends:duncan 90 100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如何获取&lt;code class=&quot;highlighter-rouge&quot;&gt;chani&lt;/code&gt;在名单里的秩（rank）？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zrevrank friends:duncan chani
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（译注：&lt;code class=&quot;highlighter-rouge&quot;&gt;zrank&lt;/code&gt;命令的具体构成是&lt;code class=&quot;highlighter-rouge&quot;&gt;ZRANK Key menber&lt;/code&gt;，要知道Key存储的Sorted Set默认是根据Score对各个menber进行升序的排列，该命令就是用来获取menber在该排列里的次序，这就是所谓的秩。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;zrevrank&lt;/code&gt;命令而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;zrank&lt;/code&gt;命令，这是因为Redis的默认排序是从低到高，但是在这个例子里我们的秩划分是从高到低。对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;对于Redis的5种数据结构，我们进行了高层次的概述。一件有趣的事情是，相对于最初构建时的想法，你经常能用Redis创造出一些更具实效的事情。对于字符串数据结构和分类集合数据结构的使用，很有可能存在一些构建方法是还没有人想到的。当你理解了那些常用的应用案例后，你将发现Redis对于许多类型的问题，都是很理想的选择。还有，不要因为Redis展示了5种数据结构和相应的各种方法，就认为你必须要把所有的东西都用上。只使用一些命令去构建一个特性是很常见的。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;第3章 - 使用数据结构&lt;/h2&gt;

&lt;p&gt;在上一章里，我们谈论了Redis的5种数据结构，对于一些可能的用途也给出了用例。现在是时候来看看一些更高级，但依然很常见的主题和设计模式。&lt;/p&gt;

&lt;h3 id=&quot;obig-o-notation&quot;&gt;大O表示法（Big O Notation）&lt;/h3&gt;

&lt;p&gt;在本书中，我们之前就已经看到过大O表示法，包括O(1)和O(N)的表示。大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。&lt;/p&gt;

&lt;p&gt;在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。让我们来看看一些用例。&lt;/p&gt;

&lt;p&gt;常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;sismember&lt;/code&gt;命令，其作用是告诉我们一个值是否属于一个集合，时间复杂度为O(1)。&lt;code class=&quot;highlighter-rouge&quot;&gt;sismember&lt;/code&gt;命令很强大，很大部分的原因是其高效的性能特征。许多Redis命令都具有O(1)的时间复杂度。&lt;/p&gt;

&lt;p&gt;对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。使用这种“分而治之”的方式，大量的元素能在几个迭代过程里被快速分解完整。&lt;code class=&quot;highlighter-rouge&quot;&gt;zadd&lt;/code&gt;命令的时间复杂度就是O(log(N))，其中N是在分类集合中的元素数量。&lt;/p&gt;

&lt;p&gt;再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令具有O(N)的时间复杂度，但是，在&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。从一个具有百万元素的列表里用&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令删除1个元素，要比从一个具有一千个元素的列表里用&lt;code class=&quot;highlighter-rouge&quot;&gt;ltrim&lt;/code&gt;命令删除10个元素来的快速（实际上，两者很可能会是一样快，因为两个时间都非常的小）。&lt;/p&gt;

&lt;p&gt;根据给定的最小和最大的值的标记，&lt;code class=&quot;highlighter-rouge&quot;&gt;zremrangebyscore&lt;/code&gt;命令会在一个分类集合里进行删除元素操作，其时间复杂度是O(log(N)+M)。这看起来似乎有点儿杂乱，通过阅读文档可以知道，这里的N指的是在分类集合里的总元素数量，而M则是被删除的元素数量。可以看出，对于性能而言，被删除的元素数量很可能会比分类集合里的总元素数量更为重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：&lt;code class=&quot;highlighter-rouge&quot;&gt;zremrangebyscore&lt;/code&gt;命令的具体构成是&lt;code class=&quot;highlighter-rouge&quot;&gt;ZREMRANGEBYSCORE Key max mix&lt;/code&gt;。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令，其时间复杂度为O(N+M*log(M))，我们将会在下一章谈论更多的相关细节。从&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的性能特征来看，可以说这是Redis里最复杂的一个命令。&lt;/p&gt;

&lt;p&gt;还存在其他的时间复杂度描述，包括O(N^2)和O(C^N)。随着N的增大，其性能将急速下降。在Redis里，没有任何一个命令具有这些类型的时间复杂度。&lt;/p&gt;

&lt;p&gt;值得指出的一点是，在Redis里，当我们发现一些操作具有O(N)的时间复杂度时，我们可能可以找到更为好的方法去处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：对于Big O Notation，相信大家都非常的熟悉，虽然原文仅仅是对该表示法进行简单的介绍，但限于个人的算法知识和文笔水平实在有限，此小节的翻译让我头痛颇久，最终成果也确实难以让人满意，望见谅。）&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;pseudo-multi-key-queries&quot;&gt;仿多关键字查询（Pseudo Multi Key Queries）&lt;/h3&gt;

&lt;p&gt;时常，你会想通过不同的关键字去查询相同的值。例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set users:leto@dune.gov &quot;{id: 9001, email: &#39;leto@dune.gov&#39;, ...}&quot;
set users:9001 &quot;{id: 9001, email: &#39;leto@dune.gov&#39;, ...}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。&lt;/p&gt;

&lt;p&gt;如果Redis允许你将一个关键字链接到另一个的话，可能情况会好很多，可惜Redis并没有提供这样的功能（而且很可能永远都不会提供）。Redis发展到现在，其开发的首要目的是要保持代码和API的整洁简单，关键字链接功能的内部实现并不符合这个前提（对于关键字，我们还有很多相关方法没有谈论到）。其实，Redis已经提供了解决的方法：散列。&lt;/p&gt;

&lt;p&gt;使用散列数据结构，我们可以摆脱重复的缠绕：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set users:9001 &quot;{id: 9001, email: leto@dune.gov, ...}&quot;
hset users:lookup:email leto@dune.gov 9001
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们所做的是，使用域来作为一个二级索引，然后去引用单个用户对象。要通过id来获取用户信息，我们可以使用一个普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;get users:9001
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而如果想通过电子邮箱来获取用户信息，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;hget&lt;/code&gt;命令再配合使用&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;命令（Ruby代码）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id = redis.hget(&#39;users:lookup:email&#39;, &#39;leto@dune.gov&#39;)
user = redis.get(&quot;users:#{id}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你很可能将会经常使用这类用法。在我看来，这就是散列真正耀眼的地方。在你了解这类用法之前，这可能不是一个明显的用例。&lt;/p&gt;

&lt;h3 id=&quot;references-and-indexes&quot;&gt;引用和索引（References and Indexes）&lt;/h3&gt;

&lt;p&gt;我们已经看过几个关于值引用的用例，包括介绍列表数据结构时的用例，以及在上面使用散列数据结构来使查询更灵活一些。进行归纳后会发现，对于那些值与值间的索引和引用，我们都必须手动的去管理。诚实来讲，这确实会让人有点沮丧，尤其是当你想到那些引用相关的操作，如管理、更新和删除等，都必须手动的进行时。在Redis里，这个问题还没有很好的解决方法。&lt;/p&gt;

&lt;p&gt;我们已经看到，集合数据结构很常被用来实现这类索引：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd friends:leto ghanima paul chani jessica
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个集合里的每一个成员都是一个Redis字符串数据结构的引用，而每一个引用的值则包含着用户对象的具体信息。那么如果&lt;code class=&quot;highlighter-rouge&quot;&gt;chani&lt;/code&gt;改变了她的名字，或者删除了她的帐号，应该如何处理？从整个朋友圈的关系结构来看可能会更好理解，我们知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;chani&lt;/code&gt;也有她的朋友：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd friends_of:chani leto paul
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你有什么待处理情况像上面那样，那在维护成本之外，还会有对于额外索引值的处理和存储空间的成本。这可能会令你感到有点退缩。在下一小节里，我们将会谈论减少使用额外数据交互的性能成本的一些方法（在第1章我们粗略地讨论了下）。&lt;/p&gt;

&lt;p&gt;如果你确实在担忧着这些情况，其实，关系型数据库也有同样的开销。索引需要一定的存储空间，必须通过扫描或查找，然后才能找到相应的记录。其开销也是存在的，当然他们对此做了很多的优化工作，使之变得更为有效。&lt;/p&gt;

&lt;p&gt;再次说明，需要在Redis里手动地管理引用确实是颇为棘手。但是，对于你关心的那些问题，包括性能或存储空间等，应该在经过测试后，才会有真正的理解。我想你会发现这不会是一个大问题。&lt;/p&gt;

&lt;h3 id=&quot;round-trips-and-pipelining&quot;&gt;数据交互和流水线（Round Trips and Pipelining）&lt;/h3&gt;

&lt;p&gt;我们已经提到过，与服务器频繁交互是Redis的一种常见模式。这类情况可能很常出现，为了使我们能获益更多，值得仔细去看看我们能利用哪些特性。&lt;/p&gt;

&lt;p&gt;许多命令能接受一个或更多的参数，也有一种关联命令（sister-command）可以接受多个参数。例如早前我们看到过&lt;code class=&quot;highlighter-rouge&quot;&gt;mget&lt;/code&gt;命令，接受多个关键字，然后返回值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者是&lt;code class=&quot;highlighter-rouge&quot;&gt;sadd&lt;/code&gt;命令，能添加一个或多个成员到集合里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd friends:vladimir piter
sadd friends:paul jessica leto &quot;leto II&quot; chani
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Redis还支持流水线功能。通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。这不但减少了网络开销，还能获得性能上的显著提高。&lt;/p&gt;

&lt;p&gt;值得一提的是，Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。&lt;/p&gt;

&lt;p&gt;对于不同的Redis载体，在流水线里运行命令的方式会有所差异。在Ruby里，你传递一个代码块到&lt;code class=&quot;highlighter-rouge&quot;&gt;pipelined&lt;/code&gt;方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis.pipelined do
  9001.times do
	redis.incr(&#39;powerlevel&#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正如你可能猜想到的，流水线功能可以实际地加速一连串命令的处理。&lt;/p&gt;

&lt;h3 id=&quot;transactions&quot;&gt;事务（Transactions）&lt;/h3&gt;

&lt;p&gt;每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。此外，对于使用多个命令，Redis支持事务功能。&lt;/p&gt;

&lt;p&gt;你可能不知道，但Redis实际上是单线程运行的，这就是为什么每一个Redis命令都能够保证具有原子性。当一个命令在执行时，没有其他命令会运行（我们会在往后的章节里简略谈论一下Scaling）。在你考虑到一些命令去做多项事情时，这会特别的有用。例如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;incr&lt;/code&gt;命令实际上就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;命令然后紧随一个&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getset&lt;/code&gt;命令设置一个新的值然后返回原始值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setnx&lt;/code&gt;命令首先测试关键字是否存在，只有当关键字不存在时才设置值&lt;/p&gt;

&lt;p&gt;虽然这些都很有用，但在实际开发时，往往会需要运行具有原子性的一组命令。若要这样做，首先要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;multi&lt;/code&gt;命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;命令去实际执行命令，或者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;discard&lt;/code&gt;命令放弃执行命令。Redis的事务功能保证了什么？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;事务中的命令将会按顺序地被执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事务中的命令要么全部被执行，要么不会执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以（也应该）在命令行界面对事务功能进行一下测试。还有一点要注意到，没有什么理由不能结合流水线功能和事务功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;multi
hincrby groups:1percent balance -9000000000
hincrby groups:99percent balance 9000000000
exec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，Redis能让你指定一个关键字（或多个关键字），当关键字有改变时，可以查看或者有条件地应用一个事务。这是用于当你需要获取值，且待运行的命令基于那些值时，所有都在一个事务里。对于上面展示的代码，我们不能去实现自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;incr&lt;/code&gt;命令，因为一旦&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;命令被调用，他们会全部被执行在一块。我们不能这么做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis.multi()
current = redis.get(&#39;powerlevel&#39;)
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（译注：虽然Redis是单线程运行的，但是我们可以同时运行多个Redis客户端进程，常见的并发问题还是会出现。像上面的代码，在&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;运行之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;运行之前，&lt;code class=&quot;highlighter-rouge&quot;&gt;powerlevel&lt;/code&gt;的值可能会被另一个Redis客户端给改变，从而造成错误。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些不是Redis的事务功能的工作。但是，如果我们增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;powerlevel&lt;/code&gt;，我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis.watch(&#39;powerlevel&#39;)
current = redis.get(&#39;powerlevel&#39;)
redis.multi()
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在我们调用&lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt;后，如果另一个客户端改变了&lt;code class=&quot;highlighter-rouge&quot;&gt;powerlevel&lt;/code&gt;的值，我们的事务将会运行失败。如果没有客户端改变&lt;code class=&quot;highlighter-rouge&quot;&gt;powerlevel&lt;/code&gt;的值，那么事务会继续工作。我们可以在一个循环里运行这些代码，直到其能正常工作。&lt;/p&gt;

&lt;h3 id=&quot;keys-anti-pattern&quot;&gt;关键字反模式（Keys Anti-Pattern）&lt;/h3&gt;

&lt;p&gt;在下一章中，我们将会谈论那些没有确切关联到数据结构的命令，其中的一些是管理或调试工具。然而有一个命令我想特别地在这里进行谈论：&lt;code class=&quot;highlighter-rouge&quot;&gt;keys&lt;/code&gt;命令。这个命令需要一个模式，然后查找所有匹配的关键字。这个命令看起来很适合一些任务，但这不应该用在实际的产品代码里。为什么？因为这个命令通过线性扫描所有的关键字来进行匹配。或者，简单地说，这个命令太慢了。&lt;/p&gt;

&lt;p&gt;人们会如此去使用这个命令？一般会用来构建一个本地的Bug追踪服务。每一个帐号都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;，你可能会通过一个看起来像&lt;code class=&quot;highlighter-rouge&quot;&gt;bug:account_id:bug_id&lt;/code&gt;的关键字，把每一个Bug存储到一个字符串数据结构值中去。如果你在任何时候需要查询一个帐号的Bug（显示它们，或者当用户删除了帐号时删除掉这些Bugs），你可能会尝试去使用&lt;code class=&quot;highlighter-rouge&quot;&gt;keys&lt;/code&gt;命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keys bug:1233:*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更好的解决方法应该使用一个散列数据结构，就像我们可以使用散列数据结构来提供一种方法去展示二级索引，因此我们可以使用域来组织数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hset bugs:1233 1 &quot;{id:1, account: 1233, subject: &#39;...&#39;}&quot;
hset bugs:1233 2 &quot;{id:2, account: 1233, subject: &#39;...&#39;}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从一个帐号里获取所有的Bug标识，可以简单地调用&lt;code class=&quot;highlighter-rouge&quot;&gt;hkeys bugs:1233&lt;/code&gt;。去删除一个指定的Bug，可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;hdel bugs:1233 2&lt;/code&gt;。如果要删除了一个帐号，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;del bugs:1233&lt;/code&gt;把关键字删除掉。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;结合这一章以及前一章，希望能让你得到一些洞察力，了解如何使用Redis去支持（Power）实际项目。还有其他的模式可以让你去构建各种类型的东西，但真正的关键是要理解基本的数据结构。你将能领悟到，这些数据结构是如何能够实现你最初视角之外的东西。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;第4章 超越数据结构&lt;/h2&gt;

&lt;p&gt;5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。我们已经看过一些这样的命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;flushdb&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;multi&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;discard&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;keys &lt;/code&gt;。这一章将看看其他的一些重要命令。&lt;/p&gt;

&lt;h3 id=&quot;expiration&quot;&gt;使用期限（Expiration）&lt;/h3&gt;

&lt;p&gt;Redis允许你标记一个关键字的使用期限。你可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。这是一个基于关键字的命令，因此其不在乎关键字表示的是哪种类型的数据结构。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expire pages:about 30
expireat pages:about 1356933600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个命令将会在30秒后删除掉关键字（包括其关联的值）。第二个命令则会在2012年12月31日上午12点删除掉关键字。&lt;/p&gt;

&lt;p&gt;这让Redis能成为一个理想的缓冲引擎。通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ttl&lt;/code&gt;命令，你可以知道一个关键字还能够存活多久。而通过&lt;code class=&quot;highlighter-rouge&quot;&gt;persist&lt;/code&gt;命令，你可以把一个关键字的使用期限删除掉。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ttl pages:about
persist pages:about
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，有个特殊的字符串命令，&lt;code class=&quot;highlighter-rouge&quot;&gt;setex&lt;/code&gt;命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期（这比任何事情都要方便）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setex pages:about 30 &#39;&amp;lt;h1&amp;gt;about us&amp;lt;/h1&amp;gt;....&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;publication-and-subscriptions&quot;&gt;发布和订阅（Publication and Subscriptions）&lt;/h3&gt;

&lt;p&gt;Redis的列表数据结构有&lt;code class=&quot;highlighter-rouge&quot;&gt;blpop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;brpop&lt;/code&gt;命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：对于&lt;code class=&quot;highlighter-rouge&quot;&gt;blpop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;brpop&lt;/code&gt;命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用&lt;code class=&quot;highlighter-rouge&quot;&gt;lpush&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;rpush&lt;/code&gt;命令推入关键字为止。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此外，Redis对于消息发布和频道订阅有着一流的支持。你可以打开第二个&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-cli&lt;/code&gt;窗口，去尝试一下这些功能。在第一个窗口里订阅一个频道（我们会称它为&lt;code class=&quot;highlighter-rouge&quot;&gt;warnings&lt;/code&gt;）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subscribe warnings
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其将会答复你订阅的信息。现在，在另一个窗口，发布一条消息到&lt;code class=&quot;highlighter-rouge&quot;&gt;warnings&lt;/code&gt;频道：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;publish warnings &quot;it&#39;s over 9000!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你回到第一个窗口，你应该已经接收到&lt;code class=&quot;highlighter-rouge&quot;&gt;warnings&lt;/code&gt;频道发来的消息。&lt;/p&gt;

&lt;p&gt;你可以订阅多个频道（&lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe channel1 channel2 ...&lt;/code&gt;），订阅一组基于模式的频道（&lt;code class=&quot;highlighter-rouge&quot;&gt;psubscribe warnings:*&lt;/code&gt;），以及使用&lt;code class=&quot;highlighter-rouge&quot;&gt;unsubscribe&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;punsubscribe&lt;/code&gt;命令停止监听一个或多个频道，或一个频道模式。&lt;/p&gt;

&lt;p&gt;最后，可以注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;publish&lt;/code&gt;命令的返回值是1，这指出了接收到消息的客户端数量。&lt;/p&gt;

&lt;h3 id=&quot;monitor-and-slow-log&quot;&gt;监控和延迟日志（Monitor and Slow Log）&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;monitor&lt;/code&gt;命令可以让你查看Redis正在做什么。这是一个优秀的调试工具，能让你了解你的程序如何与Redis进行交互。在两个&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-cli&lt;/code&gt;窗口中选一个（如果其中一个还处于订阅状态，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;unsubscribe&lt;/code&gt;命令退订，或者直接关掉窗口再重新打开一个新窗口）键入&lt;code class=&quot;highlighter-rouge&quot;&gt;monitor&lt;/code&gt;命令。在另一个窗口，执行任何其他类型的命令（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;命令）。在第一个窗口里，你应该可以看到这些命令，包括他们的参数。&lt;/p&gt;

&lt;p&gt;在实际生产环境里，你应该谨慎运行&lt;code class=&quot;highlighter-rouge&quot;&gt;monitor&lt;/code&gt;命令，这真的仅仅就是一个很有用的调试和开发工具。除此之外，没有更多要说的了。&lt;/p&gt;

&lt;p&gt;随同&lt;code class=&quot;highlighter-rouge&quot;&gt;monitor&lt;/code&gt;命令一起，Redis拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;slowlog&lt;/code&gt;命令，这是一个优秀的性能剖析工具。其会记录执行时间超过一定数量&lt;strong&gt;微秒&lt;/strong&gt;的命令。在下一章节，我们会简略地涉及如何配置Redis，现在你可以按下面的输入配置Redis去记录所有的命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config set slowlog-log-slower-than 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，执行一些命令。最后，你可以检索到所有日志，或者检索最近的那些日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slowlog get
slowlog get 10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过键入&lt;code class=&quot;highlighter-rouge&quot;&gt;slowlog len&lt;/code&gt;，你可以获取延迟日志里的日志数量。&lt;/p&gt;

&lt;p&gt;对于每个被你键入的命令，你应该查看4个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一个自动递增的id&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个Unix时间戳，表示命令开始运行的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个微妙级的时间，显示命令运行的总时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;该命令以及所带参数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;延迟日志保存在存储器中，因此在生产环境中运行（即使有一个低阀值）也应该不是一个问题。默认情况下，它将会追踪最近的1024个日志。&lt;/p&gt;

&lt;h3 id=&quot;sort&quot;&gt;排序（Sort）&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令是Redis最强大的命令之一。它让你可以在一个列表、集合或者分类集合里对值进行排序（分类集合是通过标记来进行排序，而不是集合里的成员）。下面是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的简单用例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpush users:leto:guesses 5 9 10 2 4 10 19 2
sort users:leto:guesses
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这将返回进行升序排序后的值。这里有一个更高级的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd friends:ghanima leto paul chani jessica alia duncan
sort friends:ghanima limit 0 3 desc alpha
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的命令向我们展示了，如何对已排序的记录进行分页（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt;），如何返回降序排序的结果（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;desc&lt;/code&gt;），以及如何用字典序排序代替数值序排序（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;alpha&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的真正力量是其基于引用对象来进行排序的能力。早先的时候，我们说明了列表、集合和分类集合很常被用于引用其他的Redis对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令能够解引用这些关系，而且通过潜在值来进行排序。例如，假设我们有一个Bug追踪器能让用户看到各类已存在问题。我们可能使用一个集合数据结构去追踪正在被监视的问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd watch:leto 12339 1382 338 9338
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可能会有强烈的感觉，想要通过id来排序这些问题（默认的排序就是这样的），但是，我们更可能是通过问题的严重性来对这些问题进行排序。为此，我们要告诉Redis将使用什么模式来进行排序。首先，为了可以看到一个有意义的结果，让我们添加多一点数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set severity:12339 3
set severity:1382 2
set severity:338 5
set severity:9338 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要通过问题的严重性来降序排序这些Bug，你可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sort watch:leto by severity:* desc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Redis将会用存储在列表（集合或分类集合）中的值去替代模式中的&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;by&lt;/code&gt;）。这会创建出关键字名字，Redis将通过查询其实际值来排序。&lt;/p&gt;

&lt;p&gt;在Redis里，虽然你可以有成千上万个关键字，类似上面展示的关系还是会引起一些混乱。幸好，&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令也可以工作在散列数据结构及其相关域里。相对于拥有大量的高层次关键字，你可以利用散列：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hset bug:12339 severity 3
hset bug:12339 priority 1
hset bug:12339 details &quot;{id: 12339, ....}&quot;

hset bug:1382 severity 2
hset bug:1382 priority 2
hset bug:1382 details &quot;{id: 1382, ....}&quot;

hset bug:338 severity 5
hset bug:338 priority 3
hset bug:338 details &quot;{id: 338, ....}&quot;

hset bug:9338 severity 4
hset bug:9338 priority 2
hset bug:9338 details &quot;{id: 9338, ....}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的事情不仅变得更为容易管理，而且我们能通过&lt;code class=&quot;highlighter-rouge&quot;&gt;severity&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;priority&lt;/code&gt;来进行排序，还可以告诉&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令具体要检索出哪一个域的数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sort watch:leto by bug:*-&amp;gt;priority get bug:*-&amp;gt;details
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相同的值替代出现了，但Redis还能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt;符号，用它来查看散列中指定的域。里面还包括了&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;参数，这里也会进行值替代和域查看，从而检索出Bug的细节（details域的数据）。&lt;/p&gt;

&lt;p&gt;对于太大的集合，&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的执行可能会变得很慢。好消息是，&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的输出可以被存储起来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sort watch:leto by bug:*-&amp;gt;priority get bug:*-&amp;gt;details store watch_by_priority:leto
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用我们已经看过的&lt;code class=&quot;highlighter-rouge&quot;&gt;expiration&lt;/code&gt;命令，再结合&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令的&lt;code class=&quot;highlighter-rouge&quot;&gt;store&lt;/code&gt;能力，这是一个美妙的组合。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;这一章主要关注那些非特定数据结构关联的命令。和其他事情一样，它们的使用依情况而定。构建一个程序或特性时，可能不会用到使用期限、发布和订阅或者排序等功能。但知道这些功能的存在是很好的。而且，我们也只接触到了一些命令。还有更多的命令，当你消化理解完这本书后，非常值得去浏览一下&lt;a href=&quot;http://redis.io/commands&quot;&gt;完整的命令列表&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;第5章 - 管理&lt;/h2&gt;

&lt;p&gt;在最后一章里，我们将集中谈论Redis运行中的一些管理方面内容。这是一个不完整的Redis管理指南，我们将会回答一些基本的问题，初接触Redis的新用户可能会很感兴趣。&lt;/p&gt;

&lt;h3 id=&quot;configuration&quot;&gt;配置（Configuration）&lt;/h3&gt;

&lt;p&gt;当你第一次运行Redis的服务器，它会向你显示一个警告，指&lt;code class=&quot;highlighter-rouge&quot;&gt;redis.conf&lt;/code&gt;文件没有被找到。这个文件可以被用来配置Redis的各个方面。一个充分定义（well-documented）的&lt;code class=&quot;highlighter-rouge&quot;&gt;redis.conf&lt;/code&gt;文件对各个版本的Redis都有效。范例文件包含了默认的配置选项，因此，对于想要了解设置在干什么，或默认设置是什么，都会很有用。你可以在&lt;a href=&quot;https://github.com/antirez/redis/raw/2.4.6/redis.conf&quot;&gt;https://github.com/antirez/redis/raw/2.4.6/redis.conf&lt;/a&gt;找到这个文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个配置文件针对的是Redis 2.4.6，你应该用你的版本号替代上面URL里的”2.4.6”。运行&lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt;命令，其显示的第一个值就是Redis的版本号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为这个文件已经是充分定义（well-documented），我们就不去再进行设置了。&lt;/p&gt;

&lt;p&gt;除了通过&lt;code class=&quot;highlighter-rouge&quot;&gt;redis.conf&lt;/code&gt;文件来配置Redis，&lt;code class=&quot;highlighter-rouge&quot;&gt;config set&lt;/code&gt;命令可以用来对个别值进行设置。实际上，在将&lt;code class=&quot;highlighter-rouge&quot;&gt;slowlog-log-slower-than&lt;/code&gt;设置为0时，我们就已经使用过这个命令了。&lt;/p&gt;

&lt;p&gt;还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;config get&lt;/code&gt;命令能显示一个设置值。这个命令支持模式匹配，因此如果我们想要显示关联于日志（logging）的所有设置，我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config get *log*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;authentication&quot;&gt;验证（Authentication）&lt;/h3&gt;

&lt;p&gt;通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;requirepass&lt;/code&gt;（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;config set&lt;/code&gt;命令或&lt;code class=&quot;highlighter-rouge&quot;&gt;redis.conf&lt;/code&gt;文件），可以让Redis需要一个密码验证。当&lt;code class=&quot;highlighter-rouge&quot;&gt;requirepass&lt;/code&gt;被设置了一个值（就是待用的密码），客户端将需要执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;auth password&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;一旦一个客户端通过了验证，就可以在任意数据库里执行任何一条命令，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;flushall&lt;/code&gt;命令，这将会清除掉每一个数据库里的所有关键字。通过配置，你可以重命名一些重要命令为混乱的字符串，从而获得一些安全性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
rename-command FLUSHALL 1041285018a942a4922cbf76623b741e
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者，你可以将新名字设置为一个空字符串，从而禁用掉一个命令。&lt;/p&gt;

&lt;h3 id=&quot;size-limitations&quot;&gt;大小限制（Size Limitations）&lt;/h3&gt;

&lt;p&gt;当你开始使用Redis，你可能会想知道，我能使用多少个关键字？还可能想知道，一个散列数据结构能有多少个域（尤其是当你用它来组织数据时），或者是，一个列表数据结构或集合数据结构能有多少个元素？对于每一个实例，实际限制都能达到亿万级别（hundreds of millions）。&lt;/p&gt;

&lt;h3 id=&quot;replication&quot;&gt;复制（Replication）&lt;/h3&gt;

&lt;p&gt;Redis支持复制功能，这意味着当你向一个Redis实例（Master）进行写入时，一个或多个其他实例（Slaves）能通过Master实例来保持更新。可以在配置文件里设置&lt;code class=&quot;highlighter-rouge&quot;&gt;slaveof&lt;/code&gt;，或使用&lt;code class=&quot;highlighter-rouge&quot;&gt;slaveof&lt;/code&gt;命令来配置一个Slave实例。对于那些没有进行这些设置的Redis实例，就可能一个Master实例。&lt;/p&gt;

&lt;p&gt;为了更好保护你的数据，复制功能拷贝数据到不同的服务器。复制功能还能用于改善性能，因为读取请求可以被发送到Slave实例。他们可能会返回一些稍微滞后的数据，但对于大多数程序来说，这是一个值得做的折衷。&lt;/p&gt;

&lt;p&gt;遗憾的是，Redis的复制功能还没有提供自动故障恢复。如果Master实例崩溃了，一个Slave实例需要手动的进行升级。如果你想使用Redis去达到某种高可用性，对于使用心跳监控（heartbeat monitoring）和脚本自动开关（scripts to automate the switch）的传统高可用性工具来说，现在还是一个棘手的难题。&lt;/p&gt;

&lt;h3 id=&quot;backups&quot;&gt;备份文件（Backups）&lt;/h3&gt;

&lt;p&gt;备份Redis非常简单，你可以将Redis的快照（snapshot）拷贝到任何地方，包括S3、FTP等。默认情况下，Redis会把快照存储为一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;dump.rdb&lt;/code&gt;的文件。在任何时候，你都可以对这个文件执行&lt;code class=&quot;highlighter-rouge&quot;&gt;scp&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ftp&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;cp&lt;/code&gt;等常用命令。&lt;/p&gt;

&lt;p&gt;有一种常见情况，在Master实例上会停用快照以及单一附加文件（aof），然后让一个Slave实例去处理备份事宜。这可以帮助减少Master实例的载荷。在不损害整体系统响应性的情况下，你还可以在Slave实例上设置更多主动存储的参数。&lt;/p&gt;

&lt;h3 id=&quot;redisscaling-and-redis-cluster&quot;&gt;缩放和Redis集群（Scaling and Redis Cluster）&lt;/h3&gt;

&lt;p&gt;复制功能（Replication）是一个成长中的网站可以利用的第一个工具。有一些命令会比另外一些来的昂贵（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令），将这些运行载荷转移到一个Slave实例里，可以保持整体系统对于查询的快速响应。&lt;/p&gt;

&lt;p&gt;此外，通过分发你的关键字到多个Redis实例里，可以达到真正的缩放Redis（记住，Redis是单线程的，这些可以运行在同一个逻辑框里）。随着时间的推移，你将需要特别注意这些事情（尽管许多的Redis载体都提供了consistent-hashing算法）。对于数据水平分布（horizontal distribution）的考虑不在这本书所讨论的范围内。这些东西你也很可能不需要去担心，但是，无论你使用哪一种解决方案，有一些事情你还是必须意识到。&lt;/p&gt;

&lt;p&gt;好消息是，这些工作都可在Redis集群下进行。不仅提供水平缩放（包括均衡），为了高可用性，还提供了自动故障恢复。&lt;/p&gt;

&lt;p&gt;高可用性和缩放是可以达到的，只要你愿意为此付出时间和精力，Redis集群也使事情变得简单多了。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;在过去的一段时间里，已经有许多的计划和网站使用了Redis，毫无疑问，Redis已经可以应用于实际生产中了。然而，一些工具还是不够成熟，尤其是一些安全性和可用性相关的工具。对于Redis集群，我们希望很快就能看到其实现，这应该能为一些现有的管理挑战提供处理帮忙。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;在许多方面，Redis体现了一种简易的数据处理方式，其剥离掉了大部分的复杂性和抽象，并可有效的在不同系统里运行。不少情况下，选择Redis不是最佳的选择。在另一些情况里，Redis就像是为你的数据提供了特别定制的解决方案。&lt;/p&gt;

&lt;p&gt;最终，回到我最开始所说的：Redis很容易学习。现在有许多的新技术，很难弄清楚哪些才真正值得我们花时间去学习。如果你从实际好处来考虑，Redis提供了他的简单性。我坚信，对于你和你的团队，学习Redis是最好的技术投资之一。&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/06/20/redis-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/06/20/redis-study/</guid>
        
        <category>Clover</category>
        
        <category>Redis</category>
        
        <category>DB</category>
        
        
      </item>
    
      <item>
        <title>Monogo DB Study</title>
        <description>&lt;h1 id=&quot;monogodb--&quot;&gt;MonogoDB  学习笔记&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;#入门篇&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;学习目标&lt;/h2&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;mongo-&quot;&gt;Mongo 概念&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mongo&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;MongoDB&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;索引&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;集合&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;复制集&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;分片&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;数据均衡&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mongodb&quot;&gt;学会MongoDB的搭建&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;搭建简单的单击服务&lt;/li&gt;
  &lt;li&gt;搭建具有冗余容错功能的复制集&lt;/li&gt;
  &lt;li&gt;搭建大规模数据集群&lt;/li&gt;
  &lt;li&gt;完成集群的自动部署&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mongodb-1&quot;&gt;MongoDB的使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;最基本的文档的读写和更新&lt;/li&gt;
  &lt;li&gt;各种不同类型的索引的创建与使用&lt;/li&gt;
  &lt;li&gt;复杂的聚合查询&lt;/li&gt;
  &lt;li&gt;对数据集合进行分片，在不同分片间维持数据均衡&lt;/li&gt;
  &lt;li&gt;数据备份与恢复&lt;/li&gt;
  &lt;li&gt;数据迁移&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;简单运维&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;部署集群&lt;/li&gt;
  &lt;li&gt;处理多种常见的故障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```&lt;br /&gt;
 单节点失效，如何恢复工作&lt;br /&gt;
 数据库意外被杀死如何进行数据恢复&lt;br /&gt;
 数据库拒绝服务如何排除原因&lt;br /&gt;
 数据库磁盘快慢时如何处理&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习资源&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;MongoDB官网&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;www.mongodb.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MongoDB中国官网&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;www.mongoing.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;github&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/mongodb/mongo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中文文档&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;docs.mongoing.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;视频资源&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.imooc.com/video/5934&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;#开始学习&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;数据库&lt;/h2&gt;

&lt;hr /&gt;
&lt;p&gt;### 概念&lt;br /&gt;
1. 有组织的存放数据&lt;br /&gt;
2. 按照不同的需求进行查询&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;数据库分类&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;sql数据库：支持sql语言的数据库 Oracle,Mysql&lt;/li&gt;
  &lt;li&gt;NoSql数据库：不支持SQL语言的数据库 Redis,MongoDB&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Sql 数据库&lt;/th&gt;
      &lt;th&gt;NoSql数据库&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;实时一致性&lt;/td&gt;
      &lt;td&gt;简单便捷&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;事务&lt;/td&gt;
      &lt;td&gt;方便扩展&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多表联合查询&lt;/td&gt;
      &lt;td&gt;更好的性能&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;mongodb-2&quot;&gt;为什么是MongoDB&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;无数据结构的限制
    &lt;ol&gt;
      &lt;li&gt;没有表结构的概念，每条记录可以有完全不同的结构&lt;/li&gt;
      &lt;li&gt;业务开发方便快捷&lt;/li&gt;
      &lt;li&gt;sql数据库需要先定义表结构再使用&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,sex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;男&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;上海&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,home&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;山东&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;江西&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;完全的索引支持
    &lt;ol&gt;
      &lt;li&gt;redis的key-value&lt;/li&gt;
      &lt;li&gt;hbase的单索引	，二级索引需要自己实现&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
 单键索引，多键索引：{x:1,y:1}
 数组索引：[&quot;apple&quot;,&quot;lemon&quot;]
 全文索引：“I am a little bird” (中文)
 地理位置索引：2D
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;方便的冗余和扩展
    &lt;ol&gt;
      &lt;li&gt;复制集保证数据安全&lt;/li&gt;
      &lt;li&gt;分片扩展数据规模&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;良好的支持
    &lt;ol&gt;
      &lt;li&gt;完善的文档&lt;/li&gt;
      &lt;li&gt;齐全的驱动支持&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;安装过程 略过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mkdir data
# mkdir log
# mkdir conf
# mkdir bin
# cd conf
# vim mongodb.conf
  port=27017
  dbpath=data
  logpath=log/mongod.log
  fork=true
启动 # mongod -f conf/mongodb.conf   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;连接 mongo 121.41.31.214:27017&lt;br /&gt;
数据库的关闭 连接时   db.shutdownServer()&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mongodb-3&quot;&gt;mongoDB的基本操作&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
查看所有数据库
&amp;gt; show dbs

切换数据库
&amp;gt; use dbname

删除当前数据库,（需要先use）
&amp;gt; db.dropDatabase();

创建表 (不要特殊创建 只需要use 一个不存在的name mongoDb会在需要的时候自己创建，一个表是一个集合)
&amp;gt; use dbname

数据的写入  db.集合名.insert(json数据) 表集合不存在的话自动创建 _id自动创建 _id自定义时不能重复
&amp;gt; db.dbname_collection.insert({x:1})

数据的查询 db.集合名.find()  参数可以为空，返回所有文档
&amp;gt; db.dbname_collection.find()
&amp;gt; db.dbname_collection.find({x:1})   查询x=1的文档

循环插入
&amp;gt; for(i=3;i&amp;lt;100;i++)db.dbname_collection.insert({x:i})

计数
&amp;gt; db.dbname_collection.find().count()

跳过，限制条数，排序
&amp;gt; db.dbname_collection.find().skip(3).limit(2).sort({x:1})


数据更新 db.集合名.find(查询条件,更新条目)  默认只会更新第一条找到的数据
&amp;gt; db.dbname_collection.update({x:1},{x:999})  会更新x=1的文档为 {x:999}
注意：db.dbname_collection.insert({x:1,y:2,z:3}) 若要更新z=3的文档 把x更新为22， 使用 db.dbname_collection.update({z:3},{x:22})  会把{x:1,y:2,z:3}整体覆盖为{x:22} 

局部更新
&amp;gt;db.dbname_collection.update({z:3},{$set:{x:22}})  局部更新 不会被覆盖

更新不存在的数据，即自动创建 第三个参数 true 标示不存在的时候自动创建
&amp;gt; db.dbname_collection.update({x:3},{x:22},true)

批量更新  第四个参数 true 批量更新
&amp;gt; db.dbname_collection.update({x:1},{$set:{x:22}},false,true)

数据删除  必须传参，默认删除所有找的数据
&amp;gt; db.dbname_collection.remove({x:1})
&amp;gt; db.dbname_collection.drop()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mongodb-4&quot;&gt;MongoDB索引&lt;/h2&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-5&quot;&gt;内容简介&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;索引的种类和使用&lt;/li&gt;
  &lt;li&gt;索引的匹配规则&lt;/li&gt;
  &lt;li&gt;如何建立合适的索引&lt;/li&gt;
  &lt;li&gt;索引建立的情况评估&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;查看索引
&amp;gt; db.dbname_collection.getIndexes()

创建索引  参数也是文档  1代表正向排序 -1 代表逆向排序
&amp;gt; db.dbname_collection.ensureIndex({x:1})

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;索引的种类&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;_id索引&lt;/li&gt;
  &lt;li&gt;单键索引&lt;/li&gt;
  &lt;li&gt;多键索引&lt;/li&gt;
  &lt;li&gt;复合索引&lt;/li&gt;
  &lt;li&gt;过期索引&lt;/li&gt;
  &lt;li&gt;全文索引&lt;/li&gt;
  &lt;li&gt;地理位置索引&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;id&quot;&gt;_id索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;_id索引是绝大多数集合默认建立的索引&lt;/li&gt;
  &lt;li&gt;对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;单键索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;单键索引是最普通的索引&lt;/li&gt;
  &lt;li&gt;与_id索引不同，单键索引不会自动创建&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;多键索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;多键索引与单键索引创建形式相同，区别在于字段的值
    &lt;ul&gt;
      &lt;li&gt;单键索引：值为单一的值，例如字符串，数字或者日期&lt;/li&gt;
      &lt;li&gt;多键索引：值具有多个记录，例如数组&lt;br /&gt;
##### 复合索引&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当我们的查询条件不只有一个时，就需要建立复合索引
    &lt;ul&gt;
      &lt;li&gt;插入{x:1,y:2,z:3}-&amp;gt;按照x与y的值查询-&amp;gt;创建索引db.collection.ensureIndex({x:1,y:1})-&amp;gt;使用{x:1,y:1}作为条件进行查询&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;过期索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;过期索引：是在一段时间后会过期的索引&lt;/li&gt;
  &lt;li&gt;在索引过期后，相应的数据会被删除&lt;/li&gt;
  &lt;li&gt;这适合存储一些在一些时间后会失效的数据 比如用户的登陆信息，存储的日志&lt;/li&gt;
  &lt;li&gt;建立方法：db.collection.ensureIndex({time:1},{expireAfterSeconds:10}),第二个参数是过期时间的秒数&lt;/li&gt;
  &lt;li&gt;过期索引的限制
    &lt;ol&gt;
      &lt;li&gt;存储在过期索引字段的值必须是指定的时间类型，说明：必须是ISODate或者ISODate数组，不能使用时间戳，否则不能被自动删除&lt;/li&gt;
      &lt;li&gt;如果指定了ISODate数组，则按照最小的时间进行删除&lt;/li&gt;
      &lt;li&gt;过期索引不能是复合索引&lt;/li&gt;
      &lt;li&gt;删除时间是不精确的 说明：删除过程是由后台程序每60S跑一次，而且删除也需要一些时间，所以存在误差&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;全文索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;全文索引：对字符串与字符串数组创建全文可搜索的索引&lt;br /&gt;
适用情况{author:”“,title:”“,article:””}&lt;/li&gt;
  &lt;li&gt;建立方法&lt;br /&gt;
  db.articles.ensureIndex({key:”text”})&lt;br /&gt;
  db.articles.ensureIndex({key_1:”text”,key_2:”text”})&lt;br /&gt;
  db.articles.ensureIndex({“$**”:”text”})&lt;/li&gt;
  &lt;li&gt;如何创建全文索引	&lt;br /&gt;
  db.imooc_2.ensureIndex({“article”:”text”})&lt;/li&gt;
  &lt;li&gt;如何使用全文索引进行查询
    &lt;ol&gt;
      &lt;li&gt;db.articles.find({$text:{$search:”coffee”}})&lt;/li&gt;
      &lt;li&gt;db.articles.find({$text:{$search:”aa bb cc”}}) 查询 aa 或bb 或cc&lt;/li&gt;
      &lt;li&gt;db.articles.find({$text:{$search:”aa bb -cc”}}) 查询aa 或bb 不包含cc&lt;/li&gt;
      &lt;li&gt;db.articles.find({$text:{$search:”&quot;aa&quot; &quot;bb&quot; &quot;cc&quot;”}}) 且的关系 既包含aa也包含bb也包含cc&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;全文索引的相似度&lt;/p&gt;

    &lt;p&gt;$meta操作符：{score:{$meta:”textScore”}}&lt;br /&gt;
写在查询条件后面可以返回结果的相似度与sort一起使用，可以达到很好的实用效果	db.articles.find({$text:{$search:”aa bb”}},{score:{$meta:”tetxScore”}}).sort({score:{$meta:”tetxScore”}})&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;全文索引的使用限制&lt;br /&gt;
1.每次查询，只能指定一个$text查询
    &lt;ol&gt;
      &lt;li&gt;$test查询不能出现在$nor查询中&lt;/li&gt;
      &lt;li&gt;查询中如果包含了$test,hint不再起作用&lt;br /&gt;
很可惜，MongoDB全文索引还不支持中文&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;索引属性&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;创建索引的格式&lt;br /&gt;
 db,collection.ensureIndex({param},{param}) &lt;br /&gt;
 其中第二个参数便是索引的属性&lt;/li&gt;
  &lt;li&gt;比较重要的属性有 名字 唯一性 稀疏性 是否定时删除
    &lt;ul&gt;
      &lt;li&gt;名字，name指定：db.collection.ensureIndex({},{name:””})&lt;/li&gt;
      &lt;li&gt;唯一性，unique指定：db.collection.ensureIndex({},{unique:true/false})&lt;/li&gt;
      &lt;li&gt;稀疏性，sparse指定：db.collection.ensureIndex({},{sparse:true/false}) 默认是不稀疏的&lt;br /&gt;
 db.collection.find({m:{$exists:true}})查询存在m的文档&lt;br /&gt;
 db.collection.ensureIndex({m:1},{sparse:true})&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;db.collection.find({m:{$exists:false}})&lt;br /&gt;
 &lt;strong&gt;在选取索引  在稀疏索引上 查找是否存在 将不使用稀疏索引&lt;/strong&gt;&lt;br /&gt;
 强制使用索引 db.collection.find({m:{$exists:false}}).hint(“m_1”)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;是否定时删除，expireAfterSeconds指定&lt;br /&gt;
 TTL，过期索引&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;section-12&quot;&gt;地理位置索引&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将一些点的位置存储在MongoDB中，创建索引后，可以按照位置来查找其他点
    &lt;ul&gt;
      &lt;li&gt;子分类:
        &lt;ol&gt;
          &lt;li&gt;2d索引，用于存储和查找平面上的点。&lt;/li&gt;
          &lt;li&gt;2dsphere索引，用于存储和查找球面上的点&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;查找方式
    &lt;ul&gt;
      &lt;li&gt;查找距离某个点一定距离的点&lt;/li&gt;
      &lt;li&gt;查找包含在某区域内的点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
2D索引：平面地理位置索引
		创建方式:db.collection.ensureIndex({w:&quot;2d&quot;})
		位置表示方式：经纬度[经度,维度]
		取值范围：经度[-180,180]维度[-90,90]
		db.collection.insert({w:[100,2]})
		db.collection.find({w:{$near:[1,1]}})
		near会返回100个离查询的点最近的点
		db.collection.find({w:{$near:[1,1]，$maxDistance:10}})  
		
		查询方式：
		（1）$near查询：查询距离某个点最近的点
		（2）$geoWithin查询：查询某个形状内的点
		
		形状的标示：
		1.$box:矩形，使用
		{$box[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],[&amp;lt;x2&amp;gt;,&amp;lt;y2&amp;gt;]]}  1.左边界 2.右边界
		2.$center:圆形，使用
		{$center:[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],r]} 1.圆心位置 2.半径
		3.$polygon:多边形，使用
		{$polygon：[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],[&amp;lt;x2&amp;gt;,&amp;lt;y2&amp;gt;],[&amp;lt;x3&amp;gt;,&amp;lt;y3&amp;gt;]]}
		
		db.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}})
		
	geoNear查询
	geoNear使用runCommand命令进行使用
	{
	geoNear:&amp;lt;collection&amp;gt;,
	near:[x,y],
	minDistance:(对2D索引无效)
	MaxDistance:
	num:
	}
	
	db.runCommand({geoNear:&quot;location&quot;,near:[1,2],maxDistance:10,num:1})
	
		
2dsphere: 
创建方式:db.collection.ensureIndex({w:&quot;2dsphere&quot;})
位置表示方式
GeoJson:描述一个点，一条直线，多边形等
格式：{type:&quot;&quot;,coordinates:[&amp;lt;coordinates&amp;gt;]}
查询方式和2D索引查询方式类似
支持$minDistance与$maxDistance

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-13&quot;&gt;索引构建情况分析&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;索引好处：加快索引相关的查询&lt;/li&gt;
  &lt;li&gt;索引不好处：增加磁盘空间消耗，降低写入性能&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;如何评判当前索引构建情况
    &lt;ol&gt;
      &lt;li&gt;mongostat工具介绍&lt;/li&gt;
      &lt;li&gt;profile集合介绍&lt;/li&gt;
      &lt;li&gt;日志介绍&lt;/li&gt;
      &lt;li&gt;explain分析&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;mongostat&quot;&gt;mongostat工具&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;mongostat查看mongodb运行状态的程序&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用说明	:mongostat -h 127.0.0.1:12345&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;字段说明:&lt;br /&gt;
 	* inserts&lt;br /&gt;
 	* query&lt;br /&gt;
 	* update&lt;br /&gt;
 	* delete&lt;br /&gt;
 	* getmore&lt;br /&gt;
 	* command&lt;br /&gt;
 	* flushes&lt;br /&gt;
 	* mapped&lt;br /&gt;
 	* vsize&lt;br /&gt;
 	* res&lt;br /&gt;
 	* non-mapped&lt;br /&gt;
 	* faults&lt;br /&gt;
 	* locked&lt;br /&gt;
 	* idx miss 索引情况&lt;br /&gt;
 	* qr|qw&lt;br /&gt;
 	* ar|aw&lt;br /&gt;
 	* netIn&lt;br /&gt;
 	* netOut&lt;br /&gt;
 	* conn&lt;br /&gt;
 	* set&lt;br /&gt;
 	* repl&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;profile&quot;&gt;profile集合&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;db.getProfilingStatus()&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;db.setProfilingLevel(2)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;db.system.profile.find().sort({$natural:-1}).limit(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-14&quot;&gt;日志&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;mongodb.conf 中 verbose=vvvvv    v越多代表日志越详细&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;explain&quot;&gt;explain&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;db.collection.find({x:1}).explain()&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mongodb-&quot;&gt;MongoDB 安全&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;###安全概览&lt;br /&gt;
1. 最安全的是物理隔离：不现实&lt;br /&gt;
2. 网络隔离其次&lt;br /&gt;
3. 防火墙再其次&lt;br /&gt;
4. 用户名密码在最后&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-15&quot;&gt;开启权限验证&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;auth开启&lt;br /&gt;
mongodb.conf 设置  auth=true;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;keyfile开启&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;mongodb-5&quot;&gt;MongoDB创建用户&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;创建语法：createUser(2.6之前为addUser)&lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;user:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;&amp;lt;name&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;password&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sustomData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;说明&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;roles;[{role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;role&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;database&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;角色类型：内建类型（read,readWrite,dbAdmin,dbOwner,userAdmin）&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;section-16&quot;&gt;用户角色详解&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin）&lt;/li&gt;
  &lt;li&gt;集群角色（cluterAdmin,clusterManager）&lt;/li&gt;
  &lt;li&gt;备份角色（backup,restore）&lt;/li&gt;
  &lt;li&gt;其他特殊权限（DBAdminAnyDatabase）&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 20 May 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/05/20/monogo-db-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/05/20/monogo-db-study/</guid>
        
        <category>Clover</category>
        
        <category>MonogoDB</category>
        
        
      </item>
    
      <item>
        <title>My First Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;宇宙，海洋，黑洞&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;大海&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
echo &#39;hello word!&#39;;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;宇宙&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo &#39;hello black!&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;黑洞&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#cat /etc/issue  
#cat /etc/*-release 
#uname -a
#MemTotal=`free -m | grep Mem | awk &#39;{print  $2}&#39;`
#df -h 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/03/24/my-first-blog/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/03/24/my-first-blog/</guid>
        
        <category>Clover</category>
        
        <category>OS</category>
        
        <category>Blog</category>
        
        
      </item>
    
      <item>
        <title>React vs Angular 2：冰与火之歌「译」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine/20549104&quot;&gt;我在知乎专栏「前端外刊评论」上发表的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt; 已经发布 Beta 版，而且似乎很有信心在 2016 年成为热门框架。是时候进行一场巅峰对决了，我们来看看它如何与 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 这个 2015 年的新宠抗衡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt;我之前很喜欢使用 Angular 1，不过在 2015 年转到了 React。最近我也在 Pluralsight 上发布了一门关于 &lt;a href=&quot;https://www.pluralsight.com/courses/react-flux-building-applications&quot;&gt;React 和 Flux 的课程&lt;/a&gt;（&lt;a href=&quot;http://app.pluralsight.com/signup&quot;&gt;免费试学&lt;/a&gt;）。所以，&lt;strong&gt;是的，我本人是有偏见的，但我不会偏袒任何一方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，我们开始吧，这场对决将会非常血腥。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MRPl_SNuRGJchb6eOAnkSA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图片来源：&lt;a href=&quot;https://twitter.com/jwcarroll&quot;&gt;@jwcarrol&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;两者根本不具有可比性！&lt;/h2&gt;

&lt;p&gt;是的是的，Angular 是框架，React 是类库。所以有人觉得比较这两者没有逻辑性可言。大错特错！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择 Angular 还是 React 就像选择直接购买成品电脑还是买零件自己组装一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者的优缺点本文都会提及，我会拿 React 语法和组件模型跟 Angular 的语法和组件模型做对比。这就像是拿成品电脑的 CPU 跟零售的 CPU 做对比，没有任何不妥。&lt;/p&gt;

&lt;h2 id=&quot;angular-2-&quot;&gt;Angular 2 的优点&lt;/h2&gt;

&lt;p&gt;我们先看 Angular 相对 React 有哪些优势。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;&lt;strong&gt;无选择性疲劳&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Angular 是一个完整的框架，本身就提供了比 React 多得多的建议和功能。而要用 React，开发者通常还需要借助别的类库来打造一个真正的应用。比如你可能需要额外的库来处理路由、强制单向数据流、进行 API 调用、做测试以及管理依赖等等。要做的选择和决定太多了，让人很有压力。这也是为什么 React 有那么多的入门套件的原因（我自己就写了两个：&lt;a href=&quot;https://github.com/coryhouse/react-flux-starter-kit&quot;&gt;1&lt;/a&gt;、&lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;Angular 自带了不少主张，所以能够帮助你更快开始，不至于因为要做很多决定而无所适从。这种强制的一致性也能帮助新人更快适应其开发模式，并使得开发者在不同团队间切换更具可行性。&lt;/p&gt;

&lt;p&gt;Angular 核心团队让我非常欣赏的一点是，他们拥抱了 TypeScript，这就造成了另一个优势。&lt;/p&gt;

&lt;h4 id=&quot;typescript--&quot;&gt;TypeScript = 阳关大道&lt;/h4&gt;

&lt;p&gt;没错，并非所有人都喜欢 TypeScript，但是 Angular 2 毅然决然地选择了它确实是个巨大的优势。反观 React，网上的各种示例应用令人沮丧地不一致——ES5 和 ES6 的项目基本上各占一半，而且目前存在&lt;a href=&quot;http://jamesknelson.com/should-i-use-react-createclass-es6-classes-or-stateless-functional-components/&quot;&gt;三种不同的组件声明方式&lt;/a&gt;。这无疑给初学者造成了困惑。（Angular 还拥抱了装饰器（decorator）而不是继承（extends）——很多人认为这也是个加分项）。&lt;/p&gt;

&lt;p&gt;尽管 Angular 2 并不强制使用 TypeScript，但显然的是，Angular 的核心团队默认在文档中使用 TypeScript。这意味着相关的示例应用和开源项目更有可能保持一致性。Angular 已经提供了&lt;a href=&quot;https://angular.io/docs/ts/latest/quickstart.html&quot;&gt;非常清晰的关于如何使用 TypeScript 编译器的例子&lt;/a&gt;。（诚然，目前&lt;a href=&quot;http://angularjs.blogspot.com/2015/09/angular-2-survey-results.html&quot;&gt;并非所有人都在拥抱 TypeScript&lt;/a&gt;，但我有理由相信等到正式发布之后，TypeScript 会成为事实上的标准）。这种一致性应该会帮助初学者避免在学习 React 时遇到的疑惑和选择困难。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;极少的代码变动&lt;/h4&gt;

&lt;p&gt;2015 年是 &lt;a href=&quot;https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.559iqxb39&quot;&gt;JavaScript 疲劳&lt;/a&gt;元年，React 可以说是罪魁祸首。而且 React 尚未发布 1.0，所以未来还可能有很多变数。React 生态圈依旧在快速地变动着，尤其是&lt;a href=&quot;https://github.com/kriasoft/react-starter-kit/issues/22&quot;&gt;各种 Flux 变种&lt;/a&gt;和&lt;a href=&quot;https://github.com/rackt/react-router&quot;&gt;路由&lt;/a&gt;。也就是说，你今天用 React 写的所有东西，都有可能在 React 1.0 正式发布后过时，或者必须进行大量的改动。&lt;/p&gt;

&lt;p&gt;相反，Angular 2 是一个对已经成熟完整框架（Angular 1）的重新发明，而且经过仔细、系统的设计。所以 Angular 不大可能在正式发布后要求已有项目进行痛苦的代码变动。Angular 作为一个完整的框架，你在选择它的时候，也会信任其开发团队，相信他们会认真决定框架的未来。而使用 React，一切都需要你自己负责，你要自己整合一大堆开源类库来打造一个完整的应用，类库之间互不相干且变动频繁。这是一个令人沮丧的耗时工作，而且永远没有尽头。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;&lt;strong&gt;广泛的工具支持&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;后面我会说，我认为 React 的 JSX 是非常耀眼的亮点。然而要使用 JSX，你需要选择支持它的工具。尽管 React 已经足够流行，工具支持不再是什么问题，但诸如 IDE 和 lint 工具等新工具还不大可能很快得到支持。Angular 2 的模版是保存在一个字符串或独立的 HTML 文件中的，所以不要求特殊的工具支持（不过似乎 Angular 字符串模版的智能解析工具已经呼之欲出了）。&lt;/p&gt;

&lt;h4 id=&quot;web-components-&quot;&gt;Web Components 友好&lt;/h4&gt;

&lt;p&gt;Angular 2 还拥抱了 Web Component 标准。唉，真尴尬我居然一开始忘记提到这点了——最近我还发布了一门关于&lt;a href=&quot;https://www.pluralsight.com/courses/web-components-shadow-dom&quot;&gt;Web Components 课程&lt;/a&gt;呢！简单来说，把 Angular 2 组件转换成原生 Web Components 应该会比 React 组件容易得多。固然 Web Components 的&lt;a href=&quot;http://jonrimmer.github.io/are-we-componentized-yet/&quot;&gt;浏览器支持度依然很弱&lt;/a&gt;，但长期来看，对 Web Components 友好是很大的优势。&lt;/p&gt;

&lt;p&gt;Angular 的实现有其自身的局限和陷阱，这正好让我过渡到对 React 优势的讨论。&lt;/p&gt;

&lt;h3 id=&quot;react-&quot;&gt;React 的优点&lt;/h3&gt;

&lt;p&gt;现在，让我们看看是什么让 React 如此与众不同。&lt;/p&gt;

&lt;h4 id=&quot;jsx&quot;&gt;&lt;strong&gt;JSX&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;JSX 是一种类似 HTML 的语法，但它实际上会被编译成 JavaScript。将标签与代码混写在同一个文件中意味着输入一个组件的函数或者变量时你将享受到自动补全的福利。而 Angular 基于字符串的模版就相形见绌了：很多编辑器都不会高亮它们（只会显示单色）、只有有限的代码补全支持，并且一直到运行时才会报错。并且，通常你也只能得到很有限的错误提示。不过，Angular 的团队&lt;a href=&quot;https://github.com/angular/angular/issues/4417&quot;&gt;造了一个自己的 HTML 解析器来解决这个问题&lt;/a&gt;。（叼叼叼！）&lt;/p&gt;

&lt;p&gt;如果你不喜欢 Angular 的字符串模版，你可以把模版移到一个单独的文件里去。不过这样你就回到了我认为的“老样子”：你需要在自己脑袋里记住这两个文件的关联，不但没有代码自动补全，也没有任何编译时检查来协助你。这听起来可能并不算什么……除非你已经爱上了与 React 相伴的日子。在同一个文件中组合组件还能享受编译时的检查，大概是 JSX 最与众不同的地方之一了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p5.qhimg.com/d/inn/8a99f370/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对比 Angular 2 与 React 在标签忘记闭合时是如何表现的。&lt;/p&gt;

&lt;p&gt;关于为什么 JSX 是一个巨大的优势，可以看看 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.5007n49wq&quot;&gt;JSX：硬币的另一面（JSX: The Other Side of the Coin）&lt;/a&gt;. （P.S. 这是作者写的另一篇文章，如果大家希望我们可以把这篇也翻了，欢迎在评论区举手）&lt;/p&gt;

&lt;h4 id=&quot;react--1&quot;&gt;React 报错清晰快速&lt;/h4&gt;

&lt;p&gt;当你在 React 的 JSX 中不小心手抖打错时，它并不会被编译。这是一件非常美妙的事情：无论你是忘记闭合了标签还是引用了一个不存在的属性（property），你都可以立刻知道到底是哪一行出错了。&lt;strong&gt;JSX 编译器会指出你手抖的具体行号&lt;/strong&gt;，彻彻底底加速你的开发。&lt;/p&gt;

&lt;p&gt;相反，当你在 Angular 2 中不小心敲错了一个变量时，鸦雀无声。&lt;strong&gt;Angular 2 并不会在编译时做什么，它会等到运行时才静默报错。&lt;/strong&gt;它报错得&lt;em&gt;如此之慢&lt;/em&gt;，我加载完整个应用然后奇怪为什么我的数据没有显示出来呢？这太不爽了。&lt;/p&gt;

&lt;h4 id=&quot;react--javascript-&quot;&gt;React 以 JavaScript 为中心&lt;/h4&gt;

&lt;p&gt;终于来了。这才是 React 和 Angular 的根本区别。&lt;strong&gt;很不幸，Angular 2 仍然是以 HTML 而非 JavaScript 为中心的。&lt;/strong&gt;Angular 2 并没有解决它设计上的根本问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Angular 2 继续把 “JS” 放到 HTML 里。React 则把 “HTML” 放到 JS 里。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种分歧带来的影响真是再怎么强调也不为过。它们从根本上影响着开发体验。Angular 以 HTML 为中心的设计留下了巨大的缺陷。正如我在 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.jqh5kkxlk&quot;&gt;JSX：硬币的另一面&lt;/a&gt; 中所说的，JavaScript 远比 HTML 要强大。因此，&lt;strong&gt;增强 JavaScript 让其支持标签要比增强 HTML 让其支持逻辑要合理得多&lt;/strong&gt;。无论如何，HTML 与 JavaScript 都需要某种方式以粘合在一起。React 以 JavaScript 为中心的思路从根本上优于 Angular、Ember、Knockout 这些以 HTML 为中心的思路。&lt;/p&gt;

&lt;p&gt;让我们来看看为什么。&lt;/p&gt;

&lt;h4 id=&quot;react--javascript---&quot;&gt;React 以 JavaScript 为中心的设计 = 简约&lt;/h4&gt;

&lt;p&gt;Angular 2 延续了 Angular 1 试图让 HTML 更加强大的老路子。所以即使是像循环或者条件判断这样的简单任务你也不得不使用 Angular 2 的独特语法来完成。例如，Angular 2 通过两种语法同时提供了单向数据绑定与双向数据绑定，可不幸的是它们实在差得有点多：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//单向数据绑定&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ngModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;myVar&quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//双向数据绑定&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 React 中，数据绑定语法不取决于数据流的单双向（数据绑定的单双向是在其他地方处理的，不得不说我觉得理应如此）。不管是单向还是双向数据流，绑定语法都是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Angular 2 的内联母版（inline master templates）使用了这样的语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ngFor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#hero of heroes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    {{hero.name}}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个代码片段遍历了一组 hero，而我比较关心的几点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过星号来声明一个“母版”实在是太晦涩了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hero&lt;/code&gt; 前的英镑符号（&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;）用于声明一个局部模版变量。这个概念感觉非常鸡肋（如果你偏好不使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;，你也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var-&lt;/code&gt; 前缀写法）&lt;/li&gt;
  &lt;li&gt;为 HTML 加入了循环语义的HTML 特性（attribute）&lt;code class=&quot;highlighter-rouge&quot;&gt;ngFor&lt;/code&gt; 是 Angular 特有的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相比上面 Angular 2 的语法，React 的语法可是纯净的 JavaScript （不过我得承认下面的属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 是个 React 的私货）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  { heroes.map(hero =&amp;gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{hero.id}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{hero.name}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  )}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;鉴于 JS 原生支持循环，React JSX 利用 JS 的力量来做到这类事情简直易如反掌，配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 能做的还远不止此。&lt;/p&gt;

&lt;p&gt;去看看 &lt;a href=&quot;https://angular.io/docs/ts/latest/guide/cheatsheet.html&quot;&gt;Angular 2 速查表&lt;/a&gt;？那不是 HTML，也不是 JavaScript……这叫 &lt;strong&gt;Angular&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;读懂 Angular：&lt;/strong&gt; 学一大堆 Angular 特有的语法&lt;/p&gt;

  &lt;p&gt;读懂 React： 学 JavaScript&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 因为语法和概念的简约而与众不同。我们不妨品味下当今流行的 JS 框架/库都是如何实现遍历的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Ember&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; 
&lt;span class=&quot;nx&quot;&gt;Angular&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ng&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;repeat&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Angular&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ngFor&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Knockout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foreach&quot;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;直接用&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;就好啦&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了 React，所有其它框架都用自己的专有语法重新发明了一个我们在 JavaScript 常见得不能再常见的东西：&lt;strong&gt;循环&lt;/strong&gt;。这大概就是 React 的美妙之处，利用 JavaScript 的力量来处理标签，而不是什么奇怪的新语法。&lt;/p&gt;

&lt;p&gt;Angular 2 中的奇怪语法还有点击事件的绑定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;onSelect(hero)&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相反，React 再一次使用了普通的 JavaScript：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onSelect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且，鉴于 React 内建了一个模拟的事件机制（Angular 2 也有），你并不需要去担心使用内联语法声明事件处理器所暗含的性能问题。&lt;/p&gt;

&lt;p&gt;为什么要强迫自己满脑子都是一个框架的特殊语法呢？为什么不直接拥抱 JS 的力量？&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;奢华的开发体验&lt;/h4&gt;

&lt;p&gt;JSX 具备的代码自动补全、编译时检查与丰富的错误提示已经创造了非常棒的开发体验，既为我们减少了输入，与节约了时间。而配合上热替换（hot reloading）与时间旅行（time travel），你将获得前所未有的开发体验，效率高到飞起。&lt;/p&gt;

&lt;p&gt;原文这里链了个 Youtube 上的视频：&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&amp;amp;feature=youtu.be&quot;&gt;Dan Abramov - Live React: Hot Reloading with Time Travel at react-europe 2015&lt;/a&gt;，大家自备梯子。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;担心框架的大小？&lt;/h4&gt;

&lt;p&gt;这里是一些常见框架/库压缩后的大小（&lt;a href=&quot;https://gist.github.com/Restuta/cda69e50a853aa64912d&quot;&gt;来源&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Angular 2:&lt;/strong&gt; 566k (766k with RxJS)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ember:&lt;/strong&gt; 435k&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js&quot;&gt;&lt;strong&gt;Angular 1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 143k&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React + Redux:&lt;/strong&gt; 139k&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出的都是框架级的、用于浏览器且压缩后的大小（但并未 gzip）。需要补充的是，Angular 2 的尺寸在最终版本发布时应该会有所减小。&lt;/p&gt;

&lt;p&gt;为了做一个更真实的对比，我将 Angular 2 &lt;a href=&quot;https://angular.io/docs/ts/latest/tutorial/&quot;&gt;官方教程&lt;/a&gt;中的 Tour of Heroes 应用用 Angular 2 和 React（还用上了新的 &lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;React Slingshot&lt;/a&gt; 入门套件）都实现了一遍，结果如何呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/angular-2-tour-of-heroes/tree/master&quot;&gt;&lt;strong&gt;Angular 2&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 764k 压缩后&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/react-tour-of-heroes&quot;&gt;&lt;strong&gt;React + Redux&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 151k 压缩后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;strong&gt;做一个差不多的东西，Angular 2 目前的尺寸是 React + Redux 的五倍还多&lt;/strong&gt;。重要的事情再说一遍，Angular 2 的最终版本应该会减重。&lt;/p&gt;

&lt;p&gt;不过，我承认关于框架大小的担忧可能被夸大了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;大型应用往往至少有几百 KB 的代码，经常还更多，不管它们是不是使用了框架。开发者需要做很多的抽象来构建一个复杂的软件。无论这些抽象是来自框架的还是自己手写的，它都会对应用的加载性能造成负面影响。&lt;/p&gt;

  &lt;p&gt;就算你完全杜绝框架的使用，许多应用仍然是几百 KB 的 JavaScript 在那。 — Tom Dale &lt;a href=&quot;http://tomdale.net/2015/11/javascript-frameworks-and-mobile-performance/&quot;&gt;JavaScript Frameworks and Mobile Performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom 的观点是对的。像 Angular、Ember 这样的框架之所以更大是因为它们自带了更多的功能。&lt;/p&gt;

&lt;p&gt;但是，我关心的点在于：很多应用其实用不到这种大型框架提供的所有功能。在这个越来越拥抱微服务、微应用、&lt;a href=&quot;http://www.npmjs.com&quot;&gt;单一职责模块（single-responsibility packages）&lt;/a&gt;的时代，&lt;strong&gt;React 通过让你自己挑选必要模块，让你的应用大小真正做到量身定做&lt;/strong&gt;。在这个有着 200,000 个 npm 模块的世界里，这点非常强大。&lt;/p&gt;

&lt;h4 id=&quot;react-unix-httpsenwikipediaorgwikiunixphilosophy&quot;&gt;React 信奉&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy&quot;&gt;Unix 哲学&lt;/a&gt;.&lt;/h4&gt;

&lt;p&gt;React 是一个类库。它的哲学与 Angular、Ember 这些大而全的框架恰恰相反。你可以根据场景挑选各种时髦的类库，搭配出你的最佳组合。JavaScript 世界在飞速发展，React 允许你不断用更好的类库去迭代你应用中的每个小部分，而不是傻等着你选择的框架自己升级。&lt;/p&gt;

&lt;p&gt;Unix 久经沙场屹立不倒，原因就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小而美、可组合、目的单一，这种哲学永远不会过时。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 作为一个专注、可组合并且目的单一的工具，已经被&lt;a href=&quot;https://github.com/facebook/react/wiki/Sites-Using-React&quot;&gt;全世界的各大网站们&lt;/a&gt;使用，预示着它的前途光明（当然，Angular 也被用于&lt;a href=&quot;https://www.madewithangular.com/#/&quot;&gt;许多大牌网站&lt;/a&gt;）。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;谢幕之战&lt;/h4&gt;

&lt;p&gt;Angular 2 相比第一代有着长足的进步。新的组件模型比第一代的指令（directives）易学许多；新增了对于同构／服务器端渲染的支持；使用虚拟 DOM 提供了 3-10 倍的性能提升。这些改进使得 Angular 2 与 React 旗鼓相当。不可否认，它功能齐全、观点鲜明，能够显著减少 “JavaScript 疲劳” 。&lt;/p&gt;

&lt;p&gt;不过，Angular 2 的大小和语法都让我望而却步。Angular 致力的 HTML 中心设计比 React 的 JavaScript 中心模型要复杂太多。在 React 中，你并不需要学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;ng-什么什么&lt;/code&gt; 这种框架特有的 HTML 补丁（shim），你只要写 JavaScript 就好了。这才是我相信的未来。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51#.v4y4euy1r&quot;&gt;Angular 2 versus React: There Will Be Blood&lt;/a&gt;，其实&lt;a href=&quot;http://www.w3ctech.com/topic/1675?from=timeline&amp;amp;isappinstalled=0&quot;&gt;之前有人翻译过&lt;/a&gt;，但是翻得水平有一点不忍直视，我们不希望浪费这篇好文章。  &lt;br /&gt;
本文由 &lt;a href=&quot;https://www.zhihu.com/people/li-ling-hao&quot;&gt;@李凌豪&lt;/a&gt; &lt;a href=&quot;https://www.zhihu.com/people/huxpro&quot;&gt;@黄玄&lt;/a&gt; 联合翻译，首次发布于&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine&quot;&gt;前端外刊评论 · 知乎专栏&lt;/a&gt;，转载请保留原文链接 ;)&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/02/01/React-vs-Angular2/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/02/01/React-vs-Angular2/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>都 2015 年了，CSS 怎么还是这么糟糕</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;watch-slides-httphuangxuanmecss-sucks-2015&quot;&gt;&lt;a href=&quot;http://huangxuan.me/css-sucks-2015&quot;&gt;Watch Slides →&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://huangxuan.me/css-sucks-2015/attach/qrcode.png&quot; width=&quot;350&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;small class=&quot;img-hint&quot;&gt;你也可以通过扫描二维码在手机上观看&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这个 Web Slides 开源在&lt;a href=&quot;https://github.com/Huxpro/css-sucks-2015&quot;&gt;我的 Github 上&lt;/a&gt;，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp;amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目&lt;/p&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Document Times
    &lt;ul&gt;
      &lt;li&gt;Frameworks&lt;/li&gt;
      &lt;li&gt;Style Guide
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;OOCSS&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;SMACSS&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Pre-processer&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;PostCSS&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application Times
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Shadow DOM&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS “4”&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Naming Convention
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;BEM&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;SUIT&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS in JS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS Modules&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Interoperable CSS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PostCSS, again&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;My Opinionated Proposal
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;POCss&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pocss-page-override-components-css&quot;&gt;POCss: Page Override Components CSS&lt;/h2&gt;

&lt;h3 id=&quot;scoping-components-brsmall-styleline-height2emcss-blocks-should-only-be-used-inside-a-component-of-the-same-namesmall&quot;&gt;1. Scoping Components &lt;br /&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;CSS Blocks should only be used inside a component of the same name.&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.scss
&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--mofierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;__decendentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--modifierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.isStateOfComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;./index.scss&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CSS is &lt;em&gt;always bundled&lt;/em&gt; with components&lt;br /&gt;(from loading, mount to unmount)&lt;/p&gt;

&lt;h3 id=&quot;components-can-be-overrode-by-pages-brsmall-styleline-height2emthere-is-always-requirements-to-rewrite-styles-of-components-in-pagessmall&quot;&gt;2. Components can be Overrode by Pages &lt;br /&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;There is always requirements to rewrite styles of components in pages&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/PageA.scss
&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;#PageA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.pagelet-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;.pagelet-descendent-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* override */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;./PageA.scss&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;#Page&lt;/em&gt; for absolutely scoping between pages&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;.pagelet-name&lt;/em&gt; should be lowercase to prevent conflicting with components&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why-poc&quot;&gt;Why POC?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It’s technology-agnostic&lt;/strong&gt;&lt;br /&gt;
&lt;small&gt;
  &lt;em&gt;One css framework can be played with whatever technology stacks&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;You can combined Scss, PostCSS and whatever you want&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Solving problems, and easy&lt;/strong&gt;&lt;br /&gt;
&lt;small&gt;
  &lt;em&gt;Makes reading and teamwork much easier&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;Get all benefit from BEM, SUITCSS and others&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Leverage the power of cascading properly&lt;/strong&gt;&lt;br /&gt;
&lt;small&gt;
  &lt;em&gt;Scoping components but allow reasonable overriding&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;It’s pragmatic, flexible and hitting the sweet spot&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;Reveal.js&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/12/28/css-sucks-2015/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/12/28/css-sucks-2015/</guid>
        
        <category>前端开发</category>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>iOS 9，为前端世界都带来了些什么？「译」</title>
        <description>&lt;p&gt;2015 年 9 月，Apple 重磅发布了全新的 iPhone 6s/6s Plus、iPad Pro 与全新的操作系统 watchOS 2 与 tvOS 9（是的，这货居然是第 9 版），加上已经发布的 iOS 9，它们都为前端世界带来了哪些变化呢？作为一个 web 开发者，是时候站在我们的角度来说一说了！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注！&lt;/strong&gt; 该译文存在大量英文术语，笔者将默认读者知晓 ES6、viewport、native app、webview 等常用前端术语，并不对这些已知术语进行汉语翻译&lt;br /&gt;
对于新发布或较新的产品名称与技术术语，诸如 Apple Pen、Split View 等专有名词，笔者将在文中使用其英文名，但会尝试对部分名词进行汉语标注&lt;br /&gt;
另外，出于对 wiki 式阅读的偏爱，笔者为您添加了很多额外的链接，方便您查阅文档或出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;简而言之&lt;/h3&gt;

&lt;p&gt;如果你不想阅读整篇文章，这里为你准备了一个总结：&lt;/p&gt;

&lt;h6 id=&quot;section-1&quot;&gt;新的设备特性&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;iPhone 6s 与 6s Plus 拥有 &lt;strong&gt;“&lt;a href=&quot;http://www.apple.com/iphone-6s/3d-touch/&quot;&gt;3D Touch&lt;/a&gt;”&lt;/strong&gt;，这是一个全新的硬件特性，它可以侦测压力，是一个可以让你拿到手指压力数据的 API&lt;/li&gt;
  &lt;li&gt;iPad Pro 的 viewport 为 1024px，与以往的 iPad 全都不同&lt;/li&gt;
  &lt;li&gt;想在 iPad Pro 上支持新的 Apple Pen？不好意思，目前似乎并没有适用于网站的 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;web-&quot;&gt;新的操作系统特性（与 web 相关的）&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;iPad 上的 Safari 现在可以通过 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForSlideOverAndSplitView.html#//apple_ref/doc/uid/TP40015145-CH13-SW1&quot;&gt;Split View&lt;/a&gt;（分屏视图）与其他应用一起使用，这意味着新的 viewport 尺寸将会越来越常见&lt;/li&gt;
  &lt;li&gt;新的 Safari View Controller（&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/SafariServices/Reference/SFSafariViewController_Ref/index.html#//apple_ref/occ/cl/SFSafariViewController&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSafariViewController&lt;/code&gt;&lt;/a&gt;）可以让你在 native app 内提供与 Safari 界面、行为连贯一致的应用内网页浏览体验&lt;/li&gt;
  &lt;li&gt;注意啦！Safari 新加入了 Content Blocker（内容拦截器）。以后，并不是所有的访问都一定会出现在你的 Google Analytics 了&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12&quot;&gt;Universal Links&lt;/a&gt; 可以让应用的拥有者在 iOS 内部“占有”自己的域名。因此，访问 yourdomain.com 将会打开你的应用（类似 Android 的 Intents 机制）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308&quot;&gt;App Search（应用搜索）&lt;/a&gt;：现在，Apple 将会抓取你的网页内容（与 native app 内容）用于 Spotlight 与 Siri 的搜索结果，&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8&quot;&gt;想知道你的标签都兼容吗？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;你的网站现在可以通过 JavaScript API 访问 iCloud 的用户数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;api-&quot;&gt;新的 API 支持&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing&quot;&gt;Performance Timing API&lt;/a&gt; 在 iOS 9 得到回归&lt;/li&gt;
  &lt;li&gt;关于 HTML5 Video，你现在可以在支持 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForPictureInPicture.html#//apple_ref/doc/uid/TP40015145-CH14&quot;&gt;Picture in Picture（画中画）&lt;/a&gt;的 iPad 设备上提供这项新功能；你的视频甚至可以在 Safari 关闭后继续播放&lt;/li&gt;
  &lt;li&gt;更好的 ES6 支持：classes（类）, computed properties（可计算属性）, template literals（模版字符串）等&lt;/li&gt;
  &lt;li&gt;Backdrop CSS filters（背景滤镜）&lt;/li&gt;
  &lt;li&gt;CSS @supports 与 CSS Supports JavaScript API&lt;/li&gt;
  &lt;li&gt;CSS Level4 伪选择器&lt;/li&gt;
  &lt;li&gt;用于支持分页内容的 CSS Scroll Snapping&lt;/li&gt;
  &lt;li&gt;WKWebView 现在可以访问本地文件了&lt;/li&gt;
  &lt;li&gt;我们仍然需要等待 Push Notification，camera access，Service Workers 这些现代 web API 的到来&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-2&quot;&gt;新的操作系统&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;新一代 Apple TV 的 &lt;strong&gt;tvOS&lt;/strong&gt;： 没有浏览器，也没有 webview。但是 JavaScript、XHR 和 DOM 可以通过一个叫做 TVML 的标记语言来使用&lt;/li&gt;
  &lt;li&gt;Apple Watch 的 &lt;strong&gt;watchOS&lt;/strong&gt;：完全没有任何浏览器和 webview&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;再注！&lt;/strong&gt; 由于原文写于 Apple 发布会之前，为了不让读者感到奇怪，笔者将会对文章进行适当改写与补充，以保证本文的连贯性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ios-&quot;&gt;新的 iOS 设备特性&lt;/h3&gt;

&lt;h5 id=&quot;iphones-6s--3d-touch&quot;&gt;iPhones 6s 与 3D Touch&lt;/h5&gt;

&lt;p&gt;从 web 设计与开发的角度来说，新的 iPhone 6s 与 6s Plus 与之前的版本并没有太多差别。不过，有一个特性注定会吸引我们的目光：&lt;strong&gt;3D Touch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们无法确定 Apple 是不是只是重命名了一下 “Force Touch”（用于 Apple Watch、TrackPad 2 与最新的 MacBook 上）或者 3D Touch 的确是一个为 iPhone 定制的似曾相识却不同的东西。3D Touch 允许操作系统和应用侦测每一个手指与屏幕接触时的压力。从用户体验的角度来说，最大的变化莫过于当你用点力去触碰或者拖拽屏幕时，操作系统将会触发诸如 peek，pop 这些新机制。那么问题来了：&lt;strong&gt;我们是否能够在网站中使用这个新玩意呢？让我们一点点来看：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iOS 9 搭载的 Safari 包含了一些用于 “Force Touch” 的新 API，但它们其实并不是那个用于 iPhone 6s 3D Touch 的 API。你可以理解为这些 API 就是 MacBook 版 Safari 里为 Force Touch 准备的那些 API ，因为共享一套 codebase，所以它理所当然得存在了 iOS 版里而已。&lt;/p&gt;

&lt;p&gt;Force Touch API 为我们添加了两个新东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你的 click 事件处理函数将会从 MouseEvent 中收到一个新的属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;DOM 也新增了四个事件：&lt;code class=&quot;highlighter-rouge&quot;&gt;(webkit)mouseforcewillbegin&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforcedown&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforceup&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforcechange&lt;/code&gt;。下边的示意图将告诉你这些事件是在何时被触发的：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/foceevents.png&quot; alt=&quot;Force Events&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相信你已经从它们的名字中意识到了，这些事件都是基于鼠标而非触摸的，毕竟它们是为 MacBook 设计的。并且，TouchEvent 也并没有包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce&lt;/code&gt; 这个属性，它仅仅存在于 MouseEvent 里。在 iOS Safari 里，你确实可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;onwebkitmouseforce&lt;/code&gt; 这一系列事件处理器，但是很可惜它们并不会被触发，click 返回的 MouseEvent 也永远只能得到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce: 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可喜可贺的是，故事还没有结束。&lt;a href=&quot;https://w3c.github.io/touch-events/&quot;&gt;Touch Events v2 draft spec（触摸事件第二版草案）&lt;/a&gt; 中正式添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;force&lt;/code&gt; 属性。3D Touch 也得以在 iPhone 6s 与 6s+ 中通过 TouchEvent 访问到。不过，笔者也要在这里提醒大家，由于没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitmouseforcechange&lt;/code&gt; 这样给力的事件，在手机上我们只能通过 &lt;strong&gt;轮询 TouchEvent 的做法&lt;/strong&gt; 来不断检测压力值的改变……非常坑爹&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/fr3ino&quot;&gt;@Marcel Freinbichler&lt;/a&gt; 第一个在 Twitter 上晒出了自己的 &lt;a href=&quot;http://freinbichler.me/apps/3dtouch&quot;&gt;Demo&lt;/a&gt;。在 6s 或 new Macbook 的 Safari（目前仅 Safari 支持）上访问就可以看到圆圈会随着压力放大。墙内的小伙伴可以直接试试下面这个圆圈，体验下 3D/Force Touch 带来的的奇妙体验。&lt;/p&gt;

&lt;iframe src=&quot;http://huangxuan.me/forcify/&quot; style=&quot;
    width:100%;
    height:500px;
    border: 0;
&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;如果你不巧在用不支持 3D/Force Touch 的设备，发现尼玛用力按下去之后居然圆圈也有反映！？&lt;/p&gt;

&lt;p&gt;放心，这真的不是你的设备突然习得了“感应压力”这项技能，而是因为 &lt;a href=&quot;http://huangxuan.me/forcify&quot;&gt;Forcify&lt;/a&gt; 是一个用于在所有设备上 polyfill 3D/Force Touch API 的 JS 库……它不但封装了 OSX/iOS 两个平台之间 API 的差异，还使用”长按”来模拟了 &lt;code class=&quot;highlighter-rouge&quot;&gt;force&lt;/code&gt; 值的变化……&lt;/p&gt;

&lt;h5 id=&quot;ipad-pro&quot;&gt;iPad Pro&lt;/h5&gt;

&lt;p&gt;全新的 iPad Pro（12.9 寸）打破了以往 iPad 渲染网站的方式。在此之前，市面上所有的 iPad（从初代 iPad，到 iPad Air 4，到 iPad Mini）都是以 768px 的宽度提供 viewport。&lt;/p&gt;

&lt;p&gt;而屏幕更大的 iPad Pro 选择了宽 1024px 的 viewport，这使得它天生就能容纳更多的内容。不少人说iPad Pro 就是抄 Microsft Surface Pro 的嘛……嗯哼，IE/Edge 在 Surface Pro 上就是以 1024px 作为视口宽度的……&lt;/p&gt;

&lt;p&gt;从交互的角度上来说，iPad Pro 虽然不支持 3D Touch，但是可以搭配 Smart Keyboard 与/或 Apple Pen（带有压力侦测）使用。对于键盘其实并没有什么好说的，如果一个网站在搭配键盘的桌面电脑上好用，它在 iPad Pro 上应该也不赖。而对于 Apple Pen，很可惜，目前似乎并没有 API 能让你在网站上获得这根笔的压力与角度。&lt;/p&gt;

&lt;h3 id=&quot;ios--1&quot;&gt;新的 iOS 操作系统特性&lt;/h3&gt;

&lt;h5 id=&quot;ipad-&quot;&gt;iPad 上的多任务处理&lt;/h5&gt;

&lt;p&gt;自 iOS 9 起，iPad 允许两个应用在同一时刻并肩执行，有三种方式：&lt;strong&gt;Slide Over&lt;/strong&gt;，&lt;strong&gt;Split View&lt;/strong&gt; 与 &lt;strong&gt;Picture-in-Picture&lt;/strong&gt;。不过，每一种方式都有其硬件需求，比如说 Slide Over 需要 iPad Air, iPad Mini 2 以上的设备，而 Split View 由于对内存的要求目前只支持 iPad Air 2 与 iPad Pro。&lt;/p&gt;

&lt;h6 id=&quot;slide-over&quot;&gt;Slide Over（滑过来！）&lt;/h6&gt;

&lt;p&gt;Slide Over 支持的 App 并不多，不过 Safari 名列其中，这意味着我们的网站将可能在这个模式下被渲染。当网站处于 Slide Over 模式下时，它将在屏幕的右 1/4 位置渲染，并且置于其他 native app 之上。&lt;/p&gt;

&lt;p&gt;这个模式也为 Responsive Web Design（响应式网站设计）提出了新的挑战：&lt;strong&gt;一个只为 iPad 优化的网站，也需要能在该设备上以无需手动刷新的形式支持小屏幕的渲染。&lt;/strong&gt;因此，如果你正在使用服务器端探测（RESS），那么你的 iPad 版本需要以某种方式包含手机版本的网站，或者在进入该模式后重新加载一次。（如果你不了解 RESS，你可以观看我的&lt;a href=&quot;/2014/11/20/responsive-web-design/&quot;&gt;另一篇博文&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/slideover.png&quot; alt=&quot;Slide Over&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个模式下，无论横屏还是竖屏，所有的 iPad（包括 Pro）都会把你的网站以 320px 的 viewport 宽度进行渲染，就好像在一个大 iPhone 5 上一样。你可以在 CSS 中通过 media query（媒体查询）探测到这个模式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* iPad Air or iPad Mini */
(device-width: 768px) and (width: 320px)
/* iPad Pro */
(device-width: 1024px) and (width: 320px)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;split-view&quot;&gt;Split View（分屏视图）&lt;/h6&gt;

&lt;p&gt;在较新版本的 iPad 上，你可以将 Slide Over 的 Side View（侧视图）升级为 Split View。此时，两个应用将以相同比例在你的屏幕上同时工作。&lt;/p&gt;

&lt;p&gt;在这个模式下，我们的网站将可能……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 1/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 犹如 iPhone 5，宽 320px。而在 iPad Pro 上则像是 iPhone 6：宽 375px&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 1/2 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 507px 宽，而在 iPad Pro（横屏）下呈现为 678px 宽&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 2/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 694px 宽，而在 iPad Pro（横屏）下呈现为 981px 宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/splitview.png&quot; alt=&quot;Split View&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;picture-in-picture&quot;&gt;Picture in Picture（画中画）&lt;/h6&gt;

&lt;p&gt;在一些较新版本的 iPad 上，使用 HTML5 video 标签的网站可以将其暴露到 Picture in Picture 机制中。通过 API（本文稍后会讲）或用户的触发，视频可以独立于网站在其他应用的上方继续播放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/pip.png&quot; alt=&quot;Picture in Picture&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;ios-9-&quot;&gt;iOS 9 下的响应式网页设计&lt;/h5&gt;

&lt;p&gt;下图向你展示了 iOS 9 所有可能的 viewport 尺寸，检查检查你的响应式断点都包含它们了吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/ios9rwd.png&quot; alt=&quot;iOS 9 RWD&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;safari-view-controller&quot;&gt;Safari View Controller&lt;/h5&gt;

&lt;p&gt;如果你用过 Twitter 或者 Facebook（或者微信，微博……），那么你一定知道很多 native app 在打开一个网页链接时并不会默认使用 Safari。它们试图让你留在它们的应用里，所以通过提供 webview 让你在应用内进行网页浏览。可是问题在于，这类 webview 并不会与浏览器共享 cookies，sessions，autofill（自动填充）与 bookmark（书签），为了解决这些问题，就有了 Safari View Controller。&lt;/p&gt;

&lt;p&gt;现在，native app 可以使用 Safari View Controller 来打开网站，它提供与 Safari 完全一致的隐私政策、local storage，cookies、sessions 同时让用户留在你的 app 中，它通过一个 “Done”（完成）按钮使用户可以回到 native app 的上一个 controller。这个全新的 controller 还可以让我们在 Share（分享）按钮上添加自定义的操作，这些操作在用户使用 Safari 应用时并不会出现。同时，native app 对这个自定义 Safari 实例具有完全的内容控制，你可以屏蔽不想被渲染的内容。&lt;/p&gt;

&lt;p&gt;当你需要基于 web 的鉴权，比如 OAuth 时，使用 Safari View Controller 同样是一个好主意，这样就不再需要打开浏览器再重定向回你的应用。不过注意了，Safari View Controller 只适用于在线、公开的 web 内容。如果你的 web 内容假设在本地或者私服，那么 WKWebView 仍然是最推荐的选择。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;笔者八卦一下，Safari View Controller 实际上也算是半个社区推进的产物。早在 2014 年 12 月，Tumblr 的 iOS 工程师 Bryan 就发表了一篇著名的 &lt;a href=&quot;http://bryan.io/post/104845880796/we-need-a-safari-view-controller&quot;&gt;We need a “Safari view controller”&lt;/a&gt; 叙述现有 webview 在第三方登录鉴权时的窘境。&lt;br /&gt;
2015 年 6 月，Apple Safari 工程师 Ricky Mondello 的 Twitter 宣告了这个设想的落地：You all asked for it. Come see me introduce it. Introducing Safari View Controller 1:30 PM, Tuesday. Nob Hill.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;safari-content-blockers&quot;&gt;Safari Content Blockers&lt;/h5&gt;

&lt;p&gt;现在，iOS 9 上的 Safari 支持一种全新的 App Extensions（应用拓展）：&lt;strong&gt;Content Blocker&lt;/strong&gt;（内容拦截器）。这类拓展以 native app 的形式存在，你可以在 App Store 上下载到，它们可以拦截 Safari 内的任何内容，包括：跟踪器、广告、自定义字体、大图片、JavaScript 文件等等。&lt;/p&gt;

&lt;p&gt;作为 web 开发者，尽管我们不能禁用 Content Blocker，我们仍然应该注意到它们的存在。诸如 Crystal 的一些拦截器宣称他们&lt;a href=&quot;http://murphyapps.co/blog/2015/8/22/crystal-benchmarks&quot;&gt;可以提高网页的打开速度&lt;/a&gt;。Crystal 声称可以加快网页的加载速度 3.9 倍并且少用 53% 的带宽。不过问题是：到底哪些东西被拦截器拦截了？&lt;a href=&quot;http://thenextweb.com/apple/2015/08/27/content-blocking-in-ios-9-is-going-to-screw-up-way-more-than-just-ads/&quot;&gt;这篇文章&lt;/a&gt;提到了一些我们未来可能会遇到的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/crystal.png&quot; alt=&quot;crystal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 iOS 9 发布后，Peace，一个 Content Blocker，曾在 App Store 排名跻身前十。从用户的角度来说，如果一个网站由于被 Content Blocker 拦截了某些重要资源而不能正常工作，你可以长按重新加载按钮并且以不启用 Content Blocker 的方式重新加载这个网站（见下图，来自 MacWorld.com）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/macworld.png&quot; alt=&quot;disable content blocker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Content Blocker 能隐藏元素，也有能力通过 CSS 选择器、域名、类型、或者 URL 来过滤并拦截某个文件的加载，&lt;a href=&quot;https://itunes.apple.com/us/app/purify-blocker-fast-clutter/id1030156203?ls=1&amp;amp;mt=8&quot;&gt;Purify Blocker&lt;/a&gt; 给用户提供了拦截某一种内容类型的进阶选项，比如 Web Fonts。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/purify.png&quot; alt=&quot;purify&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;wkwebview-&quot;&gt;WKWebView 的增强&lt;/h5&gt;

&lt;p&gt;UIWebView 已经被官方弃用，虽然它还在在那，不过它再也不会得到什么升级。与此相反，WKWebView 正在取代它的位置。一个最受期待的特性现在终于推出：加载本地文件到 WKWebView。因此，现在 Apache Cordova 应用与其他 web 内容都可以直接从 iOS 包中使用本地文件了，不再需要各种诡异的 hack 了。&lt;/p&gt;

&lt;p&gt;此外，还有一些新特性也一并推出。比如说，通过 WKWebsiteDataStore，Objective-C 或 Swift 有能力查询与管理 webview 的本地存储（比如 localStorage 或 IndexedDB）。这就允许我们将原有的数据存储替换成新的某些东西，比如说替换成一个不永久的（Chrome for iOS 的隐身模式就需要这种东西）&lt;/p&gt;

&lt;h5 id=&quot;universal-links&quot;&gt;Universal Links（通用链接）&lt;/h5&gt;

&lt;p&gt;如果你既有一个网站，又有一个 native app，你现在可以通过 Universal Links 来增强用户体验。它允许你在操作系统内“占有”自己的域名，这样，一切指向你网站的链接都会被重定向到你的 app。&lt;/p&gt;

&lt;p&gt;目前，所有的 app 都是通过自定义 URI 来达到这个效果的，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;comgooglemaps://&lt;/code&gt; 就可以用来从网站或者其他原生 iOS 应用中打开 Google Maps。&lt;/p&gt;

&lt;p&gt;想要提供这个特性的话，你首先需要在 native app 中实现 Deep Linking（深度链接），让应用中的内容与 Safari 的 URL 吻合。然后，你需要在 Apple 的网站上关联你的域名，取得这个域名的 SSL 认证并且把签名后的 JSON 部署到该域名上。这是为了防止第三方的应用“占据”了属于你而不属于他们的域名，比如说 twitter.com 被非 Twitter 的其他应用占据掉。&lt;/p&gt;

&lt;p&gt;目前唯一的缺点是用户好像并不能决定到底以哪种方式来打开内容（使用 web 还是 app），不过我们可以观望一段时间看看它会如何发展。在不远的这段时间里，你可能会发现在网站或 Google 搜索里点击一个链接时会没有任何预警的就跳进了 native app 里。&lt;/p&gt;

&lt;h5 id=&quot;app-search&quot;&gt;App Search（应用搜索）&lt;/h5&gt;

&lt;p&gt;Apple 带着自己的 web 蜘蛛杀进了搜索的市场，而我们需要支持它得以在 Siri 与 Spotlight 中提升自己的曝光率。这在我们同时拥有网站与 app 时尤为重要，因为现在 Apple 会索引你网站的内容，但打开时却可能将用户带到了 app 里去。&lt;/p&gt;

&lt;p&gt;尽管这会开启 SEO 的新篇章，不过却相当容易。你需要使用一些标签标准，诸如 &lt;a href=&quot;http://schema.org/&quot;&gt;Web Schema&lt;/a&gt;、&lt;a href=&quot;http://applinks.org&quot;&gt;AppLinks&lt;/a&gt;、&lt;a href=&quot;http://ogp.me&quot;&gt;OpenGraph&lt;/a&gt; 或者 &lt;a href=&quot;https://dev.twitter.com/cards/mobile&quot;&gt;Twitter Cards&lt;/a&gt;，配合上 App Banner 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;app-argument&lt;/code&gt;，如果你有你自己的 native app 的话。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于“让你的网页支持 Apple 搜索”的更多详情，请查阅 Apple 官方文档 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8-SW5&quot;&gt;Mark Up Web Content&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 刚刚发布了一个 &lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot;&gt;App Search Validation Tool（应用搜索验证工具）&lt;/a&gt;来帮助你搞清楚，需要向你的网站添加什么才能支持 App Search&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/appsearch-1024x467.png&quot; alt=&quot;App Search&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;cloudkit-js&quot;&gt;CloudKit JS&lt;/h5&gt;

&lt;p&gt;如果你拥有一个 native app，你很可能会将用户数据保存在 iCloud 上。在过去，只有 iOS 与 Mac 应用被允许使用它。现在，通过 CloudKit JS，你的网站也可以连接上 iCloud 数据了。&lt;/p&gt;

&lt;h5 id=&quot;back-button&quot;&gt;Back Button&lt;/h5&gt;

&lt;p&gt;现在，当你链接到一个 native app 时（通过自定义 URI 或者 Universal Link），Safari 会询问用户是否想要使用 native app 打开这个链接（见下图）。如果用户同意了，这个应用将被打开，并且在左上角会有一个返回按钮可以返回 Safari ，返回到你的网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/back.png&quot; alt=&quot;backbutton&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;api--1&quot;&gt;新的 API 支持&lt;/h3&gt;

&lt;h5 id=&quot;navigation-timing-api&quot;&gt;Navigation Timing API&lt;/h5&gt;

&lt;p&gt;Navigation Timing API 在 iOS 9 迎来了回归。让我们回忆一下，这货添加于 8.0 却在一周后的 8.1 中去掉了。这对于 Web 性能是个好消息。通过这个 API，我们可以更精确的测量时间，还可以获得一系列有关加载过程的时间戳，它们对于追踪与在真实场景中做决策来改进用户体验都非常有用。&lt;/p&gt;

&lt;h5 id=&quot;picture-in-picture-1&quot;&gt;Picture in Picture&lt;/h5&gt;

&lt;p&gt;PiP API（被称为 Presentation Mode API）目前只支持 iOS，它允许我们手动让一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素进入或离开 PiP 模式如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;video.webkitSupportsPresentationMode&lt;/code&gt; 是支持的。&lt;/p&gt;

&lt;p&gt;举个例子，我们可以在内嵌模式与 PiP 模式中切换：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;video.webkitSetPresentationMode(
    video.webkitPresentationMode === &quot;picture-in-picture&quot; ?
    &quot;inline&quot; : 
    &quot;picture-in-picture&quot;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们还可以通过新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;onwebkitpresentationmodechanged&lt;/code&gt; 事件来检测 Presentation Mode（展示模式）的变化。&lt;/p&gt;

&lt;h5 id=&quot;backdrop-css&quot;&gt;Backdrop CSS&lt;/h5&gt;

&lt;p&gt;iOS 7 与最近的 Mac OS 使用 Backdrop filter（背景滤镜）来模糊背景（指 native 开发），而在网站上实现这个却并不容易。&lt;/p&gt;

&lt;p&gt;iOS 9 上的 Safari 现在支持了来自 Filter Effect v2 spec（滤镜特效第二版规范）的 &lt;strong&gt;backdrop-filter&lt;/strong&gt;。比如说，我们可以使用一个半透明的背景并且对其背后的背景使用滤镜：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;header {
   background-color: rgba(255, 255, 255, 0.4);
   -webkit-backdrop-filter: blur(5px);
   backdrop-filter: blur(5px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/backdrop.png&quot; alt=&quot;backdrop&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;css-scroll-snapping&quot;&gt;CSS Scroll Snapping&lt;/h5&gt;

&lt;p&gt;在 web 上实现分页内容（比如相册跑马灯）总是非常麻烦，无论是使用 JavaScript 框架、touch 事件还是 hacking 滚动条等等。Apple 新添加了一个很赞的 CSS 特性叫做 CSS Scroll Snapping。这个特性新增了一系列的 CSS 属性让你定义规则或者不规则的 snap zone（停留区域），这样滚动的位置就会“啪”地一下停在这个区域，而非像以前一样可以停在任何地方。&lt;/p&gt;

&lt;p&gt;来看个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#photo-gallery{
    width: 100%;
    overflow-x: scroll;
    -webkit-scroll-snap-points-x: repeat(100%);
    -webkit-scroll-snap-type: mandatory;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;想要看个跑起来后的例子？笔者为大家准备了 webkit 的官方 &lt;a href=&quot;http://www.webkit.org/demos/scroll-snap/&quot;&gt;demo&lt;/a&gt;，不过这个属性目前只支持 iOS 9 Safari 哦，并不支持 webview&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;css-supports&quot;&gt;CSS Supports&lt;/h5&gt;

&lt;p&gt;CSS Supports，包括 CSS &lt;code class=&quot;highlighter-rouge&quot;&gt;@supports&lt;/code&gt; 与来自 CSS Conditional Rules Module Level 3 spec 的 JavaScript CSS Supports API 都在 iOS 上迎来降临。现在，我们可以针对某个 CSS 属性的特定值的支持情况来编写代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@supports(-webkit-scroll-snap-type: mandatory) {
    /* we use it */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，使用 JavaScript：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (CSS.supports(&quot;-webkit-scroll-snap-type&quot;, &quot;mandatory&quot;)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-3&quot;&gt;一些细微的改进&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;ECMAScript 6 的更完善支持：classed、computed properties、template literial 与 week sets&lt;/li&gt;
  &lt;li&gt;新的 CSS Level4 伪类/元素选择器：&lt;code class=&quot;highlighter-rouge&quot;&gt;:not&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:matches&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:any-link&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:placeholder-shown&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:read-write&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:read-only&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Native app 现在可以通过 extension 来向 Safari 的 Shared Links（分享链接）窗口上注入信息&lt;/li&gt;
  &lt;li&gt;大量无前缀 CSS 属性的支持（终于），比如 transition、animation、@keyframes、flex 与 columns&lt;/li&gt;
  &lt;li&gt;Mac OS El Capitán 上的 Safari 9 提供了一个全新设计的 Web Inspector（Web 检查器）。幸运的是，iOS 9 的远程调试完全兼容 Mac OS 上的 Safari 8，所以你倒是不用急着升级你的 Mac OS&lt;/li&gt;
  &lt;li&gt;iOS 9 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;-apple-font&lt;/code&gt; 加入了一些 Dynamic Fonts（动态字体），并且它们现在应用的是 Apple 的新字体：San Francisco，笔者的博客就已经用上它啦&lt;/li&gt;
  &lt;li&gt;scrollingElement 现在可用了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/code&gt; 现在允许你从 iCloud Drive 与已安装的第三方应用，比如 Google Drive 中选择文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/IMG_2017.png&quot; alt=&quot;input file&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当你加载一个 HTTPS 协议的页面时，你不能混用 HTTP 与 HTTPS 的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs&quot;&gt;Bugs&lt;/h3&gt;

&lt;p&gt;Bug 通常都要在几周之后才会显露出来，我也会持续跟进并更新这篇文章。目前为止，我的发现如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于 Home Screen webapps（添加至主屏的 web 应用），&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-mobile-web-app-status-bar-style&lt;/code&gt; 这个 meta 标签不起作用了！所以你现在不能再像过去一样使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;black-translucent&lt;/code&gt; 让你的 webapp 渲染在状态栏的后面了。（iOS 9.2 fixed 了这个 bug）&lt;/li&gt;
  &lt;li&gt;Speech Synthesis API （语音综合 API）不再工作了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;仍在等待……&lt;/h3&gt;

&lt;p&gt;当 Mac 上的 Safari、桌面电脑与 Android 上的 Chrome 都已经为网站支持 Push Notification （通知推送）时，iOS 上的 Safari 仍然不支持这个特性。就 API 而言，我们仍然没有：WebRTC、getUserMedia、Service Worker、FileSystem API、Network Information API、Battery Status API、Vibration API 等等……你又在 iOS 上等待哪些特性呢？&lt;/p&gt;

&lt;h3 id=&quot;watchos--tvos&quot;&gt;watchOS 与 tvOS&lt;/h3&gt;

&lt;p&gt;新发布的 watchOS 2.0 与 tvOS 9.0 都是基于 iOS 的操作系统，它们针对特定的设备发行（Apple Watch 与新的 Apple TV）。从用户的角度来说，那里并没有浏览器了。从开发者的角度，那里也没有 Webview 了。&lt;/p&gt;

&lt;p&gt;尽管有不少人抱怨（大部分都是针对 webview 的缺失），我并不能确定这是不是个坏主意。我猜测 Apple 会尝试通过 Siri 来将 “web” 带给 TV、手表、甚至 CarPlay 的用户。所以，如果你遵循了上述的 “App Search” 的步骤，你的内容将可能通过 Siri 在这些设备上以 widget（小部件）或者快捷回复的形式变得可以访问。&lt;/p&gt;

&lt;p&gt;对于 Apple TV ，它支持使用 JavaScript、DOM API 与 XMLHttpRequest 来让我们构建某种类似 Client-Server webapp 的东西。没有 HTML 和 CSS，这是什么把戏？其实它支持的叫 TVML，是一种基于 XML、为那些可以被渲染在 TV 屏幕上的特定内容而优化后的标签。这些标签只可以在来自应用商店的 native app 中渲染，但是这些 TVML 是由服务器端来生成的。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://www.mobilexweb.com/blog/ios9-safari-for-web-developers&quot;&gt;iOS 9, Safari and the Web: 3D Touch, new Responsive Web Design, Native integration and HTML5 APIs — Breaking the Mobile Web&lt;/a&gt;   &lt;br /&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/12/15/ios9-safari-web/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/12/15/ios9-safari-web/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>iOS</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>「知乎」设计师如何学习前端？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/21921588/answer/69680480&quot;&gt;我在知乎上的回答&lt;/a&gt;，也被刊登于&lt;a href=&quot;http://www.uisdc.com/head-first-front-end&quot;&gt;优秀网页设计&lt;/a&gt;等多个网站上 ;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
    &lt;br /&gt;笔者的经历在知乎就可以看到，大学专业是数字媒体艺术，大一实习过动效设计师，大二拿到了人生第一个大公司 offer 是阿里的交互设计，后来转岗到淘宝旅行的前端团队，现在在微信电影票做前端研发。
    &lt;br /&gt;
    &lt;br /&gt;也是走过了不少野路子，不过还好有小右哥 &lt;a data-hash=&quot;cfdec6226ece879d2571fbc274372e9f&quot; href=&quot;//www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@尤雨溪&quot; data-tip=&quot;p$b$cfdec6226ece879d2571fbc274372e9f&quot;&gt;@尤雨溪&lt;/a&gt; 这样艺术/设计转前端的大神在前面做典范，也证明这条路是玩的通的 ;)
    &lt;br /&gt;
    &lt;br /&gt;接下来就说说自己的学习建议吧，一个小教程，也是自己走过的流程，仅供参考哈
    &lt;br /&gt;
    &lt;br /&gt;------------
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;背景篇&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;在这个时代学习新东西，一定要善于使用 Bing/Google 等搜索引擎…网络上的资源非常丰富，自学能力也尤为重要，尤其是对于学习技术！
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;入门篇（HTML/CSS）&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;说起设计师希望学前端的初衷，大概还是因为各种华丽的网页特效/交互太过吸引人，这种感觉大概就是：“Hey，我的设计可以做成网页访问了呢！”
    &lt;br /&gt;好在，“展示”对于前端技术来说反而是最简单的部分。所以，放下你对“编程”两个字的恐惧，&lt;b&gt;从“称不上是编程语言”的 HTML/CSS 开始，先做点有成就感的东西出来吧！&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;对于设计师来说，最有成就感的一定是“可以看到的东西”，而 HTML/CSS 正是用来干这个的，HTML 就是一堆非常简单的标签，而 CSS 无非就是把你画画的流程用&lt;b&gt;英语&lt;/b&gt;按一定的格式写出来而已：
    &lt;br /&gt;
    &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;p&amp;gt; p is paragraph! &amp;lt;/p&amp;gt;

&amp;lt;style&amp;gt;
p { color: red;}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;是不是非常容易，就跟读英语一样！
    &lt;br /&gt;接下来，你就需要开始自学啦，比如常用 HTML 标签的意思，各种 CSS 的属性，还有 CSS 的盒模型、优先级、选择器……放心，它们都很容易；能玩得转 PS/AI/Flash/Axure/AE/Sketch 的设计师们，学这个洒洒水啦
    &lt;br /&gt;
    &lt;br /&gt;推荐几个资源：
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.w3school.com.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;w3school 在线教程&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; (中文，一个很 Low 但是又很好的入门学习网站）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.codecademy.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Learn to code&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; (Codecademy，如果你英文 OK，&lt;b&gt;强烈建议&lt;/b&gt;你使用它进行交互式的学习！里面从 HTML/CSS 到搭建网站的课程都有，免费，生动直观）
            &lt;br /&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;&lt;b&gt;这个阶段的练习主要是“临摹”：用代码画出你想画的网站，越多越好。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;对于书，我&lt;b&gt;非常不推荐&lt;/b&gt;上来就去看各种厚厚的入门/指南书，没必要！这一个阶段应该快速上手，培养兴趣，培养成就感。先做出可以看的东西再说，掌握常用的 HTML/CSS 就够用了
    &lt;br /&gt;
    &lt;br /&gt;如果完成的好，这个阶段过后你大概就可以写出一些简单又好看的“静态网页”了，比如这个作品集/简历：&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/portfolio/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Portfolio - 黄玄的博客&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; （好久没更新了…丢人现眼）
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;入门篇（JavaScript/jQuery）&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;想要在网页上实现一些交互效果，比如轮播图、点击按钮后播放动画？那你就必须要开始学习 JavaScript 了！JavaScript 是一门完整、强大并且非常热门的编程语言，你在浏览器里看到的所有交互或者高级功能都是由它在背后支撑的！
    &lt;br /&gt;
    &lt;br /&gt;举个小栗子：
    &lt;br /&gt;
    &lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;alert(&quot;Hello World!&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;就这一行，就可以在浏览器里弹出 Hello World 啦！
    &lt;br /&gt;
    &lt;br /&gt;在了解一些基础的 JavaScript 概念（变量、函数、基本类型）后，我们可以直接去学习 jQuery，你不用知道它具体是什么（它是一个 JavaScript 代码库），你只要知道它可以显著地降低你编写交互的难度就好了：
    &lt;br /&gt;

```
$(&#39;.className&#39;).click(function(){
    alert(&quot;Hello jQuery&quot;)
})
```

通过 jQuery，我们可以继续使用在 CSS 中学到的“选择器”
    &lt;br /&gt;
    &lt;br /&gt;对于没有编程基础的人来说，想要完全掌握它们两并不容易。作为设计师，很多时候我们可以先不必深究它们的原理，而是尝试直接应用它！这样成就感会来得很快，并且你可以通过实际应用更加理解 JavaScript 是用来做什么的。
    &lt;br /&gt;
    &lt;br /&gt;我仍然推荐你使用 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.w3school.com.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;w3school 在线教程&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 与 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.codecademy.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;codecademy.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 进行学习。另外，你可以看一看诸如《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/10792216/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;锋利的jQuery (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》 这一类非常实用的书籍，可以让你很快上手做出一些简单的效果来！
    &lt;br /&gt;
    &lt;br /&gt;如果学习得顺利，你还可以尝试使用各种丰富的 jQuery 插件，你会发现写出支持用户交互的网站也没有那么困难～很多看上去很复杂的功能（比如轮播图、灯箱、下拉菜单），搜一搜然后看看文档（教程）、改改示例代码就好了。
    &lt;br /&gt;
    &lt;br /&gt;比如说，配合 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//github.com/Huxpro/jquery.HSlider&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Huxpro/jquery.HSlider · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的轮播图插件，你可以很轻松的写出 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/jquery.HSlider/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HSlider | Demo&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的网页相册或者 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/jquery.HSlider/demo-weather-app/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HSlider | Weather&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的手机端 App 原型～
    &lt;br /&gt;
    &lt;br /&gt;最后，我想推荐下 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//getbootstrap.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bootstrap · The world&#39;s most popular mobile-first and respons&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，这是世界上最知名的前端 UI 框架之一，提供了大量 CSS 样式与 jQuery 插件。它非常容易学习并且中英文教程都非常健全，你并不需要理解它背后的工作原理就能很好的使用它，让你快速达到“可以建站的水平”。有余力的话，你不但可以学习如何使用它，还可以学习它背后的设计思想。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;转职方向一：前端重构 （Web Rebuild）&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;业内通常把专精 HTML/CSS 的前端从业人员称为重构，而对于注重视觉效果的设计师来说，在掌握基本的 HTML/CSS 后，就可以朝着这个方向发展了。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;到了这个阶段，你不但要知道怎么写页面，还要知道它们都是为什么，并且知道怎么做更好。这对你理解 Web 世界非常有帮助，并且能帮助你做出更“系统化”的设计。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;CSS 的学问很多，你需要开始理解文档流、浮动流等各种定位的方式与原理，理解 CSS 的继承复用思想、理解浏览器的差异、兼容、优雅降级……这里强烈推荐一本书：《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/4736167/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;精通CSS（第2版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》，虽然前端技术突飞猛进，但这本书的思想永远不会过时。
    &lt;br /&gt;
    &lt;br /&gt;HTML 方面，要开始注重语义化、可访问性与结构的合理，你要开始学习“结构与样式的分离”，这里有一本神书将这种分离做到了极致：《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/2052176/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CSS禅意花园 (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》
    &lt;br /&gt;
    &lt;br /&gt;另外，各种炫酷屌的 CSS 3 属性你一定会喜欢：你可以用媒体查询做响应式网页设计，你可以用 transiton 和 animation 做补间动画与关键帧动画，用 transform 做缩放、旋转、3D变换，还有圆角、渐变、阴影、弹性盒！样样都是设计师的神器！
    &lt;br /&gt;
    &lt;br /&gt;如果你还掌握了 &lt;b&gt;入门篇（JavaScript/jQuery）&lt;/b&gt;的知识，那么&lt;b&gt;恭喜你！你已经可以做出很多有趣的网页了！&lt;/b&gt;很多 minisite 或者微信上的“H5” 小广告，这个程度的你已经可以轻松完成了！
    &lt;br /&gt;
    &lt;br /&gt;配合上你的设计功力，你可以开始尝试创作一些好玩的东西，比如这种富含交互和动画的网站 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/senova/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;绅宝 SENOVA&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，它仍然是基于 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//github.com/Huxpro/jquery.HSlider&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Huxpro/jquery.HSlider · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 实现的！或者给自己做个小小的个人网站试试
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;转职方向二：前端工程师（Front-end Engineer）&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;如果你觉得上述的这些都还满足不了你，你渴望做出更多了不起的交互，甚至你已经喜欢上了编程，想要转行做工程师，或者成为一名全栈设计师，那么你可以朝着这个方向继续发展！
    &lt;br /&gt;
    &lt;br /&gt;这个阶段的最大难度，是你必须&lt;b&gt;学会像一名软件工程师一样思考&lt;/b&gt;。你需要踏踏实实学习编程语言，深入理解作用域、对象、类、封装、继承、面向对象编程、事件侦听、事件冒泡等一大堆编程概念，你还需要了解浏览器，学习 DOM、BOM、CSSOM 的 API，你甚至还需要学习一些网络原理，包括域名、URL、DNS、HTTP 请求都是什么…
    &lt;br /&gt;
    &lt;br /&gt;你可能会被这一大堆名词吓到。确实，想要搞定他们并不容易。但是，你要相信只要你肯花功夫它们也没有那么难，而更重要的是，如果你能拿下他们，你所收获的并不只是这些而已，而是真正跨过了一道大坎 —— &lt;b&gt;你的世界将因此打开， 你看待世界的方式将因此改变&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;对于这个阶段，你可以继续在 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.codecademy.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;codecademy.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 上学习，但是 w3school 已经不够用了，遇到不会的语法，我推荐你查阅 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mozilla 开发者网络&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，这是少数中英文都有的非常专业且友好的网站。
    &lt;br /&gt;
    &lt;br /&gt;同时，你可能需要看一些书本来帮助你学习 JavaScript ：
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt; 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/10546125/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript高级程序设计（第3版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 》或 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/2228378/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript权威指南 (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》，大而全的书只需要一本就够了&lt;/li&gt;
        &lt;li&gt;如果上面这本你觉得太难，你可以先看 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/6038371/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript DOM编程艺术 （第2版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》来过渡一下，这本书比较容易，它会教给你 “优雅降级、渐进增强”的优秀思想&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;如果你能顺利得渡过了这个阶段，我想你已经能做出很多令你自豪的网站了！试着向身边的工程师朋友询问如何购买域名、配置简单的静态服务器，或者搜搜“Github Pages”，然后把你的作品挂在网络上让大家欣赏吧！
    &lt;br /&gt;
    &lt;br /&gt;你还可以试着用 JavaScript 写写小游戏，这不但能锻炼你的编程水平还非常有趣～比如这是我刚学 JS 不久后 hack 一晚的产物 —— 用 DOM 实现的打飞机：&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/aircraft&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hux - Aircraft&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; （不支持手机）
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;入行篇&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;如果你能完成上述所有的学习，你已经是一名非常出色的前端学徒了！对于只是想要丰富技能的设计师或者产品经理来说，接下来的内容可能会让你感到不适 ;(
    &lt;br /&gt;但如果你铁了心想要真正入行进入大公司从事专职前端开发的工作，那么你可以接着往下看：
    &lt;br /&gt;
    &lt;br /&gt;近几年的前端技术发展迅猛，前端工程师早已不是切切图写写页面做点特效就完事的职位，你需要具备相当完善的工程师素质与计算机知识，成为一名真正的工程师。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要非常了解 JavaScript 这门语言&lt;/b&gt;，包括 闭包、IIFE、this、prototype 及一些底层实现（ES、VO、AO）、熟悉常用的设计模式与 JavaScript 范式（比如实现类与私有属性）。另外，新的 ES6 已经问世，包括 class, module, arrow function 等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要非常了解前端常用的网络及后端知识&lt;/b&gt;，包括 Ajax、JSON、HTTP 请求、GET/POST 差异、RESTful、URL hash/query、webSocket、常用的跨域方式（JSONP/CORS、HTTP 强缓存/协商缓存，以及如何利用 CDN 、静态网站/动态网站区别、服务器端渲染/前端渲染区别等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要学习使用进阶的 CSS&lt;/b&gt;，包括熟悉 CSS 3，使用 Scss/Less 等编译到 CSS 的语言，使用 autoprefixer 等 PostCSS 工具，了解 CSS 在 Scope/Namespace 上的缺陷，你还可以学习 CSS Modules、CSS in JS 这些有趣的新玩意
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要非常了解前端的模块化规范&lt;/b&gt;，可能在你学习到这里的时候，Require.js/AMD 已经再见了，但是 CommonJS 与 ES6 Modules 你必须要了解。（你可以观看我的分享《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/js-module-7day/%23/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript Modularization Seven Day&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》 来学习 JS 模块化的历史）
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要熟悉 Git 与 Shell 的使用&lt;/b&gt;，包括基于 git 的版本管理、分支管理与团队协作，包括简单的 Linux/Unix 命令、你要知道大部分程序员的工作可以通过 shell 更快更酷的完成，并且很多“软件”只能通过 shell 来使用。你还可以把你的代码放到 github 上与人分享，并且学习 github 上其他优秀的开源代码
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要熟悉并且习惯使用 Node&lt;/b&gt;，包括了解 npm、使用 Grunt/Gulp/Browserify/Webpack 优化你的工作流、对你的代码进行打包、混淆、压缩、发布，你还可以使用 Express/Koa 配合 MongoDB/Redis 涉足到后端领域，或者尝试用 Node 做后端渲染优化你的首屏体验
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要了解各种 HTML 5 的新 API&lt;/b&gt;，包括 &amp;lt;video&amp;gt;/&amp;lt;audio&amp;gt;，包括 Canvas，webGL、File API、App Cache、localStorage、IndexedDB、Drag &amp;amp; Drop、更高级的 DOM API、Fetch API 等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要学习 JavaScript 的单线程与异步编程方法&lt;/b&gt;，因为它们非常非常常用、包括 setTimeout/setInterval，回调与回调地狱、事件与event loop、还有 Promise 甚至 Async/Await
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要非常了解浏览器&lt;/b&gt;，包括主流浏览器的名称、内核与差异、包括私有属性与 -webkit- 等厂商前缀，你需要学习如何使用 Chrome DevTool，你需要了解浏览器渲染的 reflow/repaint 来避免 Jank 并进行有针对性的性能优化
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要专门学习 Mobile Web&lt;/b&gt;，因为移动互联网是趋势。包括 viewport、CSS pixel、 touch 事件、iOS/Android 浏览器的差异与兼容、移动端的性能优化、300ms delay 等等…你还需要知道 Hybrid 是什么，包括 Cordova/Phonegap，更复杂的比如和 iOS/Android 通信的机制，比如 URI Scheme 或者 JS Bridge
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要学习一些&lt;/b&gt;&lt;b&gt;非常火热的前端框架/库&lt;/b&gt;，他们不但能帮助你更快的进行开发、更重要的是他们背后所蕴含的思想。包括 Backbone、Angular、Vue、React、Polymer 等等、了解它们背后的双向数据绑定、单向数据流、MVC/MVVM/Flux 思想、Web Component 与组件化等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要学习如何构建 web 单页应用&lt;/b&gt;，这是 web 的未来，包括利用 history API 或者 hash 实现路由，包括基于 Ajax + 模版引擎或者其他技术的前端渲染、包括组织较为复杂的软件设计等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;我还建议你学习更多的计算机知识&lt;/b&gt;，它们能对你的代码能起到潜移默化的作用，包括简单的计算机体系结构、更广泛的编程知识（面向对象/函数式等）、栈、堆、数组、队列、哈希表、树、图等数据结构、时间复杂度与空间复杂度以及简单的算法等等
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要了解业内的大神并阅读它们的博客/知乎/微博&lt;/b&gt;，比如 &lt;a data-hash=&quot;cfdec6226ece879d2571fbc274372e9f&quot; href=&quot;//www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@尤雨溪&quot; data-tip=&quot;p$b$cfdec6226ece879d2571fbc274372e9f&quot;&gt;@尤雨溪&lt;/a&gt;&lt;a data-hash=&quot;3ec3b166992a5a90a1083945d2490d38&quot; href=&quot;//www.zhihu.com/people/3ec3b166992a5a90a1083945d2490d38&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@贺师俊&quot; data-tip=&quot;p$b$3ec3b166992a5a90a1083945d2490d38&quot;&gt;@贺师俊&lt;/a&gt;&lt;a data-hash=&quot;3212f9044005e9306aab1b61e74e7ae6&quot; href=&quot;//www.zhihu.com/people/3212f9044005e9306aab1b61e74e7ae6&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@张云龙&quot; data-tip=&quot;p$b$3212f9044005e9306aab1b61e74e7ae6&quot;&gt;@张云龙&lt;/a&gt;&lt;a data-hash=&quot;c5198d4e9c0145aee04dd53cc6590edd&quot; href=&quot;//www.zhihu.com/people/c5198d4e9c0145aee04dd53cc6590edd&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@徐飞&quot; data-tip=&quot;p$b$c5198d4e9c0145aee04dd53cc6590edd&quot;&gt;@徐飞&lt;/a&gt;&lt;a data-hash=&quot;20fdd386a6e59d178b8fe14e2863cb40&quot; href=&quot;//www.zhihu.com/people/20fdd386a6e59d178b8fe14e2863cb40&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@张克军&quot; data-tip=&quot;p$b$20fdd386a6e59d178b8fe14e2863cb40&quot;&gt;@张克军&lt;/a&gt;&lt;a data-hash=&quot;c11336b8607d86bc9090bed90757a34c&quot; href=&quot;//www.zhihu.com/people/c11336b8607d86bc9090bed90757a34c&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@玉伯&quot; data-tip=&quot;p$b$c11336b8607d86bc9090bed90757a34c&quot;&gt;@玉伯&lt;/a&gt;&lt;a data-hash=&quot;64458d15a75902cd0425732b7b757705&quot; href=&quot;//www.zhihu.com/people/64458d15a75902cd0425732b7b757705&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@拔赤&quot; data-tip=&quot;p$b$64458d15a75902cd0425732b7b757705&quot;&gt;@拔赤&lt;/a&gt;&lt;a data-hash=&quot;0d9b98af12015c94cff646a6fc0773b5&quot; href=&quot;//www.zhihu.com/people/0d9b98af12015c94cff646a6fc0773b5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@寸志&quot; data-tip=&quot;p$b$0d9b98af12015c94cff646a6fc0773b5&quot;&gt;@寸志&lt;/a&gt;&lt;a data-hash=&quot;790dccce26904cdcd11b0fad3bac37b7&quot; href=&quot;//www.zhihu.com/people/790dccce26904cdcd11b0fad3bac37b7&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@题叶&quot; data-tip=&quot;p$b$790dccce26904cdcd11b0fad3bac37b7&quot;&gt;@题叶&lt;/a&gt;&lt;a data-hash=&quot;85de6407f2219137df29b4249b91cfd5&quot; href=&quot;//www.zhihu.com/people/85de6407f2219137df29b4249b91cfd5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@郭达峰&quot; data-tip=&quot;p$b$85de6407f2219137df29b4249b91cfd5&quot;&gt;@郭达峰&lt;/a&gt; 等等等等，很多思想和新东西只有从他们身上才能学到。我还推荐你多参加技术交流会，多认识一些可以一起学习的小伙伴，你们可以互相交流并且一起成长
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;你需要具备很强的自学能力、对技术有热情并且不断跟进&lt;/b&gt;。因为 JavaScript/前端的社区非常非常活跃，有太多的新东西需要你自己来发现与学习：比如 Universal JavaScript、Isomorphic JavaScript、前端测试、HTML5 页游、WebRTC、WebSocket、CSS 4、SVG、HTTP/2、ES 7、React Native、Babel、TypeScript、Electron 等等等等…
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;虽然一下扯得有点多，但这些确实就是你未来将会遇到的。你并不需要全部掌握它们，但是却多多益善；你也可以专精在某几个方面，这已经足以让你成为非常专业的前端工程师。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;所以，如果你自认为涵盖了上述要求的 40%，欢迎简历发 huangxuan@wepiao.com ，实习/全职皆可～&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;咦，这个结尾怪怪的……

&lt;/div&gt;

</description>
        <pubDate>Wed, 28 Oct 2015 20:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/10/28/how-designer-learn-fe/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/10/28/how-designer-learn-fe/</guid>
        
        <category>知乎</category>
        
        <category>前端开发</category>
        
        <category>UX Design</category>
        
        
      </item>
    
      <item>
        <title>ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」</title>
        <description>&lt;p&gt;JavaScript 有着很奇怪的命名史。&lt;/p&gt;

&lt;p&gt;1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript &lt;em&gt;（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-js-version/javascript-java.jpg&quot; alt=&quot;java-javascript&quot; /&gt;&lt;br /&gt;
&lt;small class=&quot;img-hint&quot;&gt;歪果仁的笑话怎么一点都不好笑&lt;/small&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript#History&quot;&gt;wikipedia 的 JavaScript 词条&lt;/a&gt; 更详细的叙述了这段历史&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1996 年，网景将 JavaScript 提交给 &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;ECMA International（欧洲计算机制造商协会）&lt;/a&gt; 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;术语（译者注）：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;标准（Standard）&lt;/em&gt;： 用于定义与其他事物区别的一套规则&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;实现（Implementation）&lt;/em&gt;： 某个标准的具体实施/真实实践&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29&quot;&gt;ECMAScript 第四版草案&lt;/a&gt;由于太过激进而被抛弃，Adobe 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/ActionScript&quot;&gt;ActionScript 3.0&lt;/a&gt; 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）&lt;/p&gt;

&lt;p&gt;目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;decorators（装饰者）&lt;/a&gt;，&lt;a href=&quot;https://github.com/lukehoban/ecmascript-asyncawait&quot;&gt;async-await（async-await 异步编程模型）&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/jeffmo/es-class-properties&quot;&gt;static class properties（静态类属性）&lt;/a&gt;。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 &lt;a href=&quot;https://babeljs.io/docs/usage/experimental/&quot;&gt;Babel 的官网&lt;/a&gt; 上查看各个提案目前都在哪个阶段了。&lt;/p&gt;

&lt;p&gt;所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 5 (ES5)&lt;/strong&gt;：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)&lt;/strong&gt;：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;这张兼容性表&lt;/a&gt;来查看不同浏览器和工具的实现情况。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 2016&lt;/strong&gt;：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript Proposals&lt;/strong&gt;：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;一些资源&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;TC39 的 &lt;a href=&quot;https://github.com/tc39/ecma262&quot;&gt;Github 仓库&lt;/a&gt;上可以看到所有目前公开的提案&lt;/li&gt;
  &lt;li&gt;如果你还不熟悉 ES6，Babel 有一个&lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;很不错的特性概览&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 &lt;a href=&quot;http://exploringjs.com/&quot;&gt;Exploring ES6&lt;/a&gt;和 Nicholas Zakas 的 &lt;a href=&quot;https://leanpub.com/understandinges6&quot;&gt;Understanding ECMAScript 6&lt;/a&gt;。Axel 的博客 &lt;a href=&quot;http://www.2ality.com/&quot;&gt;2ality&lt;/a&gt; 也是很不错的 ES6 资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; width=&quot;320&quot; src=&quot;/img/in-post/post-js-version/keep-calm-and-learn-javascript.png&quot; /&gt;&lt;br /&gt;
&lt;small class=&quot;img-hint&quot;&gt;来学 JavaScript 吧！&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;著作权声明&lt;/h4&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/&quot;&gt;ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?&lt;/a&gt;   &lt;br /&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/09/22/js-version/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/09/22/js-version/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>翻译</category>
        
        
      </item>
    
  </channel>
</rss>
