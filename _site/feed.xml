<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clover Blog</title>
    <description>克洛弗，Web &amp; Mobile Lover，Front-End Engineer，UX Designer，PHP&amp;JAVA Engineer | 这里是 @Clover克洛弗 的个人博客，与你一起发现更大的世界。</description>
    <link>http://clover.htmhub.com/</link>
    <atom:link href="http://clover.htmhub.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 29 Aug 2016 16:08:21 +0800</pubDate>
    <lastBuildDate>Mon, 29 Aug 2016 16:08:21 +0800</lastBuildDate>
    <generator>Jekyll v3.0.3</generator>
    
      <item>
        <title>PHP源码加密模块 php-beast</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;https://github.com/liexusong/php-beast&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
  _____  _    _ _____    ____  ______           _____ _______
 |  __ \| |  | |  __ \  |  _ \|  ____|   /\    / ____|__   __|
 | |__) | |__| | |__) | | |_)/| |__     /  \  | (___    | |
 |  ___/|  __  |  ___/  |  _ ||  __|   / /\ \  \___ \   | |
 | |    | |  | | |      | |_)\| |____ / ____ \ ____) |  | |
 |_|    |_|  |_|_|      |____/|______/_/    \_\_____/   |_|
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;
此模块可以用于商业用途, 版权归原作者.&lt;br/&gt;
QQ交流群：239243332
&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;php-beast可以自定义加密模块，加密模块编写教程: &lt;a href=&quot;https://github.com/liexusong/php-beast/wiki/%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B&quot;&gt;点击&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;

&lt;h3&gt;编译安装如下:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
$ wget https://github.com/liexusong/php-beast/archive/master.zip
$ unzip master.zip
$ cd php-beast-master
$ phpize
$ ./configure --with-php-config=/usr/local/php/bin/php-config
$ sudo make &amp;&amp; make install

编译好之后修改php.ini配置文件, 加入配置项: extension=beast.so, 重启php-fpm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;温馨提示: 可以设置较大的缓存提高效率&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;使用php-beast的性能：&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
&lt;img src=&quot;http://git.oschina.net/liexusong/php-beast/raw/master/images/beast1.png?dir=0&amp;filepath=images/beast1.png&amp;oid=645b87003dada2eac4f1a9fcfd353aa0423f5711&amp;sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;不使用php-beast的性能：&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
&lt;img src=&quot;http://git.oschina.net/liexusong/php-beast/raw/master/images/beast2.png?dir=0&amp;filepath=images/beast2.png&amp;oid=3f07cff6dca34b22d8933ab0ea1740a0e4f37e34&amp;sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7&quot; /&gt;&lt;/p&gt;

配置项:
&lt;pre&gt;&lt;code&gt;
 beast.cache_size = size
 beast.log_file = &quot;path_to_log&quot;
 beast.enable = On
 beast.encrypt_handler = &quot;des-algo&quot;
&lt;/code&gt;&lt;/pre&gt;

支持的模块有：
&lt;pre&gt;
 1. AES
 2. DES
 3. Base64
&lt;/pre&gt;

&lt;p&gt;通过测试环境:
&lt;pre&gt;&lt;code&gt;
 Nginx + Fastcgi + (PHP-5.2.x ~ PHP-5.6.x)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;注意&lt;/h3&gt;

&lt;p&gt;如果出现502错误，一般是由于GCC版本太低导致，请先升级GCC再安装本模块。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;怎么加密项目&lt;/h2&gt;

&lt;p&gt;安装完 &lt;code&gt;php-beast&lt;/code&gt; 后可以使用 &lt;code&gt;tools&lt;/code&gt; 目录下的 &lt;code&gt;encode_files.php&lt;/code&gt; 来加密你的项目。使用 &lt;code&gt;encode_files.php&lt;/code&gt; 之前先修改 &lt;code&gt;tools&lt;/code&gt; 目录下的 &lt;code&gt;configure.ini&lt;/code&gt; 文件，如下：
```ini
; source path
src_path = &amp;quot;&amp;quot;&lt;/p&gt;

&lt;p&gt;; destination path
dst_path = &amp;quot;&amp;quot;&lt;/p&gt;

&lt;p&gt;; expire time
expire = &amp;quot;&amp;quot;
``&lt;code&gt;
&lt;/code&gt;src&lt;em&gt;path&lt;code&gt;是要加密项目的路径，&lt;/code&gt;dst&lt;/em&gt;path&lt;code&gt;是保存加密后项目的路径，&lt;/code&gt;expire&lt;code&gt;是设置项目可使用的时间 (&lt;/code&gt;expire&lt;code&gt;的格式是：&lt;/code&gt;YYYY-mm-dd HH:ii:ss&lt;code&gt;)。
修改完&lt;/code&gt;configure.ini&lt;code&gt;文件后就可以使用命令&lt;/code&gt;php encode_files.php` 开始加密项目。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;制定自己的php-beast&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;php-beast&lt;/code&gt; 有多个地方可以定制的，以下一一列出：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; 使用 &lt;code&gt;header.c&lt;/code&gt; 文件可以修改 &lt;code&gt;php-beast&lt;/code&gt; 加密后的文件头结构，这样网上的解密软件就不能认识我们的加密文件，就不能进行解密，增加加密的安全性。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;code&gt;php-beast&lt;/code&gt; 提供只能在指定的机器上运行的功能。要使用此功能可以在 &lt;code&gt;networkcards.c&lt;/code&gt; 文件添加能够运行机器的网卡号，例如：
&lt;code&gt;c
char *allow_networkcards[] = {
    &amp;quot;fa:16:3e:08:88:01&amp;quot;,
    NULL,
};
&lt;/code&gt;
这样设置之后，&lt;code&gt;php-beast&lt;/code&gt; 扩展就只能在 &lt;code&gt;fa:16:3e:08:88:01&lt;/code&gt; 这台机器上运行。另外要注意的是，由于有些机器网卡名可能不一样，所以如果你的网卡名不是 &lt;code&gt;eth0&lt;/code&gt; 的话，可以在 &lt;code&gt;php.ini&lt;/code&gt; 中添加配置项： &lt;code&gt;beast.networkcard = &amp;quot;xxx&amp;quot;&lt;/code&gt; 其中 &lt;code&gt;xxx&lt;/code&gt; 就是你的网卡名，也可以配置多张网卡，如：&lt;code&gt;beast.networkcard = &amp;quot;eth0,eth1,eth2&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; 使用 &lt;code&gt;php-beast&lt;/code&gt; 时最好不要使用默认的加密key，因为扩展是开源的，如果使用默认加密key的话，很容易被人发现。所以最好编译的时候修改加密的key，&lt;code&gt;aes模块&lt;/code&gt; 可以在 &lt;code&gt;aes_algo_handler.c&lt;/code&gt; 文件修改，而 &lt;code&gt;des模块&lt;/code&gt; 可以在 &lt;code&gt;des_algo_handler.c&lt;/code&gt; 文件修改。&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;使用过程&lt;/h3&gt;

&lt;hr&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装好php-beast喝php扩展&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写 php-beast-master/tools/configure.ini&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;  ; source path
  src_path = &quot;/home/wwwroot/demo9.htmhub.com.bak&quot;

  ; destination path
  dst_path = &quot;/home/wwwroot/demo9.htmhub.com&quot;

  ; expire time
  expire = &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;执行编译过程 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;php  php-beast-master/tools/encode_files.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时会将配置好的代码加密，解密过程是通过 beast.so 在线解密的。PHP文件可以正常访问。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/08/16/php-codes-encode/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/08/16/php-codes-encode/</guid>
        
        <category>Clover</category>
        
        <category>Linux</category>
        
        <category>PHP</category>
        
        
      </item>
    
      <item>
        <title>Linux文件加密之ccrypt</title>
        <description>&lt;h1&gt;ccrypt&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;ccrypt是为了取代UNIX crypt而设计的，这个实用工具可用于文件和数据流加密及解密。它使用Rijndael密码&lt;/code&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo apt-get install ccrypt
# yum install ccrypt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;加密文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ccencrypt filename
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入两次密码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解密文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ccdecrypt filename
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提供加密时输入的同一个密码才能解密&lt;/p&gt;

&lt;p&gt;它使用ccencrypt来加密、使用ccdecrypt来解密。一定要注意，加密时，原始文件(tecmint.txt)换成了tecmint.txt.cpt;解密时，加密文件(tecmint.txt.cpt)换成了原始文件(tecmint.txt)。你可以使用ls命令来予以核查&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/08/16/linux-file-encode/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/08/16/linux-file-encode/</guid>
        
        <category>Clover</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Redis Study 之二 入门指南</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考书籍：Redis入门指南（第二版）李子骅 编著 人民邮电出版社&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;一、准备&lt;/h1&gt;

&lt;h2&gt;1）启动Redis&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接启动
    &lt;code&gt;bash
    # redis-server
&lt;/code&gt;
Redis 服务器 默认 会 使用 6379 端口 ,通过-- port 参数 可以 自定义 端口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-server --port 6380      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过初始化脚本启动（略过）      &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定配置文件启动&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;2）停止Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Redis有可能正在将内存中的数据同步到硬盘中，强行终止Redis进程可能会导致数据 丢失。 正确停止Redis的方式应该是向Redis发送SHUTDOWN 命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-cli shutdown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Redis收到shutdown命令后，会先断开所有的客户端连接，然后根据配置执行持久化，最后完成退出&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis会妥善处理&lt;code&gt;sigterm&lt;/code&gt;信号   ,所以使用kill Redis进程的PID也可以正常结束Redis,效果与发送shutdown命令一样。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3）Redis命令行客户端&lt;/h2&gt;

&lt;p&gt;redis-cli是Redis自带的基于命令行的Redis客户端&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;发送命令&lt;/p&gt;

&lt;p&gt;redis-cli向Redis发送命令有两种方式。&lt;/p&gt;

&lt;p&gt;一是将命令作为redis-cli的参数执行 ,&lt;code&gt;-h&lt;/code&gt;自定义地址 &lt;code&gt;-p&lt;/code&gt;自定义端口号&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-cli -h 127.0.0.1 -p 6379
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redis提供&lt;code&gt;PING&lt;/code&gt;命令来测试客户端语Redis连接是否正常&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-cli PING
PONG    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二是不附带参数运行redis-cli，这样会进入交互模式可以自由输入命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# redis-cli
redis 127.0.0.1:6379&amp;gt; PING
PONG
redis 127.0.0.1:6379&amp;gt; ECHO hi
&quot;hi&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令返回值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;状态回复&lt;/p&gt;

&lt;p&gt;状态是最简单的一种回复如SET 会回复OK &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* 错误回复

    当出现命令不存在或命令格式有错误时Redis会返回错误回复（error replay）.错误回复以（error）开头，并在后面跟上错误信息。如执行一个不存在的命令：

        redis&amp;gt;ERRORCOMMEND
        (error)ERR unknown command &#39;ERRORCOMMEND&#39;

    在 2. 6 版本 时， 错误 信息 均 是以“ ERR” 开头， 而在 2. 8 版 以后， 部分 错误 信息 会 以 具体 的 错误 类型 开头， 如： 

        redis&amp;gt; LPUSH key 1 (integer) 1
        redis&amp;gt; GET key 
        (error) WRONGTYPE Operation against a key holding the wrong kind of value 

    这里 错误 信息 开头 的“ WRONGTYPE” 就 表示 类型 错误， 这个 改进 使得 在调 试 

* 整数回复  
    Redis没有整数类型，但提供了用于整数操作的命令。整数回复以（integer）开头，并在后面跟上整数数据：

        redis&amp;gt; INCR foo
        (integer) 1
* 字符串回复
    字符串回复是最常见的一种回复类型，当请求一个字符串类型键的值或一个其他键中的某个元素时就会得到一个字符串。字符串回复以双引号包裹：

        redis&amp;gt; GET foo
        &quot;1&quot;     
* 多行字符串回复
    多行字符串回复中的每行字符串都以一个序号开头

        redis &amp;gt; KEYS *
        1) &quot;bar&quot;
        2) &quot;foo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4）配置&lt;/h2&gt;

&lt;p&gt;通过&lt;code&gt;redis-server&lt;/code&gt;的启动参数port设置了Redis的端口号，除此之外还有其他的配置选项，如开启持久化，日志级别等。由于配置选项多，redis支持通过配置文件来配置这些选        &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#redis-server /path/to/redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#redis-server /path/to/redis.conf --loglevel warning
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis提供了一个配置文件的模板redis.conf位于源代码目录&lt;/p&gt;

&lt;p&gt;还可以在运行时通过&lt;code&gt;CONFIG SET&lt;/code&gt; 命令在不重启Redis的情况下动态修改部分Redis配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt;CONFIG SET loglevel warning
OK      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并不是所有的配置都可以使用CONFIG SET 命令修改      &lt;/p&gt;

&lt;h2&gt;4）多数据库&lt;/h2&gt;

&lt;p&gt;每个 数据库 对外 都是 以 一个 从 0 开始 的 递增 数字 命名， Redis 默认 支持 16 个 数据库， 可以 通过 配置 参数 databases 来 修改 这一 数字。 客户 端 与 Redis 建立 连接 后 会 自动 选择 0 号 数据库， 不过 可以 随时 使用SELECT命令更换数据库，如要选择1号数据库：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt;SELECT 1
    OK
    redis[1] GET foo
    (nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redis不支持自定义数据库的名字       &lt;/p&gt;

&lt;hr&gt;

&lt;h1&gt;二、入门&lt;/h1&gt;

&lt;h2&gt;1）字符串类型&lt;/h2&gt;

&lt;p&gt;一个字符串类型键允许存储的数据的最大容量是512M。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;赋值与取值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SET key value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GET key&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;set和get是redis中最简单的两个命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;当键不存在时返回空结果
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;递增数字&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;INCR key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当存储的字符串是整数形式时，Redis提供了一个实用的命令INCR，其作用是让当键值递增，并返回递增后的值&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt;INCR num
    (integer) 1
    redis&amp;gt;INCR num
    (integer) 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当要操作的键不存在时默认键值为0，所以第一次递增后的结果是1.&lt;/p&gt;

&lt;p&gt;当键值不是整数是会提示错误&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt; SET foo lorem
    OK 
    redis&amp;gt; INCR foo
    (error) ERR value is not an integer or out of range
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令拾遗&lt;/p&gt;

&lt;p&gt;1).增加指定的整数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;INCRBY key increment
INCRBY通过 increment 参数指定一次增加的数值
redis&amp;gt; INCRBY bar 2
(integer)2
redis&amp;gt; INCRBY bar 3
(integer)5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2).减少指定的整数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;DECR key
DECRBY key increment
redis&amp;gt; DECR bar 
(integer)4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3).增加指定浮点数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;INCRBYFLOAT key increment&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;递增一个双精度浮点数  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt;INCRBYFLOAT bar 2.7
&quot;6.7&quot;
redis&amp;gt;INCRBYFLOAT bar 5E+4
&quot;50006.69999999999999929&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4).向尾部追加值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;APPEND key value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;APPEND 作用是向键值的末尾追加value.如果键不存在则将该值设置为value,即相当于SET key value.返回值是追加后字符串的总长度&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt;SET key hello
OK
redis&amp;gt;APPEND key &quot; world!&quot;
（integer）12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时key的值是&amp;quot;hello world!&amp;quot;。APPEND命令的第二个参数加了双引号，原因是该参数包含空格，在redis-cli中输入需要双引号以示区分&lt;/p&gt;

&lt;p&gt;5).获取字符串长度&lt;/p&gt;

&lt;p&gt;&lt;code&gt;STRLEN key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;STRLEN 命令返回键值的长度，如果键不存在返回0 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt;STRLEN key
(interger)12
redis&amp;gt;SET key 你好
OK
redis&amp;gt;STRLEN key
(interger)6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面提到字符串类型可以存储二进制数据，所以它可以存储任意编码的字符串。例子中接收到的是使用UTF-8编码的中文，由于你好的UTF-8编码的长度都是3，所以返回6。&lt;/p&gt;

&lt;p&gt;6).同时获得/设置多个键值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MGET key[key ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MMSET key value [key value ...]&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; MSET key1 v1 key2 v2 key3 v3
redis&amp;gt; GET key2
&quot;v2&quot;
redis &amp;gt; MGET key1 key3
1)&quot;v1&quot;
2)&quot;v3&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7). 位操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GETBIT key offset&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SETBIT key offset value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BITCOUNT key [start] [key ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BITOP operation destkey key [key ...]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;h2&gt;2）散列类型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;赋值与取值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HSET key field value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HGET key field&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HMSET key field value [field value ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HMGET key field [field ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HGETALL key&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; HSET car price 500
(interger)1
redis&amp;gt; HSET car name BMW
(interger)1
redis&amp;gt;HEGT car name
&quot;BMW&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HSET命令方便之处在于不区分插入和更新操作，这意味着修改数据时不用事先判断字段是否存在来决定要执行的是插入操作还是更新操作。当执行的是插入操作时HSET会返回1，当执行的是更新操作是 HSET返回0。&lt;code&gt;当键本身不存在是，HSET命令还会自动创建&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;REDIS中每个键都属于一个明确的数据类型，如通过HSET命令建立的键都是散列类型，通过SET命令建立的键是字符串类型。使用一种数据类型的命令操作另外一种数据类型的键会提示错误“ERR Operation against a key holding the wrong kind of value”&lt;/code&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; HMGET car price name
1)&quot;500&quot;
2)&quot;BMW&quot;

redis&amp;gt; HGETALL car  
1)&quot;price&quot;
2)&quot;500&quot;
3)&quot;name&quot;
4)&quot;BMW&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判断字段是否存在&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;HEXISTS key field&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HEXISTS命令用来判断一个字段是否存在。如果存在则返回1，否则返回0（&lt;code&gt;如果键不存在也会返回0&lt;/code&gt;）。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt;HEXISTS car model
    (integer)0
    redis&amp;gt;HSET car model C200
    (integer)1
    redis&amp;gt;HEXISTS car model
    (integer)1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当字段不存在时赋值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HSETNX key field value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HSETNX 命令与HSET命令相似，区别在于如果字段已经存在，HSETNX命令不执行任何操作&lt;/p&gt;

&lt;p&gt;HSETNX 命令是原子操作，不用担心竞态条件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加数字&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HINCRBY key field increment&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; HINCRBY person score 60
(integer)60
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前person键不存在，HINCARBY命令会自动建立该键并默认score字段在执行前的值为0.命令的返回值是增值后的字段值&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HDELkey field [field]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HDEL 命令可以删除一个或者多个字段，返回值是被删除的字段个数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; HDEL car price
(integer)1
redis&amp;gt; HDEL car price       
(integer)0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储文章数据&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$postID=INCR posts:count
#判断用户输入的slug是否可用，如果可用则记录
$isSlugAvailable=HSETNX slug.to.id,$slug ,$postIID
if $isSlugAvailable is 0
#slug已经用过了需要提示更换slug
exit
HMSET post:$postID,title,$title,content,$content,slug,$slug,...
这段代码使用了HSETNX命令原子的实现了HEXISTS和HSET两个命令以避免竞态条件。当用户访问文章时，我们从网址中得到文章的缩略名，并查询slug.to.id键来获取文章ID：
$postID=HGET slug.to.id,$slug
if not $postID
print 文章不存在
exit
$post=HGETALL post:$postID
print文章标题:$post.title
需要注意的是如果要修改文章的缩略名一定不能忘了修改slug.to.id键对应的字段。
#判断新的slug是否可用，如果可用则记录
$isSlugAvailable=HSETNX slug.to.id ,$newSlug,42
if $isSlugAvailable is 0
exit
#获得旧的缩略名 
$oldSlug=HGET post:42,slug
#设置新的缩略名
HSET post:42,slug,$newSlug
#删除旧的缩略名
HDEL slug.to.id ,$oldslug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令拾遗&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1）只获取字段名或字段值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HEKYS key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HVALS key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有时仅仅需要获取键中所有字段的名字而不需要字段值，那么可以使用HEKYS命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt; HKEYS car 
    1)&quot;name&quot;
    2)&quot;model&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HVALS 命令与HEKYS命令相对应，HVALS命令用来获得键中所有字段值&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    redis&amp;gt; HVALS car
    1)&quot;BMW&quot;
    2)&quot;C200&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2)获取字段数量&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HLEN key&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; HLEN car
(integer) 2                 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3）列表类型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;向列表两端增加元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LPUSH key value [value ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RPUSH key value [value ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LPUSH命令用来向列表左边增加元素，返回值表示增加元素后列表的长度&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LPUSH numbers 1
(integer) 1

[1]

redis&amp;gt; LPUSH numbers 2 3 
(integer) 3

[ 3 2 1 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LPUSH 会向列表左边先加入 2 再加入 3&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; RPUSH numbers 0 -1
(integer) 5

[3 2 1 0 -1]    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从列表两端弹出元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LPOP key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RPOP key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有进有出，LPOP可以从列表左边弹出一个元素。LPOP命令执行两步操作：第一步是将列表左边的元素从列表移除，第二步是返回被移除的元素值&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LPOP numbers
&quot;3&quot;

redis&amp;gt; RPOP numbers
&quot;-1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;结合上面提到的4个命令可以使用列表类型来模拟栈和队列的操作&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;栈：LPUSH和LPOP   RPUSH和RPOP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;队列：LPUSH和RPOP  RPUSH和LPOP&lt;/code&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取列表中元素的个数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LLEN key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当键不存在时LLEN会返回0&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt;LLEN numbers
(integer) 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LLEN功能类似SQL语句 SELECT COUNT(*) FROM table_name 但是LLEN的时间复杂度为O(1) ,使用时Redis会直接读取现成的值，而不需要统计&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取列表片段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LRANGE key start stop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回索引从start到stop之间的所有元素（包含两端的元素），起始索引为0&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LRANGE numbers 0 2
1)&quot;2&quot;
2)&quot;1&quot;
3)&quot;0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LRANGE在取得列表片段的同时不会像LPOP一样删除该片段&lt;/p&gt;

&lt;p&gt;LRANGE也支持负索引 表示从右边开始计算序数
-1 表示最右边第一个元素 -2便是最右边第二个元素&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LRANGE nubmers -2 -1
1)&quot;1&quot;
2)&quot;0&quot;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，LRANGE numbers 0 -1 可以获取列表中所有元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;特殊情况&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* 如果start的索引位置比stop的索引位置靠后，返回空列表
* 如果stop大于实际的索引范围，则返回到列表最右边的元素

    redis&amp;gt; LRANGE nubmers 1 999
    1)&quot;1&quot;
    2)&quot;0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除列表中指定的值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LREM key count value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LREM 会删除列表前count个值为value的元素，返回值是实际删除的元素个数，根据count值的不同，LREM执行方式有差异&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* 当count&amp;gt;0时，LREM会从列表左边开始删除前count个值为value的元素
* 当count&amp;lt;0时，LREM会从列表右边开始删除|count|个值为value的值
* 当count=0时，LREM会删除所有值为value的元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令拾遗&lt;/p&gt;

&lt;p&gt;1.获得/设置指定索引的元素值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LINDEX key index&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LSET key index value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LINDEX 返回指定索引的元素&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LINDEX numbers 0
&quot;2&quot;
redis&amp;gt; LINDEX numbers -1
&quot;0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LSET是另一个通过索引操作列表的命令,它会将索引为index的元素赋值为value.例如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LSET nubmers 1 7 
OK 
redis&amp;gt; LINDEX nubmers 1
&quot;7&quot;         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.只保留列表指定片段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LTRIM key start end&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LTRIM命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和LRANGE命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LRANGE numbers 0 -1
1)&quot;1&quot;
2)&quot;2&quot;
3)&quot;7&quot;
4)&quot;3&quot;
&quot;0&quot;
redis&amp;gt; LTRIM numbers 1 2
OK
redis&amp;gt; LRANGE numbers 0 1
1)&quot;2&quot;
2)&quot;7&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LTRIM命令常和LPUSH命令一起来使用用来限制列表中元素的数量，比如日志只保留100条&lt;/p&gt;

&lt;p&gt;LPUSHlogs $newlog&lt;/p&gt;

&lt;p&gt;LTROM logs 0 99&lt;/p&gt;

&lt;p&gt;3.向列表中插入元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LINSERT key BEFORE | AFTER pivot value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;LINSERT 命令首先会在列表从左到右查找值为pivot的元素，然后根据BEFORE还是AFTER来决定将value插入到该元素的前面还是后面&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; LRANGE numbers 0 -1
1)&quot;2&quot;
2)&quot;7&quot;
3)&quot;0&quot;
redis&amp;gt; LINSERT numbers AFTER 7 3
(integer) 4
redis&amp;gt; LRANGE numbers 0 -1
1)&quot;2&quot;
2)&quot;7&quot;
3)&quot;3&quot;
4)&quot;0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.将元素从一个列表转到另一个列表&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RPOPLPUSH source destination&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RPOPLPUSH功能：先执行RPOP命令再执行LPUSH命令。RPOPLPUSH命令会先从source列表类型键的右边弹出一个元素，然后将其加入到destination列表类型键的左边，并返回这个元素的值，整个过程是原子的。&lt;/p&gt;

&lt;p&gt;当把列表类型作为队列使用时，RPOPLPUSH命令可以很直观的在多个队列中传递数据。当source和destination相同时，RPOPLPUSH命令会不断地将对尾的元素移到队首，借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用RPOPLPUSH命令循环取出一个网址来测试可用性。RPOPLPUSH的好处在于在程序执行过程中仍然可以不断的向网址列表中加入新网址，整个系统易扩展，允许多个客户端同时处理队列&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;4）集合类型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;在集合中的每个元素都是不同的，且没有顺序。一个集合类型（set）键可以存储之多232-1个字符串&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加/删除元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SADD key member [member ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SREM key member [member ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SADD命令用来向集合中增加一个或多个元素，如果键不存在则自动创建。因为一个集合中不能有相同的元素，相同键的元素会被忽略执行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; SADD letters a 
(integer) 1
redis&amp;gt; SADD letters a b c
(integer) 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二条SADD命令返回值为2是因为元素a已经存在，所以实际只加入了两个元素&lt;/p&gt;

&lt;p&gt;SREM命令用来从集合正删除一个或者多个元素，并返回删除成功的个数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; SREM letters c d 
(integer) 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获得集合中的所有元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SMEMBERS key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SMEMBERS命令会返回集合中的所有元素&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; SMEMBERS letters
1)&quot;b&quot;
2)&quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判断元素是否在集合中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SMEMBERS key member&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;判断一个元素是否在集合中是一个时间复杂度为O(1)的操作，无论集合元素多少，都可以很快速的返回结果。当值存在时SMEMBERS命令返回1，不存在返回0&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; SMEMBERS letters a 
(integer) 1
redis&amp;gt; SMEMBERS letters d
(integer) 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集合间运算&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SDIFF key [key ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SINTER key [key ...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SUNION key [key ...]&lt;/code&gt;  &lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;- SDIFF用来对多个集合执行差集运算.

    集合A与集合B的差集表示A-B，代表所有属于A且不属于B的元素构成的集合

    ```
    redis &amp;gt; SADD setA 1 2 3
    (integer) 3
    redis &amp;gt; SADD setB 2 3 4
    (integer) 3
    redis &amp;gt; SDIFF setA set B 
    1）&quot;1&quot;
    redis &amp;gt; SDIFF setB setA 
    1) &quot;4&quot; 
    ```

    SDIFF支持同时传入多个键

    `redis &amp;gt; SDIFF setA setB setC` 

    计算顺序是先计算setA-setB,在计算结果与setC差集。

- SINTER命令用来对多个集合执行交集运算。

    集合A与集合B的交集表示为A∩B，代表所有属于A且属于B的元素构成的集合

    ```
    redis &amp;gt; SADD setA 1 2 3
    (integer) 3
    redis &amp;gt; SADD setB 2 3 4
    (integer) 3
    redis &amp;gt; SINTER setA setB
    1)&quot;2&quot;
    2)&quot;3&quot;
    ```

- SUNION 命令用来对多个集合执行并集运算

    集合A与集合B的并集表示为A∪B，代表所有属于A或者属于B的元素构成的集合

    ```
    redis &amp;gt; SADD setA 1 2 3
    (integer) 3
    redis &amp;gt; SADD setB 2 3 4
    (integer) 3
    redis &amp;gt; SINTER setA setB
    1)&quot;1&quot;
    2)&quot;2&quot;
    3)&quot;3&quot;
    4)&quot;4&quot;
    ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;命令拾遗&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* 获得集合中元素个数

    `SCARD key`

    SCARD命令用来获得集合中的元素个数

    ```
    redis &amp;gt; SMEMBERS letters
    1)&quot;b&quot;
    2)&quot;2&quot;
    redis &amp;gt; SCARD letters
    (integer)2
    ```

* 进行集合运算并将结果存储

    `SDIFFSTORE destination key  [key ...]`

    `SINTERSTORE destination key [key ...]`

    `SUNINONSTORE destination key [key ...]`

    结果存储在 destination的键中

* 随机获得集合中的元素

    `SRANDMEMBER key    [count]`

    SRANDMEMBER 命令用来随机从集合中获取一个元素

    ```
    redis &amp;gt; SRANDMEMBER letters
    &quot;a&quot;
    redis &amp;gt; SRANDMEMBER letters
    &quot;b&quot;
    ```

count来控制一次获取多个元素

    1）当count为正数时，随机获取count个数不重复的数，大于元素总个数，返回全部

    2）当count为负数时，随机获取|count|个元素，这些元素`有可能相同`

* 从集合中弹出一个元素

    `SPOP key `

    由于集合是无序的，所以SPOP会从集合中随机选择一个元素弹出

    ```
    redis &amp;gt;SOPO letters 
    &quot;b&quot; 
    redis &amp;gt; SMEMBERS letters
    1)&quot;a&quot;
    2)&quot;c&quot;
    3)&quot;d&quot;
    ``` 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5）有序集合类型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;在集合的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有序集合类型在某些方面和列表类型有些相似&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* （1）二者都是有序的
* （2）二者都可以获得某一范围的元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是二者有很大的区别，使得他们的应用场景也不相同&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* （1）列表类型通过链表实现，获取靠近两端的元素极快，当元素增多时，访问中间元素的速度会变慢，所以他更加适合实现如“新鲜事”“日志”这样很少访问中间元素的应用
* （2）有序集合类型是使用散列表和跳跃表实现的，即使读取中间部分的 数据也很快（时间复杂度是O(log(N))）
* （3）列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改元素的分数）
* （4）`有序集合比列表类型更消耗内存`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ZADD key score member [score member...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ZADD命令用来向有序集合中添加一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。ZADD返回的是新加入到元素集合中的个数（不包含之前已经存在的元素）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; ZADD scoreboard 89 Tom 67 Peter 100 David
(integer)3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; ZADD scoreboard  76 Peter 
(integer)0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分数不仅可以是整数，还支持双精度浮点数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis&amp;gt; ZADD testboard 17E+307 a
(integer)1
redis&amp;gt; ZADD testboard 1.5 b
(integer)1
redis&amp;gt; ZADD testboard +inf c
(integer)1
redis&amp;gt; ZADD testboard -inf d
(integer)1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中+inf和-inf分别表示正无穷和负无穷&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获得元素的分数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ZSCORE key member&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ZSCORE scoreboard Tom 
&quot;89&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获得排名在某个范围的元素列表   &lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/07/04/redis-study-2/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/07/04/redis-study-2/</guid>
        
        <category>Clover</category>
        
        <category>Redis</category>
        
        <category>DB</category>
        
        
      </item>
    
      <item>
        <title>Gulp-前端自动化构建工具</title>
        <description>&lt;h1&gt;Gulp-Web前端自动化开发工具&lt;/h1&gt;

&lt;hr&gt;

&lt;h3&gt;入门指南&lt;/h3&gt;

&lt;h4&gt;1. 全局安装 gulp&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ npm install --global gulp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2. 作为项目的开发依赖（devDependencies）安装&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ npm install --save-dev gulp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 在项目根目录下创建一个名为 gulpfile.js 的文件&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;var gulp = require(&#39;gulp&#39;);

gulp.task(&#39;default&#39;, function() {
  // 将你的默认的任务代码放在这
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4. 运行 gulp：&lt;/h4&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/06/30/gulp-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/06/30/gulp-study/</guid>
        
        <category>Clover</category>
        
        <category>Web</category>
        
        <category>HTML</category>
        
        <category>Gulp</category>
        
        
      </item>
    
      <item>
        <title>Redis Study</title>
        <description>&lt;h1&gt;Redis的学习&lt;/h1&gt;

&lt;hr&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。&lt;/p&gt;

&lt;p&gt;对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。&lt;/p&gt;

&lt;p&gt;当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。&lt;/p&gt;

&lt;p&gt;本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。&lt;/p&gt;

&lt;h2&gt;安装&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;&lt;code&gt;windows&lt;/code&gt;:&lt;a href=&quot;https://github.com/dmajkic/redis/downloads&quot;&gt;https://github.com/dmajkic/redis/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*nix和MacOSX平台&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz
$ tar xzf redis-3.2.0.tar.gz
$ cd redis-3.2.0
$ make
$ make install
$ cp redis.conf /etc/
$ cd /etc
$ vim redis.conf
修改daemonize yes---目的使进程在后台运行
$ cd /usr/local/bin
$./redis-server /etc/redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查是否启动成功&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ ps -ef | grep redis
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;服务启动后通过 redis-cli链接
进入命令行控制台&lt;/p&gt;

&lt;p&gt;（当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）&lt;/p&gt;

&lt;p&gt;如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。&lt;/p&gt;

&lt;h2&gt;运行和连接Redis&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.&lt;/p&gt;

&lt;p&gt;如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。&lt;/p&gt;

&lt;p&gt;然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。&lt;/p&gt;

&lt;p&gt;可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。&lt;/p&gt;

&lt;p&gt;如果在上面的启动步骤里遇到什么问题，我建议你到&lt;code&gt;Redis的官方支持组&lt;/code&gt;里获取帮助。&lt;/p&gt;

&lt;h2&gt;驱动Redis&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的&lt;a href=&quot;http://redis.io/clients&quot;&gt;客户端推荐页面&lt;/a&gt;下载适合的Redis载体。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;学习-基础知识&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;是什么使Redis显得这么特别？Redis具体能解决什么类型的问题？要实际应用Redis，开发者必须储备什么知识？在我们能回答这么一些问题之前，我们需要明白Redis到底是什么。&lt;/p&gt;

&lt;p&gt;Redis通常被人们认为是一种持久化的存储器关键字-值型存储（in-memory persistent key-value store）。我认为这种对Redis的描述并不太准确。Redis的确是将所有的数据存放于存储器（更多是是按位存储），而且也确实通过将数据写入磁盘来实现持久化，但是Redis的实际意义比单纯的关键字-值型存储要来得深远。纠正脑海里的这种误解观点非常关键，否则你对于Redis之道以及其应用的洞察力就会变得越发狭义。&lt;/p&gt;

&lt;p&gt;事实是，Redis引入了5种不同的数据结构，只有一个是典型的关键字-值型结构。理解Redis的关键就在于搞清楚这5种数据结构，其工作的原理都是如何，有什么关联方法以及你能怎样应用这些数据结构去构建模型。首先，让我们来弄明白这些数据结构的实际意义。&lt;/p&gt;

&lt;p&gt;应用上面提及的数据结构概念到我们熟悉的关系型数据库里，我们可以认为其引入了一个单独的数据结构——表格。表格既复杂又灵活，基于表格的存储和管理，没有多少东西是你不能进行建模的。然而，这种通用性并不是没有缺点。具体来说就是，事情并不是总能达到假设中的简单或者快速。相对于这种普遍适用（one-size-fits-all）的结构体系，我们可以使用更为专门化的结构体系。当然，因此可能有些事情我们会完成不了(至少，达不到很好的程度）。但话说回来，这样做就能确定我们可以获得想象中的简单性和速度吗？&lt;/p&gt;

&lt;p&gt;针对特定类型的问题使用特定的数据结构？我们不就是这样进行编程的吗？你不会使用一个散列表去存储每份数据，也不会使用一个标量变量去存储。对我来说，这正是Redis的做法。如果你需要处理标量、列表、散列或者集合，为什么不直接就用标量、列表、散列和集合去存储他们？为什么不是直接调用&lt;code&gt;exists(key)&lt;/code&gt;去检测一个已存在的值，而是要调用其他比O(1)（常量时间查找，不会因为待处理元素的增长而变慢）慢的操作？&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;数据库（Databases）&lt;/h3&gt;

&lt;hr&gt;

&lt;p&gt;与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。&lt;/p&gt;

&lt;p&gt;在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是&lt;code&gt;0&lt;/code&gt;。如果你想切换到一个不同的数据库，你可以使用&lt;code&gt;select&lt;/code&gt;命令来实现。在命令行界面里键入&lt;code&gt;select 1&lt;/code&gt;，Redis应该会回复一条&lt;code&gt;OK&lt;/code&gt;的信息，然后命令行界面里的提示符会变成类似&lt;code&gt;redis 127.0.0.1:6379[1]&amp;gt;&lt;/code&gt;这样。如果你想切换回默认数据库，只要在命令行界面键入&lt;code&gt;select 0&lt;/code&gt;即可。&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;命令、关键字和值（Commands, Keys and Values）&lt;/h3&gt;

&lt;hr&gt;

&lt;p&gt;Redis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值。在转入其它关于Redis的有用信息之前，我们必须理解关键字和值的概念。&lt;/p&gt;

&lt;p&gt;关键字（Keys）是用来标识数据块。我们将会很常跟关键字打交道，不过在现在，明白关键字就是类似于&lt;code&gt;users:leto&lt;/code&gt;这样的表述就足够了。一般都能很好地理解到，这样关键字包含的信息是一个名为&lt;code&gt;leto&lt;/code&gt;的用户。这个关键字里的冒号没有任何特殊含义，对于Redis而言，使用分隔符来组织关键字是很常见的方法。&lt;/p&gt;

&lt;p&gt;值（Values）是关联于关键字的实际值，可以是任何东西。有时候你会存储字符串，有时候是整数，还有时候你会存储序列化对象（使用JSON、XML或其他格式）。在大多数情况下，Redis会把值看做是一个字节序列，而不会关注它们实质上是什么。要注意，不同的Redis载体处理序列化会有所不同（一些会让你自己决定）。因此，在这本书里，我们将仅讨论字符串、整数和JSON。
现在让我们活动一下手指吧。在命令行界面键入下面的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;set users:leto &quot;{name: leto, planet: dune, likes: [spice]}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是Redis命令的基本构成。首先我们要有一个确定的命令，在上面的语句里就是set。然后就是相应的参数，set命令接受两个参数，包括要设置的关键字，以及相应要设置的值。很多的情况是，命令接受一个关键字（当这种情况出现，其经常是第一个参数）。你能想到如何去获取这个值吗？我想你会说（当然一时拿不准也没什么）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;get users:leto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键字和值的是Redis的基本概念，而&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;命令是对此最简单的使用。你可以创建更多的用户，去尝试不同类型的关键字以及不同的值，看看一些不同的组合。&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;查询（Querying）&lt;/h3&gt;

&lt;hr&gt;

&lt;p&gt;随着学习的持续深入，两件事情将变得清晰起来。对于Redis而言，关键字就是一切，而值是没有任何意义。更通俗来看就是，Redis不允许你通过值来进行查询。回到上面的例子，我们就不能查询生活在&lt;code&gt;dune&lt;/code&gt;行星上的用户。&lt;/p&gt;

&lt;p&gt;对许多人来说，这会引起一些担忧。在我们生活的世界里，数据查询是如此的灵活和强大，而Redis的方式看起来是这么的原始和不高效。不要让这些扰乱你太久。要记住，Redis不是一种普遍使用（one-size-fits-all）的解决方案，确实存在这么一些事情是不应该由Redis来解决的（因为其查询的限制）。事实上，在考虑了这些情况后，你会找到新的方法去构建你的数据。&lt;/p&gt;

&lt;p&gt;很快，我们就能看到更多实际的用例。很重要的一点是，我们要明白关于Redis的这些基本事实。这能帮助我们弄清楚为什么值可以是任何东西，因为Redis从来不需要去读取或理解它们。而且，这也可以帮助我们理清思路，然后去思考如何在这个新世界里建立模型。&lt;/p&gt;

&lt;h3&gt;存储器和持久化（Memory and Persistence）&lt;/h3&gt;

&lt;p&gt;我们之前提及过，Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。&lt;/p&gt;

&lt;p&gt;除了创建磁盘快照外，Redis可以在附加模式下运行。任何时候，如果有一个关键字变更，一个单一附加（append-only）的文件会在磁盘里进行更新。在一些情况里，虽然硬件或软件可能发生错误，但用那60秒有效数据存储去换取更好性能是可以接受的。而在另一些情况里，这种损失就难以让人接受，Redis为你提供了选择。在第5章里，我们将会看到第三种选择，其将持久化任务减荷到一个从属数据库里。&lt;/p&gt;

&lt;p&gt;至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件。&lt;/p&gt;

&lt;p&gt;我很清楚有一些开发者对即使是一点点的数据空间都是那么的敏感。一本《威廉·莎士比亚全集》需要近5.5MB的存储空间。对于缩放的需求，其它的解决方案趋向于IO-bound或者CPU-bound。这些限制（RAM或者IO）将会需要你去理解更多机器实际依赖的数据类型，以及应该如何去进行存储和查询。除非你是存储大容量的多媒体文件到Redis中，否则存储器内存储应该不会是一个问题。如果这对于一个程序是个问题，你就很可能不会用IO-bound的解决方案。&lt;/p&gt;

&lt;p&gt;Redis有虚拟存储器的支持。然而，这个功能已经被认为是失败的了（通过Redis的开发者），而且它的使用已经被废弃了。&lt;/p&gt;

&lt;p&gt;（从另一个角度来看，一本5.5MB的《威廉·莎士比亚全集》可以通过压缩减小到近2MB。当然，Redis不会自动对值进行压缩，但是因为其将所有值都看作是字节，没有什么限制让你不能对数据进行压缩/解压，通过牺牲处理时间来换取存储空间。）&lt;/p&gt;

&lt;h3&gt;整体来看（Putting It Together）&lt;/h3&gt;

&lt;p&gt;我们已经接触了好几个高层次的主题。在继续深入Redis之前，我想做的最后一件事情是将这些主题整合起来。这些主题包括，查询的限制，数据结构以及Redis在存储器内存储数据的方法。&lt;/p&gt;

&lt;p&gt;当你将这3个主题整合起来，你最终会得出一个绝妙的结论：速度。一些人可能会想，当然Redis会很快速，要知道所有的东西都在存储器里。但这仅仅是其中的一部分，让Redis闪耀的真正原因是其不同于其它解决方案的特殊数据结构。&lt;/p&gt;

&lt;p&gt;能有多快速？这依赖于很多东西，包括你正在使用着哪个命令，数据的类型等等。但Redis的性能测试是趋向于数万或数十万次操作&lt;strong&gt;每秒&lt;/strong&gt;。你可以通过运行&lt;code&gt;redis-benchmark&lt;/code&gt;（就在&lt;code&gt;redis-server&lt;/code&gt;和&lt;code&gt;redis-cli&lt;/code&gt;的同一个文件夹里）来进行测试。&lt;/p&gt;

&lt;p&gt;我曾经试过将一组使用传统模型的代码转向使用Redis。在传统模型里，运行一个我写的载入测试，需要超过5分钟的时间来完成。而在Redis里，只需要150毫秒就完成了。你不会总能得到这么好的收获，但希望这能让你对我们所谈的东西有更清晰的理解。&lt;/p&gt;

&lt;p&gt;理解Redis的这个特性很重要，因为这将影响到你如何去与Redis进行交互。拥有SQL背景的程序员通常会致力于让数据库的数据往返次数减至最小。这对于任何系统都是个好建议，包括Redis。然而，考虑到我们是在处理比较简单的数据结构，有时候我们还是需要与Redis服务器频繁交互，以达到我们的目的。刚开始的时候，可能会对这种数据访问模式感到不太自然。实际上，相对于我们通过Redis获得的高性能而言，这仅仅是微不足道的损失。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;虽然我们只接触和摆弄了Redis的冰山一角，但我们讨论的主题已然覆盖了很大范围内的东西。如果觉得有些事情还是不太清楚（例如查询），不用为此而担心，在下一章我们将会继续深入探讨，希望你的问题都能得到解答。&lt;/p&gt;

&lt;p&gt;这一章的要点包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关键字（Keys）是用于标识一段数据的一个字符串&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis展示了（也实现了）5种专门的数据结构&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2&gt;第2章 - 数据结构&lt;/h2&gt;

&lt;p&gt;现在开始将探究Redis的5种数据结构，我们会解释每种数据结构都是什么，包含了什么有效的方法（Method），以及你能用这些数据结构处理哪些类型的特性和数据。&lt;/p&gt;

&lt;p&gt;目前为止，我们所知道的Redis构成仅包括命令、关键字和值，还没有接触到关于数据结构的具体概念。当我们使用&lt;code&gt;set&lt;/code&gt;命令时，Redis是怎么知道我们是在使用哪个数据结构？其解决方法是，每个命令都相对应于一种特定的数据结构。例如，当你使用&lt;code&gt;set&lt;/code&gt;命令，你就是将值存储到一个字符串数据结构里。而当你使用&lt;code&gt;hset&lt;/code&gt;命令，你就是将值存储到一个散列数据结构里。考虑到Redis的关键字集很小，这样的机制具有相当的可管理性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://redis.io/commands&quot;&gt;Redis的网站&lt;/a&gt;里有着非常优秀的参考文档，没有任何理由去重造轮子。但为了搞清楚这些数据结构的作用，我们将会覆盖那些必须知道的重要命令。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有什么事情比高兴的玩和试验有趣的东西来得更重要的了。在任何时候，你都能通过键入&lt;code&gt;flushdb&lt;/code&gt;命令将你数据库里的所有值清除掉，因此，不要再那么害羞了，去尝试做些疯狂的事情吧！&lt;/p&gt;

&lt;h3&gt;字符串（Strings)&lt;/h3&gt;

&lt;p&gt;在Redis里，字符串是最基本的数据结构。当你在思索着关键字-值对时，你就是在思索着字符串数据结构。不要被名字给搞混了，如之前说过的，你的值可以是任何东西。我更喜欢将他们称作“标量”（Scalars），但也许只有我才这样想。&lt;/p&gt;

&lt;p&gt;我们已经看到了一个常见的字符串使用案例，即通过关键字存储对象的实例。有时候，你会频繁地用到这类操作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;set users:leto &quot;{name: leto, planet: dune, likes: [spice]}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了这些外，Redis还有一些常用的操作。例如，&lt;code&gt;strlen &amp;lt;key&amp;gt;&lt;/code&gt;能用来获取一个关键字对应值的长度；&lt;code&gt;getrange &amp;lt;key&amp;gt; &amp;lt;start&amp;gt; &amp;lt;end&amp;gt;&lt;/code&gt;将返回指定范围内的关键字对应值；&lt;code&gt;append &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;会将value附加到已存在的关键字对应值中（如果该关键字并不存在，则会创建一个新的关键字-值对）。不要犹豫，去试试看这些命令吧。下面是我得到的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;&amp;gt; strlen users:leto
(integer) 42

&amp;gt; getrange users:leto 27 40
&quot;likes: [spice]&quot;

&amp;gt; append users:leto &quot; OVER 9000!!&quot;
(integer) 54
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在你可能会想，这很好，但似乎没有什么意义。你不能有效地提取出一段范围内的JSON文件，或者为其附加一些值。你是对的，这里的经验是，一些命令，尤其是关于字符串数据结构的，只有在给定了明确的数据类型后，才会有实际意义。&lt;/p&gt;

&lt;p&gt;之前我们知道了，Redis不会去关注你的值是什么东西。通常情况下，这没有错。然而，一些字符串命令是专门为一些类型或值的结构而设计的。作为一个有些含糊的用例，我们可以看到，对于一些自定义的空间效率很高的（space-efficient）串行化对象，&lt;code&gt;append&lt;/code&gt;和&lt;code&gt;getrange&lt;/code&gt;命令将会很有用。对于一个更为具体的用例，我们可以再看一下&lt;code&gt;incr&lt;/code&gt;、&lt;code&gt;incrby&lt;/code&gt;、&lt;code&gt;decr&lt;/code&gt;和&lt;code&gt;decrby&lt;/code&gt;命令。这些命令会增长或者缩减一个字符串数据结构的值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;&amp;gt; incr stats:page:about
(integer) 1
&amp;gt; incr stats:page:about
(integer) 2

&amp;gt; incrby ratings:video:12333 5
(integer) 5
&amp;gt; incrby ratings:video:12333 3
(integer) 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由此你可以想象到，Redis的字符串数据结构能很好地用于分析用途。你还可以去尝试增长&lt;code&gt;users:leto&lt;/code&gt;（一个不是整数的值），然后看看会发生什么（应该会得到一个错误）。&lt;/p&gt;

&lt;p&gt;更为进阶的用例是&lt;code&gt;setbit&lt;/code&gt;和&lt;code&gt;getbit&lt;/code&gt;命令。“今天我们有多少个独立用户访问”是个在Web应用里常见的问题，有一篇&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/&quot;&gt;精彩的博文&lt;/a&gt;，在里面可以看到Spool是如何使用这两个命令有效地解决此问题。对于1.28亿个用户，一部笔记本电脑在不到50毫秒的时间里就给出了答复，而且只用了16MB的存储空间。&lt;/p&gt;

&lt;p&gt;最重要的事情不是在于你是否明白位图（Bitmaps)的工作原理，或者Spool是如何去使用这些命令，而是应该要清楚Redis的字符串数据结构比你当初所想的要有用许多。然而，最常见的应用案例还是上面我们给出的：存储对象（简单或复杂）和计数。同时，由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。&lt;/p&gt;

&lt;h3&gt;散列（Hashes）&lt;/h3&gt;

&lt;p&gt;我们已经知道把Redis称为一种关键字-值型存储是不太准确的，散列数据结构是一个很好的例证。你会看到，在很多方面里，散列数据结构很像字符串数据结构。两者显著的区别在于，散列数据结构提供了一个额外的间接层：一个域（Field）。因此，散列数据结构中的&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;hset users:goku powerlevel 9000
hget users:goku powerlevel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相关的操作还包括在同一时间设置多个域、同一时间获取多个域、获取所有的域和值、列出所有的域或者删除指定的一个域：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如你所见，散列数据结构比普通的字符串数据结构具有更多的可操作性。我们可以使用一个散列数据结构去获得更精确的描述，是存储一个用户，而不是一个序列化对象。从而得到的好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。&lt;/p&gt;

&lt;p&gt;对于散列数据结构，可以从一个经过明确定义的对象的角度来考虑，例如一个用户，关键之处在于要理解他们是如何工作的。从性能上的原因来看，这是正确的，更具粒度化的控制可能会相当有用。在下一章我们将会看到，如何用散列数据结构去组织你的数据，使查询变得更为实效。在我看来，这是散列真正耀眼的地方。&lt;/p&gt;

&lt;h3&gt;列表（Lists）&lt;/h3&gt;

&lt;p&gt;对于一个给定的关键字，列表数据结构让你可以存储和处理一组值。你可以添加一个值到列表里、获取列表的第一个值或最后一个值以及用给定的索引来处理值。列表数据结构维护了值的顺序，提供了基于索引的高效操作。为了跟踪在网站里注册的最新用户，我们可以维护一个&lt;code&gt;newusers&lt;/code&gt;的列表：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;lpush newusers goku
ltrim newusers 0 50
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（译注：&lt;code&gt;ltrim&lt;/code&gt;命令的具体构成是&lt;code&gt;LTRIM Key start stop&lt;/code&gt;。要理解&lt;code&gt;ltrim&lt;/code&gt;命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。对于指定的列表，根据所提供的两个范围参数start和stop，&lt;code&gt;ltrim&lt;/code&gt;命令会将指定范围外的值都删除掉，只留下范围内的值。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，我们将一个新用户推入到列表的前端，然后对列表进行调整，使得该列表只包含50个最近被推入的用户。这是一种常见的模式。&lt;code&gt;ltrim&lt;/code&gt;是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。&lt;/p&gt;

&lt;p&gt;这是我们第一次看到一个关键字的对应值索引另一个值。如果我们想要获取最近的10个用户的详细资料，我们可以运行下面的组合操作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们之前谈论过关于多次往返数据的模式，上面的两行Ruby代码为我们进行了很好的演示。&lt;/p&gt;

&lt;p&gt;当然，对于存储和索引关键字的功能，并不是只有列表数据结构这种方式。值可以是任意的东西，你可以使用列表数据结构去存储日志，也可以用来跟踪用户浏览网站时的路径。如果你过往曾构建过游戏，你可能会使用列表数据结构去跟踪用户的排队活动。&lt;/p&gt;

&lt;h3&gt;集合（Sets）&lt;/h3&gt;

&lt;p&gt;集合数据结构常常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如并集。集合数据结构没有对值进行排序，但是其提供了高效的基于值的操作。使用集合数据结构的典型用例是朋友名单的实现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sismember friends:leto jessica
sismember friends:leto vladimir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且，我们可以查看两个或更多的人是不是有共同的朋友：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sinter friends:leto friends:duncan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;甚至可以在一个新的关键字里存储结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sinterstore friends:leto_duncan friends:leto friends:duncan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。&lt;/p&gt;

&lt;h3&gt;分类集合（Sorted Sets）&lt;/h3&gt;

&lt;p&gt;最后也是最强大的数据结构是分类集合数据结构。如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。如果我们想要一个秩分类的朋友名单，可以这样做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于&lt;code&gt;duncan&lt;/code&gt;的朋友，要怎样计算出标记（score）为90或更高的人数？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;zcount friends:duncan 90 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何获取&lt;code&gt;chani&lt;/code&gt;在名单里的秩（rank）？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;zrevrank friends:duncan chani
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（译注：&lt;code&gt;zrank&lt;/code&gt;命令的具体构成是&lt;code&gt;ZRANK Key menber&lt;/code&gt;，要知道Key存储的Sorted Set默认是根据Score对各个menber进行升序的排列，该命令就是用来获取menber在该排列里的次序，这就是所谓的秩。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们使用了&lt;code&gt;zrevrank&lt;/code&gt;命令而不是&lt;code&gt;zrank&lt;/code&gt;命令，这是因为Redis的默认排序是从低到高，但是在这个例子里我们的秩划分是从高到低。对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;对于Redis的5种数据结构，我们进行了高层次的概述。一件有趣的事情是，相对于最初构建时的想法，你经常能用Redis创造出一些更具实效的事情。对于字符串数据结构和分类集合数据结构的使用，很有可能存在一些构建方法是还没有人想到的。当你理解了那些常用的应用案例后，你将发现Redis对于许多类型的问题，都是很理想的选择。还有，不要因为Redis展示了5种数据结构和相应的各种方法，就认为你必须要把所有的东西都用上。只使用一些命令去构建一个特性是很常见的。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2&gt;第3章 - 使用数据结构&lt;/h2&gt;

&lt;p&gt;在上一章里，我们谈论了Redis的5种数据结构，对于一些可能的用途也给出了用例。现在是时候来看看一些更高级，但依然很常见的主题和设计模式。&lt;/p&gt;

&lt;h3&gt;大O表示法（Big O Notation）&lt;/h3&gt;

&lt;p&gt;在本书中，我们之前就已经看到过大O表示法，包括O(1)和O(N)的表示。大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。&lt;/p&gt;

&lt;p&gt;在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。让我们来看看一些用例。&lt;/p&gt;

&lt;p&gt;常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。对于&lt;code&gt;sismember&lt;/code&gt;命令，其作用是告诉我们一个值是否属于一个集合，时间复杂度为O(1)。&lt;code&gt;sismember&lt;/code&gt;命令很强大，很大部分的原因是其高效的性能特征。许多Redis命令都具有O(1)的时间复杂度。&lt;/p&gt;

&lt;p&gt;对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。使用这种“分而治之”的方式，大量的元素能在几个迭代过程里被快速分解完整。&lt;code&gt;zadd&lt;/code&gt;命令的时间复杂度就是O(log(N))，其中N是在分类集合中的元素数量。&lt;/p&gt;

&lt;p&gt;再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。&lt;code&gt;ltrim&lt;/code&gt;命令具有O(N)的时间复杂度，但是，在&lt;code&gt;ltrim&lt;/code&gt;命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。从一个具有百万元素的列表里用&lt;code&gt;ltrim&lt;/code&gt;命令删除1个元素，要比从一个具有一千个元素的列表里用&lt;code&gt;ltrim&lt;/code&gt;命令删除10个元素来的快速（实际上，两者很可能会是一样快，因为两个时间都非常的小）。&lt;/p&gt;

&lt;p&gt;根据给定的最小和最大的值的标记，&lt;code&gt;zremrangebyscore&lt;/code&gt;命令会在一个分类集合里进行删除元素操作，其时间复杂度是O(log(N)+M)。这看起来似乎有点儿杂乱，通过阅读文档可以知道，这里的N指的是在分类集合里的总元素数量，而M则是被删除的元素数量。可以看出，对于性能而言，被删除的元素数量很可能会比分类集合里的总元素数量更为重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：&lt;code&gt;zremrangebyscore&lt;/code&gt;命令的具体构成是&lt;code&gt;ZREMRANGEBYSCORE Key max mix&lt;/code&gt;。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;sort&lt;/code&gt;命令，其时间复杂度为O(N+M*log(M))，我们将会在下一章谈论更多的相关细节。从&lt;code&gt;sort&lt;/code&gt;命令的性能特征来看，可以说这是Redis里最复杂的一个命令。&lt;/p&gt;

&lt;p&gt;还存在其他的时间复杂度描述，包括O(N^2)和O(C^N)。随着N的增大，其性能将急速下降。在Redis里，没有任何一个命令具有这些类型的时间复杂度。&lt;/p&gt;

&lt;p&gt;值得指出的一点是，在Redis里，当我们发现一些操作具有O(N)的时间复杂度时，我们可能可以找到更为好的方法去处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：对于Big O Notation，相信大家都非常的熟悉，虽然原文仅仅是对该表示法进行简单的介绍，但限于个人的算法知识和文笔水平实在有限，此小节的翻译让我头痛颇久，最终成果也确实难以让人满意，望见谅。）&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;仿多关键字查询（Pseudo Multi Key Queries）&lt;/h3&gt;

&lt;p&gt;时常，你会想通过不同的关键字去查询相同的值。例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;set users:leto@dune.gov &quot;{id: 9001, email: &#39;leto@dune.gov&#39;, ...}&quot;
set users:9001 &quot;{id: 9001, email: &#39;leto@dune.gov&#39;, ...}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。&lt;/p&gt;

&lt;p&gt;如果Redis允许你将一个关键字链接到另一个的话，可能情况会好很多，可惜Redis并没有提供这样的功能（而且很可能永远都不会提供）。Redis发展到现在，其开发的首要目的是要保持代码和API的整洁简单，关键字链接功能的内部实现并不符合这个前提（对于关键字，我们还有很多相关方法没有谈论到）。其实，Redis已经提供了解决的方法：散列。&lt;/p&gt;

&lt;p&gt;使用散列数据结构，我们可以摆脱重复的缠绕：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;set users:9001 &quot;{id: 9001, email: leto@dune.gov, ...}&quot;
hset users:lookup:email leto@dune.gov 9001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们所做的是，使用域来作为一个二级索引，然后去引用单个用户对象。要通过id来获取用户信息，我们可以使用一个普通的&lt;code&gt;get&lt;/code&gt;命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;get users:9001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而如果想通过电子邮箱来获取用户信息，我们可以使用&lt;code&gt;hget&lt;/code&gt;命令再配合使用&lt;code&gt;get&lt;/code&gt;命令（Ruby代码）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;id = redis.hget(&#39;users:lookup:email&#39;, &#39;leto@dune.gov&#39;)
user = redis.get(&quot;users:#{id}&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你很可能将会经常使用这类用法。在我看来，这就是散列真正耀眼的地方。在你了解这类用法之前，这可能不是一个明显的用例。&lt;/p&gt;

&lt;h3&gt;引用和索引（References and Indexes）&lt;/h3&gt;

&lt;p&gt;我们已经看过几个关于值引用的用例，包括介绍列表数据结构时的用例，以及在上面使用散列数据结构来使查询更灵活一些。进行归纳后会发现，对于那些值与值间的索引和引用，我们都必须手动的去管理。诚实来讲，这确实会让人有点沮丧，尤其是当你想到那些引用相关的操作，如管理、更新和删除等，都必须手动的进行时。在Redis里，这个问题还没有很好的解决方法。&lt;/p&gt;

&lt;p&gt;我们已经看到，集合数据结构很常被用来实现这类索引：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd friends:leto ghanima paul chani jessica
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个集合里的每一个成员都是一个Redis字符串数据结构的引用，而每一个引用的值则包含着用户对象的具体信息。那么如果&lt;code&gt;chani&lt;/code&gt;改变了她的名字，或者删除了她的帐号，应该如何处理？从整个朋友圈的关系结构来看可能会更好理解，我们知道，&lt;code&gt;chani&lt;/code&gt;也有她的朋友：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd friends_of:chani leto paul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你有什么待处理情况像上面那样，那在维护成本之外，还会有对于额外索引值的处理和存储空间的成本。这可能会令你感到有点退缩。在下一小节里，我们将会谈论减少使用额外数据交互的性能成本的一些方法（在第1章我们粗略地讨论了下）。&lt;/p&gt;

&lt;p&gt;如果你确实在担忧着这些情况，其实，关系型数据库也有同样的开销。索引需要一定的存储空间，必须通过扫描或查找，然后才能找到相应的记录。其开销也是存在的，当然他们对此做了很多的优化工作，使之变得更为有效。&lt;/p&gt;

&lt;p&gt;再次说明，需要在Redis里手动地管理引用确实是颇为棘手。但是，对于你关心的那些问题，包括性能或存储空间等，应该在经过测试后，才会有真正的理解。我想你会发现这不会是一个大问题。&lt;/p&gt;

&lt;h3&gt;数据交互和流水线（Round Trips and Pipelining）&lt;/h3&gt;

&lt;p&gt;我们已经提到过，与服务器频繁交互是Redis的一种常见模式。这类情况可能很常出现，为了使我们能获益更多，值得仔细去看看我们能利用哪些特性。&lt;/p&gt;

&lt;p&gt;许多命令能接受一个或更多的参数，也有一种关联命令（sister-command）可以接受多个参数。例如早前我们看到过&lt;code&gt;mget&lt;/code&gt;命令，接受多个关键字，然后返回值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者是&lt;code&gt;sadd&lt;/code&gt;命令，能添加一个或多个成员到集合里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd friends:vladimir piter
sadd friends:paul jessica leto &quot;leto II&quot; chani
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis还支持流水线功能。通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。这不但减少了网络开销，还能获得性能上的显著提高。&lt;/p&gt;

&lt;p&gt;值得一提的是，Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。&lt;/p&gt;

&lt;p&gt;对于不同的Redis载体，在流水线里运行命令的方式会有所差异。在Ruby里，你传递一个代码块到&lt;code&gt;pipelined&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis.pipelined do
  9001.times do
    redis.incr(&#39;powerlevel&#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如你可能猜想到的，流水线功能可以实际地加速一连串命令的处理。&lt;/p&gt;

&lt;h3&gt;事务（Transactions）&lt;/h3&gt;

&lt;p&gt;每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。此外，对于使用多个命令，Redis支持事务功能。&lt;/p&gt;

&lt;p&gt;你可能不知道，但Redis实际上是单线程运行的，这就是为什么每一个Redis命令都能够保证具有原子性。当一个命令在执行时，没有其他命令会运行（我们会在往后的章节里简略谈论一下Scaling）。在你考虑到一些命令去做多项事情时，这会特别的有用。例如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;incr&lt;/code&gt;命令实际上就是一个&lt;code&gt;get&lt;/code&gt;命令然后紧随一个&lt;code&gt;set&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getset&lt;/code&gt;命令设置一个新的值然后返回原始值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt;命令首先测试关键字是否存在，只有当关键字不存在时才设置值&lt;/p&gt;

&lt;p&gt;虽然这些都很有用，但在实际开发时，往往会需要运行具有原子性的一组命令。若要这样做，首先要执行&lt;code&gt;multi&lt;/code&gt;命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行&lt;code&gt;exec&lt;/code&gt;命令去实际执行命令，或者使用&lt;code&gt;discard&lt;/code&gt;命令放弃执行命令。Redis的事务功能保证了什么？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事务中的命令将会按顺序地被执行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事务中的命令要么全部被执行，要么不会执行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以（也应该）在命令行界面对事务功能进行一下测试。还有一点要注意到，没有什么理由不能结合流水线功能和事务功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;multi
hincrby groups:1percent balance -9000000000
hincrby groups:99percent balance 9000000000
exec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，Redis能让你指定一个关键字（或多个关键字），当关键字有改变时，可以查看或者有条件地应用一个事务。这是用于当你需要获取值，且待运行的命令基于那些值时，所有都在一个事务里。对于上面展示的代码，我们不能去实现自己的&lt;code&gt;incr&lt;/code&gt;命令，因为一旦&lt;code&gt;exec&lt;/code&gt;命令被调用，他们会全部被执行在一块。我们不能这么做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis.multi()
current = redis.get(&#39;powerlevel&#39;)
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（译注：虽然Redis是单线程运行的，但是我们可以同时运行多个Redis客户端进程，常见的并发问题还是会出现。像上面的代码，在&lt;code&gt;get&lt;/code&gt;运行之后，&lt;code&gt;set&lt;/code&gt;运行之前，&lt;code&gt;powerlevel&lt;/code&gt;的值可能会被另一个Redis客户端给改变，从而造成错误。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些不是Redis的事务功能的工作。但是，如果我们增加一个&lt;code&gt;watch&lt;/code&gt;到&lt;code&gt;powerlevel&lt;/code&gt;，我们可以这样做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;redis.watch(&#39;powerlevel&#39;)
current = redis.get(&#39;powerlevel&#39;)
redis.multi()
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们调用&lt;code&gt;watch&lt;/code&gt;后，如果另一个客户端改变了&lt;code&gt;powerlevel&lt;/code&gt;的值，我们的事务将会运行失败。如果没有客户端改变&lt;code&gt;powerlevel&lt;/code&gt;的值，那么事务会继续工作。我们可以在一个循环里运行这些代码，直到其能正常工作。&lt;/p&gt;

&lt;h3&gt;关键字反模式（Keys Anti-Pattern）&lt;/h3&gt;

&lt;p&gt;在下一章中，我们将会谈论那些没有确切关联到数据结构的命令，其中的一些是管理或调试工具。然而有一个命令我想特别地在这里进行谈论：&lt;code&gt;keys&lt;/code&gt;命令。这个命令需要一个模式，然后查找所有匹配的关键字。这个命令看起来很适合一些任务，但这不应该用在实际的产品代码里。为什么？因为这个命令通过线性扫描所有的关键字来进行匹配。或者，简单地说，这个命令太慢了。&lt;/p&gt;

&lt;p&gt;人们会如此去使用这个命令？一般会用来构建一个本地的Bug追踪服务。每一个帐号都有一个&lt;code&gt;id&lt;/code&gt;，你可能会通过一个看起来像&lt;code&gt;bug:account_id:bug_id&lt;/code&gt;的关键字，把每一个Bug存储到一个字符串数据结构值中去。如果你在任何时候需要查询一个帐号的Bug（显示它们，或者当用户删除了帐号时删除掉这些Bugs），你可能会尝试去使用&lt;code&gt;keys&lt;/code&gt;命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;keys bug:1233:*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更好的解决方法应该使用一个散列数据结构，就像我们可以使用散列数据结构来提供一种方法去展示二级索引，因此我们可以使用域来组织数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;hset bugs:1233 1 &quot;{id:1, account: 1233, subject: &#39;...&#39;}&quot;
hset bugs:1233 2 &quot;{id:2, account: 1233, subject: &#39;...&#39;}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从一个帐号里获取所有的Bug标识，可以简单地调用&lt;code&gt;hkeys bugs:1233&lt;/code&gt;。去删除一个指定的Bug，可以调用&lt;code&gt;hdel bugs:1233 2&lt;/code&gt;。如果要删除了一个帐号，可以通过&lt;code&gt;del bugs:1233&lt;/code&gt;把关键字删除掉。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;结合这一章以及前一章，希望能让你得到一些洞察力，了解如何使用Redis去支持（Power）实际项目。还有其他的模式可以让你去构建各种类型的东西，但真正的关键是要理解基本的数据结构。你将能领悟到，这些数据结构是如何能够实现你最初视角之外的东西。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2&gt;第4章 超越数据结构&lt;/h2&gt;

&lt;p&gt;5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。我们已经看过一些这样的命令：&lt;code&gt;info&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;flushdb&lt;/code&gt;, &lt;code&gt;multi&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;discard&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;和&lt;code&gt;keys&lt;/code&gt;。这一章将看看其他的一些重要命令。&lt;/p&gt;

&lt;h3&gt;使用期限（Expiration）&lt;/h3&gt;

&lt;p&gt;Redis允许你标记一个关键字的使用期限。你可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。这是一个基于关键字的命令，因此其不在乎关键字表示的是哪种类型的数据结构。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;expire pages:about 30
expireat pages:about 1356933600
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个命令将会在30秒后删除掉关键字（包括其关联的值）。第二个命令则会在2012年12月31日上午12点删除掉关键字。&lt;/p&gt;

&lt;p&gt;这让Redis能成为一个理想的缓冲引擎。通过&lt;code&gt;ttl&lt;/code&gt;命令，你可以知道一个关键字还能够存活多久。而通过&lt;code&gt;persist&lt;/code&gt;命令，你可以把一个关键字的使用期限删除掉。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ttl pages:about
persist pages:about
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，有个特殊的字符串命令，&lt;code&gt;setex&lt;/code&gt;命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期（这比任何事情都要方便）。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;setex pages:about 30 &#39;&amp;lt;h1&amp;gt;about us&amp;lt;/h1&amp;gt;....&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;发布和订阅（Publication and Subscriptions）&lt;/h3&gt;

&lt;p&gt;Redis的列表数据结构有&lt;code&gt;blpop&lt;/code&gt;和&lt;code&gt;brpop&lt;/code&gt;命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（译注：对于&lt;code&gt;blpop&lt;/code&gt;和&lt;code&gt;brpop&lt;/code&gt;命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用&lt;code&gt;lpush&lt;/code&gt;或&lt;code&gt;rpush&lt;/code&gt;命令推入关键字为止。）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此外，Redis对于消息发布和频道订阅有着一流的支持。你可以打开第二个&lt;code&gt;redis-cli&lt;/code&gt;窗口，去尝试一下这些功能。在第一个窗口里订阅一个频道（我们会称它为&lt;code&gt;warnings&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;subscribe warnings
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其将会答复你订阅的信息。现在，在另一个窗口，发布一条消息到&lt;code&gt;warnings&lt;/code&gt;频道：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;publish warnings &quot;it&#39;s over 9000!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你回到第一个窗口，你应该已经接收到&lt;code&gt;warnings&lt;/code&gt;频道发来的消息。&lt;/p&gt;

&lt;p&gt;你可以订阅多个频道（&lt;code&gt;subscribe channel1 channel2 ...&lt;/code&gt;），订阅一组基于模式的频道（&lt;code&gt;psubscribe warnings:*&lt;/code&gt;），以及使用&lt;code&gt;unsubscribe&lt;/code&gt;和&lt;code&gt;punsubscribe&lt;/code&gt;命令停止监听一个或多个频道，或一个频道模式。&lt;/p&gt;

&lt;p&gt;最后，可以注意到&lt;code&gt;publish&lt;/code&gt;命令的返回值是1，这指出了接收到消息的客户端数量。&lt;/p&gt;

&lt;h3&gt;监控和延迟日志（Monitor and Slow Log）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;monitor&lt;/code&gt;命令可以让你查看Redis正在做什么。这是一个优秀的调试工具，能让你了解你的程序如何与Redis进行交互。在两个&lt;code&gt;redis-cli&lt;/code&gt;窗口中选一个（如果其中一个还处于订阅状态，你可以使用&lt;code&gt;unsubscribe&lt;/code&gt;命令退订，或者直接关掉窗口再重新打开一个新窗口）键入&lt;code&gt;monitor&lt;/code&gt;命令。在另一个窗口，执行任何其他类型的命令（例如&lt;code&gt;get&lt;/code&gt;或&lt;code&gt;set&lt;/code&gt;命令）。在第一个窗口里，你应该可以看到这些命令，包括他们的参数。&lt;/p&gt;

&lt;p&gt;在实际生产环境里，你应该谨慎运行&lt;code&gt;monitor&lt;/code&gt;命令，这真的仅仅就是一个很有用的调试和开发工具。除此之外，没有更多要说的了。&lt;/p&gt;

&lt;p&gt;随同&lt;code&gt;monitor&lt;/code&gt;命令一起，Redis拥有一个&lt;code&gt;slowlog&lt;/code&gt;命令，这是一个优秀的性能剖析工具。其会记录执行时间超过一定数量&lt;strong&gt;微秒&lt;/strong&gt;的命令。在下一章节，我们会简略地涉及如何配置Redis，现在你可以按下面的输入配置Redis去记录所有的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;config set slowlog-log-slower-than 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，执行一些命令。最后，你可以检索到所有日志，或者检索最近的那些日志：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;slowlog get
slowlog get 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过键入&lt;code&gt;slowlog len&lt;/code&gt;，你可以获取延迟日志里的日志数量。&lt;/p&gt;

&lt;p&gt;对于每个被你键入的命令，你应该查看4个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个自动递增的id&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个Unix时间戳，表示命令开始运行的时间&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个微妙级的时间，显示命令运行的总时间&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该命令以及所带参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;延迟日志保存在存储器中，因此在生产环境中运行（即使有一个低阀值）也应该不是一个问题。默认情况下，它将会追踪最近的1024个日志。&lt;/p&gt;

&lt;h3&gt;排序（Sort）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;命令是Redis最强大的命令之一。它让你可以在一个列表、集合或者分类集合里对值进行排序（分类集合是通过标记来进行排序，而不是集合里的成员）。下面是一个&lt;code&gt;sort&lt;/code&gt;命令的简单用例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;rpush users:leto:guesses 5 9 10 2 4 10 19 2
sort users:leto:guesses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将返回进行升序排序后的值。这里有一个更高级的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd friends:ghanima leto paul chani jessica alia duncan
sort friends:ghanima limit 0 3 desc alpha
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的命令向我们展示了，如何对已排序的记录进行分页（通过&lt;code&gt;limit&lt;/code&gt;），如何返回降序排序的结果（通过&lt;code&gt;desc&lt;/code&gt;），以及如何用字典序排序代替数值序排序（通过&lt;code&gt;alpha&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;命令的真正力量是其基于引用对象来进行排序的能力。早先的时候，我们说明了列表、集合和分类集合很常被用于引用其他的Redis对象，&lt;code&gt;sort&lt;/code&gt;命令能够解引用这些关系，而且通过潜在值来进行排序。例如，假设我们有一个Bug追踪器能让用户看到各类已存在问题。我们可能使用一个集合数据结构去追踪正在被监视的问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sadd watch:leto 12339 1382 338 9338
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可能会有强烈的感觉，想要通过id来排序这些问题（默认的排序就是这样的），但是，我们更可能是通过问题的严重性来对这些问题进行排序。为此，我们要告诉Redis将使用什么模式来进行排序。首先，为了可以看到一个有意义的结果，让我们添加多一点数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;set severity:12339 3
set severity:1382 2
set severity:338 5
set severity:9338 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要通过问题的严重性来降序排序这些Bug，你可以这样做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sort watch:leto by severity:* desc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis将会用存储在列表（集合或分类集合）中的值去替代模式中的&lt;code&gt;*&lt;/code&gt;（通过&lt;code&gt;by&lt;/code&gt;）。这会创建出关键字名字，Redis将通过查询其实际值来排序。&lt;/p&gt;

&lt;p&gt;在Redis里，虽然你可以有成千上万个关键字，类似上面展示的关系还是会引起一些混乱。幸好，&lt;code&gt;sort&lt;/code&gt;命令也可以工作在散列数据结构及其相关域里。相对于拥有大量的高层次关键字，你可以利用散列：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;hset bug:12339 severity 3
hset bug:12339 priority 1
hset bug:12339 details &quot;{id: 12339, ....}&quot;

hset bug:1382 severity 2
hset bug:1382 priority 2
hset bug:1382 details &quot;{id: 1382, ....}&quot;

hset bug:338 severity 5
hset bug:338 priority 3
hset bug:338 details &quot;{id: 338, ....}&quot;

hset bug:9338 severity 4
hset bug:9338 priority 2
hset bug:9338 details &quot;{id: 9338, ....}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的事情不仅变得更为容易管理，而且我们能通过&lt;code&gt;severity&lt;/code&gt;或&lt;code&gt;priority&lt;/code&gt;来进行排序，还可以告诉&lt;code&gt;sort&lt;/code&gt;命令具体要检索出哪一个域的数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sort watch:leto by bug:*-&amp;gt;priority get bug:*-&amp;gt;details
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相同的值替代出现了，但Redis还能识别&lt;code&gt;-&amp;gt;&lt;/code&gt;符号，用它来查看散列中指定的域。里面还包括了&lt;code&gt;get&lt;/code&gt;参数，这里也会进行值替代和域查看，从而检索出Bug的细节（details域的数据）。&lt;/p&gt;

&lt;p&gt;对于太大的集合，&lt;code&gt;sort&lt;/code&gt;命令的执行可能会变得很慢。好消息是，&lt;code&gt;sort&lt;/code&gt;命令的输出可以被存储起来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sort watch:leto by bug:*-&amp;gt;priority get bug:*-&amp;gt;details store watch_by_priority:leto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用我们已经看过的&lt;code&gt;expiration&lt;/code&gt;命令，再结合&lt;code&gt;sort&lt;/code&gt;命令的&lt;code&gt;store&lt;/code&gt;能力，这是一个美妙的组合。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;这一章主要关注那些非特定数据结构关联的命令。和其他事情一样，它们的使用依情况而定。构建一个程序或特性时，可能不会用到使用期限、发布和订阅或者排序等功能。但知道这些功能的存在是很好的。而且，我们也只接触到了一些命令。还有更多的命令，当你消化理解完这本书后，非常值得去浏览一下&lt;a href=&quot;http://redis.io/commands&quot;&gt;完整的命令列表&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2&gt;第5章 - 管理&lt;/h2&gt;

&lt;p&gt;在最后一章里，我们将集中谈论Redis运行中的一些管理方面内容。这是一个不完整的Redis管理指南，我们将会回答一些基本的问题，初接触Redis的新用户可能会很感兴趣。&lt;/p&gt;

&lt;h3&gt;配置（Configuration）&lt;/h3&gt;

&lt;p&gt;当你第一次运行Redis的服务器，它会向你显示一个警告，指&lt;code&gt;redis.conf&lt;/code&gt;文件没有被找到。这个文件可以被用来配置Redis的各个方面。一个充分定义（well-documented）的&lt;code&gt;redis.conf&lt;/code&gt;文件对各个版本的Redis都有效。范例文件包含了默认的配置选项，因此，对于想要了解设置在干什么，或默认设置是什么，都会很有用。你可以在&lt;a href=&quot;https://github.com/antirez/redis/raw/2.4.6/redis.conf&quot;&gt;https://github.com/antirez/redis/raw/2.4.6/redis.conf&lt;/a&gt;找到这个文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个配置文件针对的是Redis 2.4.6，你应该用你的版本号替代上面URL里的&amp;quot;2.4.6&amp;quot;。运行&lt;code&gt;info&lt;/code&gt;命令，其显示的第一个值就是Redis的版本号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为这个文件已经是充分定义（well-documented），我们就不去再进行设置了。&lt;/p&gt;

&lt;p&gt;除了通过&lt;code&gt;redis.conf&lt;/code&gt;文件来配置Redis，&lt;code&gt;config set&lt;/code&gt;命令可以用来对个别值进行设置。实际上，在将&lt;code&gt;slowlog-log-slower-than&lt;/code&gt;设置为0时，我们就已经使用过这个命令了。&lt;/p&gt;

&lt;p&gt;还有一个&lt;code&gt;config get&lt;/code&gt;命令能显示一个设置值。这个命令支持模式匹配，因此如果我们想要显示关联于日志（logging）的所有设置，我们可以这样做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;config get *log*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;验证（Authentication）&lt;/h3&gt;

&lt;p&gt;通过设置&lt;code&gt;requirepass&lt;/code&gt;（使用&lt;code&gt;config set&lt;/code&gt;命令或&lt;code&gt;redis.conf&lt;/code&gt;文件），可以让Redis需要一个密码验证。当&lt;code&gt;requirepass&lt;/code&gt;被设置了一个值（就是待用的密码），客户端将需要执行一个&lt;code&gt;auth password&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;一旦一个客户端通过了验证，就可以在任意数据库里执行任何一条命令，包括&lt;code&gt;flushall&lt;/code&gt;命令，这将会清除掉每一个数据库里的所有关键字。通过配置，你可以重命名一些重要命令为混乱的字符串，从而获得一些安全性。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
rename-command FLUSHALL 1041285018a942a4922cbf76623b741e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，你可以将新名字设置为一个空字符串，从而禁用掉一个命令。&lt;/p&gt;

&lt;h3&gt;大小限制（Size Limitations）&lt;/h3&gt;

&lt;p&gt;当你开始使用Redis，你可能会想知道，我能使用多少个关键字？还可能想知道，一个散列数据结构能有多少个域（尤其是当你用它来组织数据时），或者是，一个列表数据结构或集合数据结构能有多少个元素？对于每一个实例，实际限制都能达到亿万级别（hundreds of millions）。&lt;/p&gt;

&lt;h3&gt;复制（Replication）&lt;/h3&gt;

&lt;p&gt;Redis支持复制功能，这意味着当你向一个Redis实例（Master）进行写入时，一个或多个其他实例（Slaves）能通过Master实例来保持更新。可以在配置文件里设置&lt;code&gt;slaveof&lt;/code&gt;，或使用&lt;code&gt;slaveof&lt;/code&gt;命令来配置一个Slave实例。对于那些没有进行这些设置的Redis实例，就可能一个Master实例。&lt;/p&gt;

&lt;p&gt;为了更好保护你的数据，复制功能拷贝数据到不同的服务器。复制功能还能用于改善性能，因为读取请求可以被发送到Slave实例。他们可能会返回一些稍微滞后的数据，但对于大多数程序来说，这是一个值得做的折衷。&lt;/p&gt;

&lt;p&gt;遗憾的是，Redis的复制功能还没有提供自动故障恢复。如果Master实例崩溃了，一个Slave实例需要手动的进行升级。如果你想使用Redis去达到某种高可用性，对于使用心跳监控（heartbeat monitoring）和脚本自动开关（scripts to automate the switch）的传统高可用性工具来说，现在还是一个棘手的难题。&lt;/p&gt;

&lt;h3&gt;备份文件（Backups）&lt;/h3&gt;

&lt;p&gt;备份Redis非常简单，你可以将Redis的快照（snapshot）拷贝到任何地方，包括S3、FTP等。默认情况下，Redis会把快照存储为一个名为&lt;code&gt;dump.rdb&lt;/code&gt;的文件。在任何时候，你都可以对这个文件执行&lt;code&gt;scp&lt;/code&gt;、&lt;code&gt;ftp&lt;/code&gt;或&lt;code&gt;cp&lt;/code&gt;等常用命令。&lt;/p&gt;

&lt;p&gt;有一种常见情况，在Master实例上会停用快照以及单一附加文件（aof），然后让一个Slave实例去处理备份事宜。这可以帮助减少Master实例的载荷。在不损害整体系统响应性的情况下，你还可以在Slave实例上设置更多主动存储的参数。&lt;/p&gt;

&lt;h3&gt;缩放和Redis集群（Scaling and Redis Cluster）&lt;/h3&gt;

&lt;p&gt;复制功能（Replication）是一个成长中的网站可以利用的第一个工具。有一些命令会比另外一些来的昂贵（例如&lt;code&gt;sort&lt;/code&gt;命令），将这些运行载荷转移到一个Slave实例里，可以保持整体系统对于查询的快速响应。&lt;/p&gt;

&lt;p&gt;此外，通过分发你的关键字到多个Redis实例里，可以达到真正的缩放Redis（记住，Redis是单线程的，这些可以运行在同一个逻辑框里）。随着时间的推移，你将需要特别注意这些事情（尽管许多的Redis载体都提供了consistent-hashing算法）。对于数据水平分布（horizontal distribution）的考虑不在这本书所讨论的范围内。这些东西你也很可能不需要去担心，但是，无论你使用哪一种解决方案，有一些事情你还是必须意识到。&lt;/p&gt;

&lt;p&gt;好消息是，这些工作都可在Redis集群下进行。不仅提供水平缩放（包括均衡），为了高可用性，还提供了自动故障恢复。&lt;/p&gt;

&lt;p&gt;高可用性和缩放是可以达到的，只要你愿意为此付出时间和精力，Redis集群也使事情变得简单多了。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;在过去的一段时间里，已经有许多的计划和网站使用了Redis，毫无疑问，Redis已经可以应用于实际生产中了。然而，一些工具还是不够成熟，尤其是一些安全性和可用性相关的工具。对于Redis集群，我们希望很快就能看到其实现，这应该能为一些现有的管理挑战提供处理帮忙。&lt;/p&gt;

&lt;p&gt;\clearpage&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;在许多方面，Redis体现了一种简易的数据处理方式，其剥离掉了大部分的复杂性和抽象，并可有效的在不同系统里运行。不少情况下，选择Redis不是最佳的选择。在另一些情况里，Redis就像是为你的数据提供了特别定制的解决方案。&lt;/p&gt;

&lt;p&gt;最终，回到我最开始所说的：Redis很容易学习。现在有许多的新技术，很难弄清楚哪些才真正值得我们花时间去学习。如果你从实际好处来考虑，Redis提供了他的简单性。我坚信，对于你和你的团队，学习Redis是最好的技术投资之一。&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/06/20/redis-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/06/20/redis-study/</guid>
        
        <category>Clover</category>
        
        <category>Redis</category>
        
        <category>DB</category>
        
        
      </item>
    
      <item>
        <title>Monogo DB Study</title>
        <description>&lt;h1&gt;MonogoDB  学习笔记&lt;/h1&gt;

&lt;hr&gt;

&lt;h1&gt;入门篇&lt;/h1&gt;

&lt;hr&gt;

&lt;h2&gt;学习目标&lt;/h2&gt;

&lt;hr&gt;

&lt;h4&gt;Mongo 概念&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mongo&lt;/code&gt; &lt;code&gt;MongoDB&lt;/code&gt; &lt;code&gt;索引&lt;/code&gt; &lt;code&gt;集合&lt;/code&gt; &lt;code&gt;复制集&lt;/code&gt; &lt;code&gt;分片&lt;/code&gt; &lt;code&gt;数据均衡&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;学会MongoDB的搭建&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;搭建简单的单击服务&lt;/li&gt;
&lt;li&gt;搭建具有冗余容错功能的复制集&lt;/li&gt;
&lt;li&gt;搭建大规模数据集群&lt;/li&gt;
&lt;li&gt;完成集群的自动部署&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;MongoDB的使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;最基本的文档的读写和更新&lt;/li&gt;
&lt;li&gt;各种不同类型的索引的创建与使用&lt;/li&gt;
&lt;li&gt;复杂的聚合查询&lt;/li&gt;
&lt;li&gt;对数据集合进行分片，在不同分片间维持数据均衡&lt;/li&gt;
&lt;li&gt;数据备份与恢复&lt;/li&gt;
&lt;li&gt;数据迁移&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;简单运维&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;部署集群&lt;/li&gt;
&lt;li&gt;处理多种常见的故障&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt; 单节点失效，如何恢复工作
 数据库意外被杀死如何进行数据恢复
 数据库拒绝服务如何排除原因
 数据库磁盘快慢时如何处理

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;学习资源&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MongoDB官网&lt;/strong&gt; &lt;code&gt;www.mongodb.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MongoDB中国官网&lt;/strong&gt; &lt;code&gt;www.mongoing.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;github&lt;/strong&gt; &lt;code&gt;https://github.com/mongodb/mongo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中文文档&lt;/strong&gt; &lt;code&gt;docs.mongoing.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视频资源&lt;/strong&gt; &lt;code&gt;http://www.imooc.com/video/5934&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h1&gt;开始学习&lt;/h1&gt;

&lt;hr&gt;

&lt;h2&gt;数据库&lt;/h2&gt;

&lt;hr&gt;

&lt;h3&gt;概念&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有组织的存放数据&lt;/li&gt;
&lt;li&gt;按照不同的需求进行查询&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;数据库分类&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;sql数据库：支持sql语言的数据库 Oracle,Mysql&lt;/li&gt;
&lt;li&gt;NoSql数据库：不支持SQL语言的数据库 Redis,MongoDB&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sql 数据库 | NoSql数据库 
----------|------------- 
实时一致性       | 简单便捷 
事务          |方便扩展
多表联合查询   | 更好的性能&lt;/p&gt;

&lt;h3&gt;为什么是MongoDB&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;无数据结构的限制&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有表结构的概念，每条记录可以有完全不同的结构&lt;/li&gt;
&lt;li&gt;业务开发方便快捷&lt;/li&gt;
&lt;li&gt;sql数据库需要先定义表结构再使用&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,sex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;男&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;上海&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,home&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;山东&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;江西&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完全的索引支持&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;redis的key-value&lt;/li&gt;
&lt;li&gt;hbase的单索引    ，二级索引需要自己实现&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;单键索引，多键索引：{x:1,y:1}
数组索引：[&quot;apple&quot;,&quot;lemon&quot;]
全文索引：“I am a little bird” (中文)
地理位置索引：2D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方便的冗余和扩展&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;复制集保证数据安全&lt;/li&gt;
&lt;li&gt;分片扩展数据规模&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;良好的支持&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;完善的文档&lt;/li&gt;
&lt;li&gt;齐全的驱动支持&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;blockquote&gt;
&lt;p&gt;安装过程 略过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# mkdir data
# mkdir log
# mkdir conf
# mkdir bin
# cd conf
# vim mongodb.conf
  port=27017
  dbpath=data
  logpath=log/mongod.log
  fork=true
启动 # mongod -f conf/mongodb.conf   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接 mongo 121.41.31.214:27017
数据库的关闭 连接时   db.shutdownServer()&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;mongoDB的基本操作&lt;/h2&gt;

&lt;hr&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;
查看所有数据库
&amp;gt; show dbs

切换数据库
&amp;gt; use dbname

删除当前数据库,（需要先use）
&amp;gt; db.dropDatabase();

创建表 (不要特殊创建 只需要use 一个不存在的name mongoDb会在需要的时候自己创建，一个表是一个集合)
&amp;gt; use dbname

数据的写入  db.集合名.insert(json数据) 表集合不存在的话自动创建 _id自动创建 _id自定义时不能重复
&amp;gt; db.dbname_collection.insert({x:1})

数据的查询 db.集合名.find()  参数可以为空，返回所有文档
&amp;gt; db.dbname_collection.find()
&amp;gt; db.dbname_collection.find({x:1})   查询x=1的文档

循环插入
&amp;gt; for(i=3;i&amp;lt;100;i++)db.dbname_collection.insert({x:i})

计数
&amp;gt; db.dbname_collection.find().count()

跳过，限制条数，排序
&amp;gt; db.dbname_collection.find().skip(3).limit(2).sort({x:1})


数据更新 db.集合名.find(查询条件,更新条目)  默认只会更新第一条找到的数据
&amp;gt; db.dbname_collection.update({x:1},{x:999})  会更新x=1的文档为 {x:999}
注意：db.dbname_collection.insert({x:1,y:2,z:3}) 若要更新z=3的文档 把x更新为22， 使用 db.dbname_collection.update({z:3},{x:22})  会把{x:1,y:2,z:3}整体覆盖为{x:22} 

局部更新
&amp;gt;db.dbname_collection.update({z:3},{$set:{x:22}})  局部更新 不会被覆盖

更新不存在的数据，即自动创建 第三个参数 true 标示不存在的时候自动创建
&amp;gt; db.dbname_collection.update({x:3},{x:22},true)

批量更新  第四个参数 true 批量更新
&amp;gt; db.dbname_collection.update({x:1},{$set:{x:22}},false,true)

数据删除  必须传参，默认删除所有找的数据
&amp;gt; db.dbname_collection.remove({x:1})
&amp;gt; db.dbname_collection.drop()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;MongoDB索引&lt;/h2&gt;

&lt;hr&gt;

&lt;h4&gt;内容简介&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;索引的种类和使用&lt;/li&gt;
&lt;li&gt;索引的匹配规则&lt;/li&gt;
&lt;li&gt;如何建立合适的索引&lt;/li&gt;
&lt;li&gt;索引建立的情况评估&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;查看索引
&amp;gt; db.dbname_collection.getIndexes()

创建索引  参数也是文档  1代表正向排序 -1 代表逆向排序
&amp;gt; db.dbname_collection.ensureIndex({x:1})

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;索引的种类&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;_id索引&lt;/li&gt;
&lt;li&gt; 单键索引&lt;/li&gt;
&lt;li&gt; 多键索引&lt;/li&gt;
&lt;li&gt; 复合索引&lt;/li&gt;
&lt;li&gt; 过期索引&lt;/li&gt;
&lt;li&gt; 全文索引&lt;/li&gt;
&lt;li&gt; 地理位置索引&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;_id索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;_id索引是绝大多数集合默认建立的索引&lt;/li&gt;
&lt;li&gt;对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;单键索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;单键索引是最普通的索引&lt;/li&gt;
&lt;li&gt;与_id索引不同，单键索引不会自动创建&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;多键索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;多键索引与单键索引创建形式相同，区别在于字段的值

&lt;ul&gt;
&lt;li&gt;单键索引：值为单一的值，例如字符串，数字或者日期&lt;/li&gt;
&lt;li&gt;多键索引：值具有多个记录，例如数组
##### 复合索引&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当我们的查询条件不只有一个时，就需要建立复合索引

&lt;ul&gt;
&lt;li&gt;插入{x:1,y:2,z:3}-&amp;gt;按照x与y的值查询-&amp;gt;创建索引db.collection.ensureIndex({x:1,y:1})-&amp;gt;使用{x:1,y:1}作为条件进行查询&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;过期索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;过期索引：是在一段时间后会过期的索引&lt;/li&gt;
&lt;li&gt;在索引过期后，相应的数据会被删除&lt;/li&gt;
&lt;li&gt;这适合存储一些在一些时间后会失效的数据 比如用户的登陆信息，存储的日志&lt;br&gt;&lt;/li&gt;
&lt;li&gt;建立方法：db.collection.ensureIndex({time:1},{expireAfterSeconds:10}),第二个参数是过期时间的秒数&lt;/li&gt;
&lt;li&gt;过期索引的限制

&lt;ol&gt;
&lt;li&gt;存储在过期索引字段的值必须是指定的时间类型，说明：必须是ISODate或者ISODate数组，不能使用时间戳，否则不能被自动删除&lt;/li&gt;
&lt;li&gt;如果指定了ISODate数组，则按照最小的时间进行删除&lt;/li&gt;
&lt;li&gt;过期索引不能是复合索引&lt;/li&gt;
&lt;li&gt;删除时间是不精确的 说明：删除过程是由后台程序每60S跑一次，而且删除也需要一些时间，所以存在误差&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;全文索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 全文索引：对字符串与字符串数组创建全文可搜索的索引
适用情况{author:&amp;quot;&amp;quot;,title:&amp;quot;&amp;quot;,article:&amp;quot;&amp;quot;}&lt;/li&gt;
&lt;li&gt;建立方法
db.articles.ensureIndex({key:&amp;quot;text&amp;quot;})
db.articles.ensureIndex({key&lt;em&gt;1:&amp;quot;text&amp;quot;,key&lt;/em&gt;2:&amp;quot;text&amp;quot;})
db.articles.ensureIndex({&amp;quot;$**&amp;quot;:&amp;quot;text&amp;quot;})&lt;/li&gt;
&lt;li&gt;如何创建全文索引&lt;br&gt;
db.imooc_2.ensureIndex({&amp;quot;article&amp;quot;:&amp;quot;text&amp;quot;})&lt;/li&gt;
&lt;li&gt;如何使用全文索引进行查询

&lt;ol&gt;
&lt;li&gt; db.articles.find({$text:{$search:&amp;quot;coffee&amp;quot;}})&lt;/li&gt;
&lt;li&gt; db.articles.find({$text:{$search:&amp;quot;aa bb cc&amp;quot;}}) 查询 aa 或bb 或cc&lt;/li&gt;
&lt;li&gt; db.articles.find({$text:{$search:&amp;quot;aa bb -cc&amp;quot;}}) 查询aa 或bb 不包含cc&lt;/li&gt;
&lt;li&gt; db.articles.find({$text:{$search:&amp;quot;\&amp;quot;aa\&amp;quot; \&amp;quot;bb\&amp;quot; \&amp;quot;cc\&amp;quot;&amp;quot;}}) 且的关系 既包含aa也包含bb也包含cc&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;全文索引的相似度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$meta操作符：{score:{$meta:&amp;quot;textScore&amp;quot;}}
  写在查询条件后面可以返回结果的相似度与sort一起使用，可以达到很好的实用效果 db.articles.find({$text:{$search:&amp;quot;aa bb&amp;quot;}},{score:{$meta:&amp;quot;tetxScore&amp;quot;}}).sort({score:{$meta:&amp;quot;tetxScore&amp;quot;}})
* 全文索引的使用限制
  1.每次查询，只能指定一个$text查询
  2. $test查询不能出现在$nor查询中&lt;br&gt;
  3. 查询中如果包含了$test,hint不再起作用
  很可惜，MongoDB全文索引还不支持中文&lt;/p&gt;

&lt;h4&gt;索引属性&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;创建索引的格式
db,collection.ensureIndex({param},{param}) 
其中第二个参数便是索引的属性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较重要的属性有 名字 唯一性 稀疏性 是否定时删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;名字，name指定：db.collection.ensureIndex({},{name:&amp;quot;&amp;quot;})&lt;/li&gt;
&lt;li&gt;唯一性，unique指定：db.collection.ensureIndex({},{unique:true/false})&lt;/li&gt;
&lt;li&gt;稀疏性，sparse指定：db.collection.ensureIndex({},{sparse:true/false}) 默认是不稀疏的
db.collection.find({m:{$exists:true}})查询存在m的文档
db.collection.ensureIndex({m:1},{sparse:true})&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;db.collection.find({m:{$exists:false}})
&lt;strong&gt;在选取索引  在稀疏索引上 查找是否存在 将不使用稀疏索引&lt;/strong&gt;
强制使用索引 db.collection.find({m:{$exists:false}}).hint(&amp;quot;m_1&amp;quot;)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;* 是否定时删除，expireAfterSeconds指定
TTL，过期索引
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;地理位置索引&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;将一些点的位置存储在MongoDB中，创建索引后，可以按照位置来查找其他点

&lt;ul&gt;
&lt;li&gt;子分类:&lt;/li&gt;
&lt;li&gt;2d索引，用于存储和查找平面上的点。&lt;/li&gt;
&lt;li&gt;2dsphere索引，用于存储和查找球面上的点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查找方式

&lt;ul&gt;
&lt;li&gt;查找距离某个点一定距离的点&lt;br&gt;&lt;/li&gt;
&lt;li&gt;查找包含在某区域内的点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;
2D索引：平面地理位置索引
        创建方式:db.collection.ensureIndex({w:&quot;2d&quot;})
        位置表示方式：经纬度[经度,维度]
        取值范围：经度[-180,180]维度[-90,90]
        db.collection.insert({w:[100,2]})
        db.collection.find({w:{$near:[1,1]}})
        near会返回100个离查询的点最近的点
        db.collection.find({w:{$near:[1,1]，$maxDistance:10}})  

        查询方式：
        （1）$near查询：查询距离某个点最近的点
        （2）$geoWithin查询：查询某个形状内的点

        形状的标示：
        1.$box:矩形，使用
        {$box[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],[&amp;lt;x2&amp;gt;,&amp;lt;y2&amp;gt;]]}  1.左边界 2.右边界
        2.$center:圆形，使用
        {$center:[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],r]} 1.圆心位置 2.半径
        3.$polygon:多边形，使用
        {$polygon：[[&amp;lt;x1&amp;gt;,&amp;lt;y1&amp;gt;],[&amp;lt;x2&amp;gt;,&amp;lt;y2&amp;gt;],[&amp;lt;x3&amp;gt;,&amp;lt;y3&amp;gt;]]}

        db.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}})

    geoNear查询
    geoNear使用runCommand命令进行使用
    {
    geoNear:&amp;lt;collection&amp;gt;,
    near:[x,y],
    minDistance:(对2D索引无效)
    MaxDistance:
    num:
    }

    db.runCommand({geoNear:&quot;location&quot;,near:[1,2],maxDistance:10,num:1})


2dsphere: 
创建方式:db.collection.ensureIndex({w:&quot;2dsphere&quot;})
位置表示方式
GeoJson:描述一个点，一条直线，多边形等
格式：{type:&quot;&quot;,coordinates:[&amp;lt;coordinates&amp;gt;]}
查询方式和2D索引查询方式类似
支持$minDistance与$maxDistance

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;索引构建情况分析&lt;/h2&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;索引好处：加快索引相关的查询&lt;/li&gt;
&lt;li&gt;索引不好处：增加磁盘空间消耗，降低写入性能&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;如何评判当前索引构建情况

&lt;ol&gt;
&lt;li&gt;mongostat工具介绍&lt;/li&gt;
&lt;li&gt;profile集合介绍&lt;/li&gt;
&lt;li&gt;日志介绍&lt;/li&gt;
&lt;li&gt;explain分析&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;mongostat工具&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;mongostat查看mongodb运行状态的程序&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用说明 :mongostat -h 127.0.0.1:12345&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字段说明:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inserts&lt;/li&gt;
&lt;li&gt;query&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;getmore&lt;/li&gt;
&lt;li&gt;command&lt;/li&gt;
&lt;li&gt;flushes&lt;/li&gt;
&lt;li&gt;mapped&lt;/li&gt;
&lt;li&gt;vsize&lt;/li&gt;
&lt;li&gt;res&lt;/li&gt;
&lt;li&gt;non-mapped&lt;/li&gt;
&lt;li&gt;faults&lt;/li&gt;
&lt;li&gt;locked&lt;/li&gt;
&lt;li&gt;idx miss 索引情况&lt;/li&gt;
&lt;li&gt;qr|qw&lt;/li&gt;
&lt;li&gt;ar|aw&lt;/li&gt;
&lt;li&gt;netIn&lt;/li&gt;
&lt;li&gt;netOut&lt;/li&gt;
&lt;li&gt;conn&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;repl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;profile集合&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;db.getProfilingStatus()&lt;/li&gt;
&lt;li&gt;&lt;p&gt;db.setProfilingLevel(2)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;db.system.profile.find().sort({$natural:-1}).limit(1)  &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;日志&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;mongodb.conf 中 verbose=vvvvv    v越多代表日志越详细&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;explain&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;db.collection.find({x:1}).explain()&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;MongoDB 安全&lt;/h2&gt;

&lt;hr&gt;

&lt;h3&gt;安全概览&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;最安全的是物理隔离：不现实&lt;/li&gt;
&lt;li&gt;网络隔离其次&lt;/li&gt;
&lt;li&gt;防火墙再其次&lt;/li&gt;
&lt;li&gt;用户名密码在最后&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;h4&gt;开启权限验证&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;auth开启
mongodb.conf 设置  auth=true;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keyfile开启&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;MongoDB创建用户&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;创建语法：createUser(2.6之前为addUser)&lt;/li&gt;
&lt;li&gt;
&lt;code&gt;
{
user:&amp;quot;&amp;lt;name&amp;gt;&amp;quot;,
pwd:&amp;quot;&amp;lt;password&amp;gt;&amp;quot;,
sustomData:{&amp;lt;说明&amp;gt;},
roles;[{role:&amp;quot;&amp;lt;role&amp;gt;&amp;quot;,db:&amp;quot;database&amp;quot;}]
}
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;角色类型：内建类型（read,readWrite,dbAdmin,dbOwner,userAdmin）&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;用户角色详解&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin）&lt;/li&gt;
&lt;li&gt;集群角色（cluterAdmin,clusterManager）&lt;/li&gt;
&lt;li&gt;备份角色（backup,restore）&lt;/li&gt;
&lt;li&gt;其他特殊权限（DBAdminAnyDatabase） &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 20 May 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/05/20/monogo-db-study/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/05/20/monogo-db-study/</guid>
        
        <category>Clover</category>
        
        <category>MonogoDB</category>
        
        
      </item>
    
      <item>
        <title>My First Blog</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;宇宙，海洋，黑洞&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;大海&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
echo &amp;#39;hello word!&amp;#39;;
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;宇宙&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;echo &#39;hello black!&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;黑洞&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#cat /etc/issue  
#cat /etc/*-release 
#uname -a
#MemTotal=`free -m | grep Mem | awk &#39;{print  $2}&#39;`
#df -h 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/03/24/my-first-blog/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/03/24/my-first-blog/</guid>
        
        <category>Clover</category>
        
        <category>OS</category>
        
        <category>Blog</category>
        
        
      </item>
    
      <item>
        <title>React vs Angular 2：冰与火之歌「译」</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;这篇文章转载自&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine/20549104&quot;&gt;我在知乎专栏「前端外刊评论」上发表的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt; 已经发布 Beta 版，而且似乎很有信心在 2016 年成为热门框架。是时候进行一场巅峰对决了，我们来看看它如何与 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 这个 2015 年的新宠抗衡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt;我之前很喜欢使用 Angular 1，不过在 2015 年转到了 React。最近我也在 Pluralsight 上发布了一门关于 &lt;a href=&quot;https://www.pluralsight.com/courses/react-flux-building-applications&quot;&gt;React 和 Flux 的课程&lt;/a&gt;（&lt;a href=&quot;http://app.pluralsight.com/signup&quot;&gt;免费试学&lt;/a&gt;）。所以，&lt;strong&gt;是的，我本人是有偏见的，但我不会偏袒任何一方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，我们开始吧，这场对决将会非常血腥。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MRPl_SNuRGJchb6eOAnkSA.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;图片来源：&lt;a href=&quot;https://twitter.com/jwcarroll&quot;&gt;@jwcarrol&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;两者根本不具有可比性！&lt;/h2&gt;

&lt;p&gt;是的是的，Angular 是框架，React 是类库。所以有人觉得比较这两者没有逻辑性可言。大错特错！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;选择 Angular 还是 React 就像选择直接购买成品电脑还是买零件自己组装一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者的优缺点本文都会提及，我会拿 React 语法和组件模型跟 Angular 的语法和组件模型做对比。这就像是拿成品电脑的 CPU 跟零售的 CPU 做对比，没有任何不妥。&lt;/p&gt;

&lt;h2&gt;Angular 2 的优点&lt;/h2&gt;

&lt;p&gt;我们先看 Angular 相对 React 有哪些优势。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;无选择性疲劳&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Angular 是一个完整的框架，本身就提供了比 React 多得多的建议和功能。而要用 React，开发者通常还需要借助别的类库来打造一个真正的应用。比如你可能需要额外的库来处理路由、强制单向数据流、进行 API 调用、做测试以及管理依赖等等。要做的选择和决定太多了，让人很有压力。这也是为什么 React 有那么多的入门套件的原因（我自己就写了两个：&lt;a href=&quot;https://github.com/coryhouse/react-flux-starter-kit&quot;&gt;1&lt;/a&gt;、&lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;Angular 自带了不少主张，所以能够帮助你更快开始，不至于因为要做很多决定而无所适从。这种强制的一致性也能帮助新人更快适应其开发模式，并使得开发者在不同团队间切换更具可行性。&lt;/p&gt;

&lt;p&gt;Angular 核心团队让我非常欣赏的一点是，他们拥抱了 TypeScript，这就造成了另一个优势。&lt;/p&gt;

&lt;h4&gt;TypeScript = 阳关大道&lt;/h4&gt;

&lt;p&gt;没错，并非所有人都喜欢 TypeScript，但是 Angular 2 毅然决然地选择了它确实是个巨大的优势。反观 React，网上的各种示例应用令人沮丧地不一致——ES5 和 ES6 的项目基本上各占一半，而且目前存在&lt;a href=&quot;http://jamesknelson.com/should-i-use-react-createclass-es6-classes-or-stateless-functional-components/&quot;&gt;三种不同的组件声明方式&lt;/a&gt;。这无疑给初学者造成了困惑。（Angular 还拥抱了装饰器（decorator）而不是继承（extends）——很多人认为这也是个加分项）。&lt;/p&gt;

&lt;p&gt;尽管 Angular 2 并不强制使用 TypeScript，但显然的是，Angular 的核心团队默认在文档中使用 TypeScript。这意味着相关的示例应用和开源项目更有可能保持一致性。Angular 已经提供了&lt;a href=&quot;https://angular.io/docs/ts/latest/quickstart.html&quot;&gt;非常清晰的关于如何使用 TypeScript 编译器的例子&lt;/a&gt;。（诚然，目前&lt;a href=&quot;http://angularjs.blogspot.com/2015/09/angular-2-survey-results.html&quot;&gt;并非所有人都在拥抱 TypeScript&lt;/a&gt;，但我有理由相信等到正式发布之后，TypeScript 会成为事实上的标准）。这种一致性应该会帮助初学者避免在学习 React 时遇到的疑惑和选择困难。&lt;/p&gt;

&lt;h4&gt;极少的代码变动&lt;/h4&gt;

&lt;p&gt;2015 年是 &lt;a href=&quot;https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.559iqxb39&quot;&gt;JavaScript 疲劳&lt;/a&gt;元年，React 可以说是罪魁祸首。而且 React 尚未发布 1.0，所以未来还可能有很多变数。React 生态圈依旧在快速地变动着，尤其是&lt;a href=&quot;https://github.com/kriasoft/react-starter-kit/issues/22&quot;&gt;各种 Flux 变种&lt;/a&gt;和&lt;a href=&quot;https://github.com/rackt/react-router&quot;&gt;路由&lt;/a&gt;。也就是说，你今天用 React 写的所有东西，都有可能在 React 1.0 正式发布后过时，或者必须进行大量的改动。&lt;/p&gt;

&lt;p&gt;相反，Angular 2 是一个对已经成熟完整框架（Angular 1）的重新发明，而且经过仔细、系统的设计。所以 Angular 不大可能在正式发布后要求已有项目进行痛苦的代码变动。Angular 作为一个完整的框架，你在选择它的时候，也会信任其开发团队，相信他们会认真决定框架的未来。而使用 React，一切都需要你自己负责，你要自己整合一大堆开源类库来打造一个完整的应用，类库之间互不相干且变动频繁。这是一个令人沮丧的耗时工作，而且永远没有尽头。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;广泛的工具支持&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;后面我会说，我认为 React 的 JSX 是非常耀眼的亮点。然而要使用 JSX，你需要选择支持它的工具。尽管 React 已经足够流行，工具支持不再是什么问题，但诸如 IDE 和 lint 工具等新工具还不大可能很快得到支持。Angular 2 的模版是保存在一个字符串或独立的 HTML 文件中的，所以不要求特殊的工具支持（不过似乎 Angular 字符串模版的智能解析工具已经呼之欲出了）。&lt;/p&gt;

&lt;h4&gt;Web Components 友好&lt;/h4&gt;

&lt;p&gt;Angular 2 还拥抱了 Web Component 标准。唉，真尴尬我居然一开始忘记提到这点了——最近我还发布了一门关于&lt;a href=&quot;https://www.pluralsight.com/courses/web-components-shadow-dom&quot;&gt;Web Components 课程&lt;/a&gt;呢！简单来说，把 Angular 2 组件转换成原生 Web Components 应该会比 React 组件容易得多。固然 Web Components 的&lt;a href=&quot;http://jonrimmer.github.io/are-we-componentized-yet/&quot;&gt;浏览器支持度依然很弱&lt;/a&gt;，但长期来看，对 Web Components 友好是很大的优势。&lt;/p&gt;

&lt;p&gt;Angular 的实现有其自身的局限和陷阱，这正好让我过渡到对 React 优势的讨论。&lt;/p&gt;

&lt;h3&gt;React 的优点&lt;/h3&gt;

&lt;p&gt;现在，让我们看看是什么让 React 如此与众不同。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;JSX&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;JSX 是一种类似 HTML 的语法，但它实际上会被编译成 JavaScript。将标签与代码混写在同一个文件中意味着输入一个组件的函数或者变量时你将享受到自动补全的福利。而 Angular 基于字符串的模版就相形见绌了：很多编辑器都不会高亮它们（只会显示单色）、只有有限的代码补全支持，并且一直到运行时才会报错。并且，通常你也只能得到很有限的错误提示。不过，Angular 的团队&lt;a href=&quot;https://github.com/angular/angular/issues/4417&quot;&gt;造了一个自己的 HTML 解析器来解决这个问题&lt;/a&gt;。（叼叼叼！）&lt;/p&gt;

&lt;p&gt;如果你不喜欢 Angular 的字符串模版，你可以把模版移到一个单独的文件里去。不过这样你就回到了我认为的“老样子”：你需要在自己脑袋里记住这两个文件的关联，不但没有代码自动补全，也没有任何编译时检查来协助你。这听起来可能并不算什么……除非你已经爱上了与 React 相伴的日子。在同一个文件中组合组件还能享受编译时的检查，大概是 JSX 最与众不同的地方之一了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p5.qhimg.com/d/inn/8a99f370/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;对比 Angular 2 与 React 在标签忘记闭合时是如何表现的。&lt;/p&gt;

&lt;p&gt;关于为什么 JSX 是一个巨大的优势，可以看看 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.5007n49wq&quot;&gt;JSX：硬币的另一面（JSX: The Other Side of the Coin）&lt;/a&gt;. （P.S. 这是作者写的另一篇文章，如果大家希望我们可以把这篇也翻了，欢迎在评论区举手）&lt;/p&gt;

&lt;h4&gt;React 报错清晰快速&lt;/h4&gt;

&lt;p&gt;当你在 React 的 JSX 中不小心手抖打错时，它并不会被编译。这是一件非常美妙的事情：无论你是忘记闭合了标签还是引用了一个不存在的属性（property），你都可以立刻知道到底是哪一行出错了。&lt;strong&gt;JSX 编译器会指出你手抖的具体行号&lt;/strong&gt;，彻彻底底加速你的开发。&lt;/p&gt;

&lt;p&gt;相反，当你在 Angular 2 中不小心敲错了一个变量时，鸦雀无声。&lt;strong&gt;Angular 2 并不会在编译时做什么，它会等到运行时才静默报错。&lt;/strong&gt;它报错得&lt;em&gt;如此之慢&lt;/em&gt;，我加载完整个应用然后奇怪为什么我的数据没有显示出来呢？这太不爽了。&lt;/p&gt;

&lt;h4&gt;React 以 JavaScript 为中心&lt;/h4&gt;

&lt;p&gt;终于来了。这才是 React 和 Angular 的根本区别。&lt;strong&gt;很不幸，Angular 2 仍然是以 HTML 而非 JavaScript 为中心的。&lt;/strong&gt;Angular 2 并没有解决它设计上的根本问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Angular 2 继续把 “JS” 放到 HTML 里。React 则把 “HTML” 放到 JS 里。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种分歧带来的影响真是再怎么强调也不为过。它们从根本上影响着开发体验。Angular 以 HTML 为中心的设计留下了巨大的缺陷。正如我在 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.jqh5kkxlk&quot;&gt;JSX：硬币的另一面&lt;/a&gt; 中所说的，JavaScript 远比 HTML 要强大。因此，&lt;strong&gt;增强 JavaScript 让其支持标签要比增强 HTML 让其支持逻辑要合理得多&lt;/strong&gt;。无论如何，HTML 与 JavaScript 都需要某种方式以粘合在一起。React 以 JavaScript 为中心的思路从根本上优于 Angular、Ember、Knockout 这些以 HTML 为中心的思路。&lt;/p&gt;

&lt;p&gt;让我们来看看为什么。&lt;/p&gt;

&lt;h4&gt;React 以 JavaScript 为中心的设计 = 简约&lt;/h4&gt;

&lt;p&gt;Angular 2 延续了 Angular 1 试图让 HTML 更加强大的老路子。所以即使是像循环或者条件判断这样的简单任务你也不得不使用 Angular 2 的独特语法来完成。例如，Angular 2 通过两种语法同时提供了单向数据绑定与双向数据绑定，可不幸的是它们实在差得有点多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;p&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//单向数据绑定&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ngModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;myVar&quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//双向数据绑定&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 React 中，数据绑定语法不取决于数据流的单双向（数据绑定的单双向是在其他地方处理的，不得不说我觉得理应如此）。不管是单向还是双向数据流，绑定语法都是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Angular 2 的内联母版（inline master templates）使用了这样的语法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ngFor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#hero of heroes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    {{hero.name}}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个代码片段遍历了一组 hero，而我比较关心的几点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过星号来声明一个“母版”实在是太晦涩了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hero&lt;/code&gt; 前的英镑符号（&lt;code&gt;#&lt;/code&gt;）用于声明一个局部模版变量。这个概念感觉非常鸡肋（如果你偏好不使用 &lt;code&gt;#&lt;/code&gt;，你也可以使用 &lt;code&gt;var-&lt;/code&gt; 前缀写法）&lt;/li&gt;
&lt;li&gt; 为 HTML 加入了循环语义的HTML 特性（attribute）&lt;code&gt;ngFor&lt;/code&gt; 是 Angular 特有的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相比上面 Angular 2 的语法，React 的语法可是纯净的 JavaScript （不过我得承认下面的属性 &lt;code&gt;key&lt;/code&gt; 是个 React 的私货）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  { heroes.map(hero =&amp;gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{hero.id}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{hero.name}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  )}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鉴于 JS 原生支持循环，React JSX 利用 JS 的力量来做到这类事情简直易如反掌，配合 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt; 能做的还远不止此。&lt;/p&gt;

&lt;p&gt;去看看 &lt;a href=&quot;https://angular.io/docs/ts/latest/guide/cheatsheet.html&quot;&gt;Angular 2 速查表&lt;/a&gt;？那不是 HTML，也不是 JavaScript……这叫 &lt;strong&gt;Angular&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读懂 Angular：&lt;/strong&gt; 学一大堆 Angular 特有的语法&lt;/p&gt;

&lt;p&gt;读懂 React： 学 JavaScript&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 因为语法和概念的简约而与众不同。我们不妨品味下当今流行的 JS 框架/库都是如何实现遍历的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;Ember&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; 
&lt;span class=&quot;nx&quot;&gt;Angular&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ng&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;repeat&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Angular&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ngFor&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Knockout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foreach&quot;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;直接用&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;就好啦&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了 React，所有其它框架都用自己的专有语法重新发明了一个我们在 JavaScript 常见得不能再常见的东西：&lt;strong&gt;循环&lt;/strong&gt;。这大概就是 React 的美妙之处，利用 JavaScript 的力量来处理标签，而不是什么奇怪的新语法。&lt;/p&gt;

&lt;p&gt;Angular 2 中的奇怪语法还有点击事件的绑定：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;onSelect(hero)&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相反，React 再一次使用了普通的 JavaScript：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onSelect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且，鉴于 React 内建了一个模拟的事件机制（Angular 2 也有），你并不需要去担心使用内联语法声明事件处理器所暗含的性能问题。&lt;/p&gt;

&lt;p&gt;为什么要强迫自己满脑子都是一个框架的特殊语法呢？为什么不直接拥抱 JS 的力量？&lt;/p&gt;

&lt;h4&gt;奢华的开发体验&lt;/h4&gt;

&lt;p&gt;JSX 具备的代码自动补全、编译时检查与丰富的错误提示已经创造了非常棒的开发体验，既为我们减少了输入，与节约了时间。而配合上热替换（hot reloading）与时间旅行（time travel），你将获得前所未有的开发体验，效率高到飞起。&lt;/p&gt;

&lt;p&gt;原文这里链了个 Youtube 上的视频：&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&amp;amp;feature=youtu.be&quot;&gt;Dan Abramov - Live React: Hot Reloading with Time Travel at react-europe 2015&lt;/a&gt;，大家自备梯子。&lt;/p&gt;

&lt;h4&gt;担心框架的大小？&lt;/h4&gt;

&lt;p&gt;这里是一些常见框架/库压缩后的大小（&lt;a href=&quot;https://gist.github.com/Restuta/cda69e50a853aa64912d&quot;&gt;来源&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Angular 2:&lt;/strong&gt; 566k (766k with RxJS)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ember:&lt;/strong&gt; 435k&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js&quot;&gt;&lt;strong&gt;Angular 1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 143k&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;React + Redux:&lt;/strong&gt; 139k&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出的都是框架级的、用于浏览器且压缩后的大小（但并未 gzip）。需要补充的是，Angular 2 的尺寸在最终版本发布时应该会有所减小。&lt;/p&gt;

&lt;p&gt;为了做一个更真实的对比，我将 Angular 2 &lt;a href=&quot;https://angular.io/docs/ts/latest/tutorial/&quot;&gt;官方教程&lt;/a&gt;中的 Tour of Heroes 应用用 Angular 2 和 React（还用上了新的 &lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;React Slingshot&lt;/a&gt; 入门套件）都实现了一遍，结果如何呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/angular-2-tour-of-heroes/tree/master&quot;&gt;&lt;strong&gt;Angular 2&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 764k 压缩后&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/react-tour-of-heroes&quot;&gt;&lt;strong&gt;React + Redux&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 151k 压缩后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;strong&gt;做一个差不多的东西，Angular 2 目前的尺寸是 React + Redux 的五倍还多&lt;/strong&gt;。重要的事情再说一遍，Angular 2 的最终版本应该会减重。&lt;/p&gt;

&lt;p&gt;不过，我承认关于框架大小的担忧可能被夸大了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大型应用往往至少有几百 KB 的代码，经常还更多，不管它们是不是使用了框架。开发者需要做很多的抽象来构建一个复杂的软件。无论这些抽象是来自框架的还是自己手写的，它都会对应用的加载性能造成负面影响。  &lt;/p&gt;

&lt;p&gt;就算你完全杜绝框架的使用，许多应用仍然是几百 KB 的 JavaScript 在那。 — Tom Dale &lt;a href=&quot;http://tomdale.net/2015/11/javascript-frameworks-and-mobile-performance/&quot;&gt;JavaScript Frameworks and Mobile Performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom 的观点是对的。像 Angular、Ember 这样的框架之所以更大是因为它们自带了更多的功能。&lt;/p&gt;

&lt;p&gt;但是，我关心的点在于：很多应用其实用不到这种大型框架提供的所有功能。在这个越来越拥抱微服务、微应用、&lt;a href=&quot;http://www.npmjs.com&quot;&gt;单一职责模块（single-responsibility packages）&lt;/a&gt;的时代，&lt;strong&gt;React 通过让你自己挑选必要模块，让你的应用大小真正做到量身定做&lt;/strong&gt;。在这个有着 200,000 个 npm 模块的世界里，这点非常强大。&lt;/p&gt;

&lt;h4&gt;React 信奉&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy&quot;&gt;Unix 哲学&lt;/a&gt;.&lt;/h4&gt;

&lt;p&gt;React 是一个类库。它的哲学与 Angular、Ember 这些大而全的框架恰恰相反。你可以根据场景挑选各种时髦的类库，搭配出你的最佳组合。JavaScript 世界在飞速发展，React 允许你不断用更好的类库去迭代你应用中的每个小部分，而不是傻等着你选择的框架自己升级。&lt;/p&gt;

&lt;p&gt;Unix 久经沙场屹立不倒，原因就是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;小而美、可组合、目的单一，这种哲学永远不会过时。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 作为一个专注、可组合并且目的单一的工具，已经被&lt;a href=&quot;https://github.com/facebook/react/wiki/Sites-Using-React&quot;&gt;全世界的各大网站们&lt;/a&gt;使用，预示着它的前途光明（当然，Angular 也被用于&lt;a href=&quot;https://www.madewithangular.com/#/&quot;&gt;许多大牌网站&lt;/a&gt;）。&lt;/p&gt;

&lt;h4&gt;谢幕之战&lt;/h4&gt;

&lt;p&gt;Angular 2 相比第一代有着长足的进步。新的组件模型比第一代的指令（directives）易学许多；新增了对于同构／服务器端渲染的支持；使用虚拟 DOM 提供了 3-10 倍的性能提升。这些改进使得 Angular 2 与 React 旗鼓相当。不可否认，它功能齐全、观点鲜明，能够显著减少 “JavaScript 疲劳” 。&lt;/p&gt;

&lt;p&gt;不过，Angular 2 的大小和语法都让我望而却步。Angular 致力的 HTML 中心设计比 React 的 JavaScript 中心模型要复杂太多。在 React 中，你并不需要学习 &lt;code&gt;ng-什么什么&lt;/code&gt; 这种框架特有的 HTML 补丁（shim），你只要写 JavaScript 就好了。这才是我相信的未来。&lt;/p&gt;

&lt;h3&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51#.v4y4euy1r&quot;&gt;Angular 2 versus React: There Will Be Blood&lt;/a&gt;，其实&lt;a href=&quot;http://www.w3ctech.com/topic/1675?from=timeline&amp;amp;isappinstalled=0&quot;&gt;之前有人翻译过&lt;/a&gt;，但是翻得水平有一点不忍直视，我们不希望浪费这篇好文章。&lt;br&gt;
本文由 &lt;a href=&quot;https://www.zhihu.com/people/li-ling-hao&quot;&gt;@李凌豪&lt;/a&gt; &lt;a href=&quot;https://www.zhihu.com/people/huxpro&quot;&gt;@黄玄&lt;/a&gt; 联合翻译，首次发布于&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine&quot;&gt;前端外刊评论 · 知乎专栏&lt;/a&gt;，转载请保留原文链接 ;)&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2016/02/01/React-vs-Angular2/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2016/02/01/React-vs-Angular2/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>都 2015 年了，CSS 怎么还是这么糟糕</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;a href=&quot;http://huangxuan.me/css-sucks-2015&quot;&gt;Watch Slides →&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://huangxuan.me/css-sucks-2015/attach/qrcode.png&quot; width=&quot;350&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;small class=&quot;img-hint&quot;&gt;你也可以通过扫描二维码在手机上观看&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;这个 Web Slides 开源在&lt;a href=&quot;https://github.com/Huxpro/css-sucks-2015&quot;&gt;我的 Github 上&lt;/a&gt;，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp;amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目&lt;/p&gt;

&lt;h3&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Document Times

&lt;ul&gt;
&lt;li&gt;Frameworks&lt;/li&gt;
&lt;li&gt;Style Guide

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OOCSS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SMACSS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pre-processer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PostCSS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Application Times

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shadow DOM&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS &amp;quot;4&amp;quot;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Naming Convention

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BEM&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SUIT&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS in JS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS Modules&lt;/strong&gt;&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;Interoperable CSS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PostCSS, again&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;My Opinionated Proposal

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;POCss&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;POCss: Page Override Components CSS&lt;/h2&gt;

&lt;h3&gt;1. Scoping Components &lt;br&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;CSS Blocks should only be used inside a component of the same name.&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scss&quot; data-lang=&quot;scss&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.scss
&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--mofierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;__decendentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--modifierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.isStateOfComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;./index.scss&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS is &lt;em&gt;always bundled&lt;/em&gt; with components&lt;br&gt;(from loading, mount to unmount)&lt;/p&gt;

&lt;h3&gt;2. Components can be Overrode by Pages &lt;br&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;There is always requirements to rewrite styles of components in pages&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scss&quot; data-lang=&quot;scss&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/PageA.scss
&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;#PageA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.pagelet-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;.pagelet-descendent-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* override */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;./PageA.scss&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;#Page&lt;/em&gt; for absolutely scoping between pages&lt;/li&gt;
&lt;li&gt;&lt;em&gt;.pagelet-name&lt;/em&gt; should be lowercase to prevent conflicting with components&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Why POC?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;It&amp;#39;s technology-agnostic&lt;/strong&gt;
&lt;small&gt;
&lt;em&gt;One css framework can be played with whatever technology stacks&lt;/em&gt;&lt;br&gt;
&lt;em&gt;You can combined Scss, PostCSS and whatever you want&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Solving problems, and easy&lt;/strong&gt;
&lt;small&gt;
&lt;em&gt;Makes reading and teamwork much easier&lt;/em&gt;&lt;br&gt;
&lt;em&gt;Get all benefit from BEM, SUITCSS and others&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Leverage the power of cascading properly&lt;/strong&gt;
&lt;small&gt;
&lt;em&gt;Scoping components but allow reasonable overriding&lt;/em&gt;&lt;br&gt;
&lt;em&gt;It&amp;#39;s pragmatic, flexible and hitting the sweet spot&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;Reveal.js&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/12/28/css-sucks-2015/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/12/28/css-sucks-2015/</guid>
        
        <category>前端开发</category>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>iOS 9，为前端世界都带来了些什么？「译」</title>
        <description>&lt;p&gt;2015 年 9 月，Apple 重磅发布了全新的 iPhone 6s/6s Plus、iPad Pro 与全新的操作系统 watchOS 2 与 tvOS 9（是的，这货居然是第 9 版），加上已经发布的 iOS 9，它们都为前端世界带来了哪些变化呢？作为一个 web 开发者，是时候站在我们的角度来说一说了！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注！&lt;/strong&gt; 该译文存在大量英文术语，笔者将默认读者知晓 ES6、viewport、native app、webview 等常用前端术语，并不对这些已知术语进行汉语翻译
对于新发布或较新的产品名称与技术术语，诸如 Apple Pen、Split View 等专有名词，笔者将在文中使用其英文名，但会尝试对部分名词进行汉语标注
另外，出于对 wiki 式阅读的偏爱，笔者为您添加了很多额外的链接，方便您查阅文档或出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;简而言之&lt;/h3&gt;

&lt;p&gt;如果你不想阅读整篇文章，这里为你准备了一个总结：&lt;/p&gt;

&lt;h6&gt;新的设备特性&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;iPhone 6s 与 6s Plus 拥有 &lt;strong&gt;“&lt;a href=&quot;http://www.apple.com/iphone-6s/3d-touch/&quot;&gt;3D Touch&lt;/a&gt;”&lt;/strong&gt;，这是一个全新的硬件特性，它可以侦测压力，是一个可以让你拿到手指压力数据的 API&lt;/li&gt;
&lt;li&gt;iPad Pro 的 viewport 为 1024px，与以往的 iPad 全都不同&lt;/li&gt;
&lt;li&gt;想在 iPad Pro 上支持新的 Apple Pen？不好意思，目前似乎并没有适用于网站的 API &lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;新的操作系统特性（与 web 相关的）&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;iPad 上的 Safari 现在可以通过 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForSlideOverAndSplitView.html#//apple_ref/doc/uid/TP40015145-CH13-SW1&quot;&gt;Split View&lt;/a&gt;（分屏视图）与其他应用一起使用，这意味着新的 viewport 尺寸将会越来越常见&lt;/li&gt;
&lt;li&gt;新的 Safari View Controller（&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/SafariServices/Reference/SFSafariViewController_Ref/index.html#//apple_ref/occ/cl/SFSafariViewController&quot;&gt;&lt;code&gt;SFSafariViewController&lt;/code&gt;&lt;/a&gt;）可以让你在 native app 内提供与 Safari 界面、行为连贯一致的应用内网页浏览体验&lt;/li&gt;
&lt;li&gt;注意啦！Safari 新加入了 Content Blocker（内容拦截器）。以后，并不是所有的访问都一定会出现在你的 Google Analytics 了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12&quot;&gt;Universal Links&lt;/a&gt; 可以让应用的拥有者在 iOS 内部“占有”自己的域名。因此，访问 yourdomain.com 将会打开你的应用（类似 Android 的 Intents 机制）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308&quot;&gt;App Search（应用搜索）&lt;/a&gt;：现在，Apple 将会抓取你的网页内容（与 native app 内容）用于 Spotlight 与 Siri 的搜索结果，&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8&quot;&gt;想知道你的标签都兼容吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;你的网站现在可以通过 JavaScript API 访问 iCloud 的用户数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;新的 API 支持&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing&quot;&gt;Performance Timing API&lt;/a&gt; 在 iOS 9 得到回归&lt;/li&gt;
&lt;li&gt;关于 HTML5 Video，你现在可以在支持 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForPictureInPicture.html#//apple_ref/doc/uid/TP40015145-CH14&quot;&gt;Picture in Picture（画中画）&lt;/a&gt;的 iPad 设备上提供这项新功能；你的视频甚至可以在 Safari 关闭后继续播放&lt;/li&gt;
&lt;li&gt;更好的 ES6 支持：classes（类）, computed properties（可计算属性）, template literals（模版字符串）等&lt;/li&gt;
&lt;li&gt;Backdrop CSS filters（背景滤镜）&lt;/li&gt;
&lt;li&gt;CSS @supports 与 CSS Supports JavaScript API &lt;/li&gt;
&lt;li&gt;CSS Level4 伪选择器&lt;/li&gt;
&lt;li&gt;用于支持分页内容的 CSS Scroll Snapping&lt;/li&gt;
&lt;li&gt;WKWebView 现在可以访问本地文件了&lt;/li&gt;
&lt;li&gt;我们仍然需要等待 Push Notification，camera access，Service Workers 这些现代 web API 的到来&lt;/li&gt;
&lt;/ul&gt;

&lt;h6&gt;新的操作系统&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;新一代 Apple TV 的 &lt;strong&gt;tvOS&lt;/strong&gt;： 没有浏览器，也没有 webview。但是 JavaScript、XHR 和 DOM 可以通过一个叫做 TVML 的标记语言来使用&lt;/li&gt;
&lt;li&gt;Apple Watch 的 &lt;strong&gt;watchOS&lt;/strong&gt;：完全没有任何浏览器和 webview&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;再注！&lt;/strong&gt; 由于原文写于 Apple 发布会之前，为了不让读者感到奇怪，笔者将会对文章进行适当改写与补充，以保证本文的连贯性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;新的 iOS 设备特性&lt;/h3&gt;

&lt;h5&gt;iPhones 6s 与 3D Touch&lt;/h5&gt;

&lt;p&gt;从 web 设计与开发的角度来说，新的 iPhone 6s 与 6s Plus 与之前的版本并没有太多差别。不过，有一个特性注定会吸引我们的目光：&lt;strong&gt;3D Touch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们无法确定 Apple 是不是只是重命名了一下 “Force Touch”（用于 Apple Watch、TrackPad 2 与最新的 MacBook 上）或者 3D Touch 的确是一个为 iPhone 定制的似曾相识却不同的东西。3D Touch 允许操作系统和应用侦测每一个手指与屏幕接触时的压力。从用户体验的角度来说，最大的变化莫过于当你用点力去触碰或者拖拽屏幕时，操作系统将会触发诸如 peek，pop 这些新机制。那么问题来了：&lt;strong&gt;我们是否能够在网站中使用这个新玩意呢？让我们一点点来看：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iOS 9 搭载的 Safari 包含了一些用于 “Force Touch” 的新 API，但它们其实并不是那个用于 iPhone 6s 3D Touch 的 API。你可以理解为这些 API 就是 MacBook 版 Safari 里为 Force Touch 准备的那些 API ，因为共享一套 codebase，所以它理所当然得存在了 iOS 版里而已。&lt;/p&gt;

&lt;p&gt;Force Touch API 为我们添加了两个新东西：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你的 click 事件处理函数将会从 MouseEvent 中收到一个新的属性：&lt;code&gt;webkitForce&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DOM 也新增了四个事件：&lt;code&gt;(webkit)mouseforcewillbegin&lt;/code&gt;，&lt;code&gt;mouseforcedown&lt;/code&gt;，&lt;code&gt;mouseforceup&lt;/code&gt; 与 &lt;code&gt;mouseforcechange&lt;/code&gt;。下边的示意图将告诉你这些事件是在何时被触发的：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/foceevents.png&quot; alt=&quot;Force Events&quot;&gt;&lt;/p&gt;

&lt;p&gt;相信你已经从它们的名字中意识到了，这些事件都是基于鼠标而非触摸的，毕竟它们是为 MacBook 设计的。并且，TouchEvent 也并没有包含 &lt;code&gt;webkitForce&lt;/code&gt; 这个属性，它仅仅存在于 MouseEvent 里。在 iOS Safari 里，你确实可以找到 &lt;code&gt;onwebkitmouseforce&lt;/code&gt; 这一系列事件处理器，但是很可惜它们并不会被触发，click 返回的 MouseEvent 也永远只能得到一个 &lt;code&gt;webkitForce: 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可喜可贺的是，故事还没有结束。&lt;a href=&quot;https://w3c.github.io/touch-events/&quot;&gt;Touch Events v2 draft spec（触摸事件第二版草案）&lt;/a&gt; 中正式添加了 &lt;code&gt;force&lt;/code&gt; 属性。3D Touch 也得以在 iPhone 6s 与 6s+ 中通过 TouchEvent 访问到。不过，笔者也要在这里提醒大家，由于没有 &lt;code&gt;webkitmouseforcechange&lt;/code&gt; 这样给力的事件，在手机上我们只能通过 &lt;strong&gt;轮询 TouchEvent 的做法&lt;/strong&gt; 来不断检测压力值的改变……非常坑爹&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/fr3ino&quot;&gt;@Marcel Freinbichler&lt;/a&gt; 第一个在 Twitter 上晒出了自己的 &lt;a href=&quot;http://freinbichler.me/apps/3dtouch&quot;&gt;Demo&lt;/a&gt;。在 6s 或 new Macbook 的 Safari（目前仅 Safari 支持）上访问就可以看到圆圈会随着压力放大。墙内的小伙伴可以直接试试下面这个圆圈，体验下 3D/Force Touch 带来的的奇妙体验。&lt;/p&gt;

&lt;iframe src=&quot;http://huangxuan.me/forcify/&quot; style=&quot;
    width:100%;
    height:500px;
    border: 0;
&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;如果你不巧在用不支持 3D/Force Touch 的设备，发现尼玛用力按下去之后居然圆圈也有反映！？&lt;/p&gt;

&lt;p&gt;放心，这真的不是你的设备突然习得了“感应压力”这项技能，而是因为 &lt;a href=&quot;http://huangxuan.me/forcify&quot;&gt;Forcify&lt;/a&gt; 是一个用于在所有设备上 polyfill 3D/Force Touch API 的 JS 库……它不但封装了 OSX/iOS 两个平台之间 API 的差异，还使用&amp;quot;长按&amp;quot;来模拟了 &lt;code&gt;force&lt;/code&gt; 值的变化……&lt;/p&gt;

&lt;h5&gt;iPad Pro&lt;/h5&gt;

&lt;p&gt;全新的 iPad Pro（12.9 寸）打破了以往 iPad 渲染网站的方式。在此之前，市面上所有的 iPad（从初代 iPad，到 iPad Air 4，到 iPad Mini）都是以 768px 的宽度提供 viewport。&lt;/p&gt;

&lt;p&gt;而屏幕更大的 iPad Pro 选择了宽 1024px 的 viewport，这使得它天生就能容纳更多的内容。不少人说iPad Pro 就是抄 Microsft Surface Pro 的嘛……嗯哼，IE/Edge 在 Surface Pro 上就是以 1024px 作为视口宽度的……&lt;/p&gt;

&lt;p&gt;从交互的角度上来说，iPad Pro 虽然不支持 3D Touch，但是可以搭配 Smart Keyboard 与/或 Apple Pen（带有压力侦测）使用。对于键盘其实并没有什么好说的，如果一个网站在搭配键盘的桌面电脑上好用，它在 iPad Pro 上应该也不赖。而对于 Apple Pen，很可惜，目前似乎并没有 API 能让你在网站上获得这根笔的压力与角度。&lt;/p&gt;

&lt;h3&gt;新的 iOS 操作系统特性&lt;/h3&gt;

&lt;h5&gt;iPad 上的多任务处理&lt;/h5&gt;

&lt;p&gt;自 iOS 9 起，iPad 允许两个应用在同一时刻并肩执行，有三种方式：&lt;strong&gt;Slide Over&lt;/strong&gt;，&lt;strong&gt;Split View&lt;/strong&gt; 与 &lt;strong&gt;Picture-in-Picture&lt;/strong&gt;。不过，每一种方式都有其硬件需求，比如说 Slide Over 需要 iPad Air, iPad Mini 2 以上的设备，而 Split View 由于对内存的要求目前只支持 iPad Air 2 与 iPad Pro。&lt;/p&gt;

&lt;h6&gt;Slide Over（滑过来！）&lt;/h6&gt;

&lt;p&gt;Slide Over 支持的 App 并不多，不过 Safari 名列其中，这意味着我们的网站将可能在这个模式下被渲染。当网站处于 Slide Over 模式下时，它将在屏幕的右 1/4 位置渲染，并且置于其他 native app 之上。&lt;/p&gt;

&lt;p&gt;这个模式也为 Responsive Web Design（响应式网站设计）提出了新的挑战：&lt;strong&gt;一个只为 iPad 优化的网站，也需要能在该设备上以无需手动刷新的形式支持小屏幕的渲染。&lt;/strong&gt;因此，如果你正在使用服务器端探测（RESS），那么你的 iPad 版本需要以某种方式包含手机版本的网站，或者在进入该模式后重新加载一次。（如果你不了解 RESS，你可以观看我的&lt;a href=&quot;/2014/11/20/responsive-web-design/&quot;&gt;另一篇博文&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/slideover.png&quot; alt=&quot;Slide Over&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这个模式下，无论横屏还是竖屏，所有的 iPad（包括 Pro）都会把你的网站以 320px 的 viewport 宽度进行渲染，就好像在一个大 iPhone 5 上一样。你可以在 CSS 中通过 media query（媒体查询）探测到这个模式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;/* iPad Air or iPad Mini */
(device-width: 768px) and (width: 320px)
/* iPad Pro */
(device-width: 1024px) and (width: 320px)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;Split View（分屏视图）&lt;/h6&gt;

&lt;p&gt;在较新版本的 iPad 上，你可以将 Slide Over 的 Side View（侧视图）升级为 Split View。此时，两个应用将以相同比例在你的屏幕上同时工作。&lt;/p&gt;

&lt;p&gt;在这个模式下，我们的网站将可能……&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以屏幕 1/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 犹如 iPhone 5，宽 320px。而在 iPad Pro 上则像是 iPhone 6：宽 375px&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以屏幕 1/2 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 507px 宽，而在 iPad Pro（横屏）下呈现为 678px 宽&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以屏幕 2/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 694px 宽，而在 iPad Pro（横屏）下呈现为 981px 宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/splitview.png&quot; alt=&quot;Split View&quot;&gt;&lt;/p&gt;

&lt;h6&gt;Picture in Picture（画中画）&lt;/h6&gt;

&lt;p&gt;在一些较新版本的 iPad 上，使用 HTML5 video 标签的网站可以将其暴露到 Picture in Picture 机制中。通过 API（本文稍后会讲）或用户的触发，视频可以独立于网站在其他应用的上方继续播放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/pip.png&quot; alt=&quot;Picture in Picture&quot;&gt;&lt;/p&gt;

&lt;h5&gt;iOS 9 下的响应式网页设计&lt;/h5&gt;

&lt;p&gt;下图向你展示了 iOS 9 所有可能的 viewport 尺寸，检查检查你的响应式断点都包含它们了吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/ios9rwd.png&quot; alt=&quot;iOS 9 RWD&quot;&gt;&lt;/p&gt;

&lt;h5&gt;Safari View Controller&lt;/h5&gt;

&lt;p&gt;如果你用过 Twitter 或者 Facebook（或者微信，微博……），那么你一定知道很多 native app 在打开一个网页链接时并不会默认使用 Safari。它们试图让你留在它们的应用里，所以通过提供 webview 让你在应用内进行网页浏览。可是问题在于，这类 webview 并不会与浏览器共享 cookies，sessions，autofill（自动填充）与 bookmark（书签），为了解决这些问题，就有了 Safari View Controller。&lt;/p&gt;

&lt;p&gt;现在，native app 可以使用 Safari View Controller 来打开网站，它提供与 Safari 完全一致的隐私政策、local storage，cookies、sessions 同时让用户留在你的 app 中，它通过一个 “Done”（完成）按钮使用户可以回到 native app 的上一个 controller。这个全新的 controller 还可以让我们在 Share（分享）按钮上添加自定义的操作，这些操作在用户使用 Safari 应用时并不会出现。同时，native app 对这个自定义 Safari 实例具有完全的内容控制，你可以屏蔽不想被渲染的内容。&lt;/p&gt;

&lt;p&gt;当你需要基于 web 的鉴权，比如 OAuth 时，使用 Safari View Controller 同样是一个好主意，这样就不再需要打开浏览器再重定向回你的应用。不过注意了，Safari View Controller 只适用于在线、公开的 web 内容。如果你的 web 内容假设在本地或者私服，那么 WKWebView 仍然是最推荐的选择。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;笔者八卦一下，Safari View Controller 实际上也算是半个社区推进的产物。早在 2014 年 12 月，Tumblr 的 iOS 工程师 Bryan 就发表了一篇著名的 &lt;a href=&quot;http://bryan.io/post/104845880796/we-need-a-safari-view-controller&quot;&gt;We need a “Safari view controller”&lt;/a&gt; 叙述现有 webview 在第三方登录鉴权时的窘境。
2015 年 6 月，Apple Safari 工程师 Ricky Mondello 的 Twitter 宣告了这个设想的落地：You all asked for it. Come see me introduce it. Introducing Safari View Controller 1:30 PM, Tuesday. Nob Hill.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;Safari Content Blockers&lt;/h5&gt;

&lt;p&gt;现在，iOS 9 上的 Safari 支持一种全新的 App Extensions（应用拓展）：&lt;strong&gt;Content Blocker&lt;/strong&gt;（内容拦截器）。这类拓展以 native app 的形式存在，你可以在 App Store 上下载到，它们可以拦截 Safari 内的任何内容，包括：跟踪器、广告、自定义字体、大图片、JavaScript 文件等等。&lt;/p&gt;

&lt;p&gt;作为 web 开发者，尽管我们不能禁用 Content Blocker，我们仍然应该注意到它们的存在。诸如 Crystal 的一些拦截器宣称他们&lt;a href=&quot;http://murphyapps.co/blog/2015/8/22/crystal-benchmarks&quot;&gt;可以提高网页的打开速度&lt;/a&gt;。Crystal 声称可以加快网页的加载速度 3.9 倍并且少用 53% 的带宽。不过问题是：到底哪些东西被拦截器拦截了？&lt;a href=&quot;http://thenextweb.com/apple/2015/08/27/content-blocking-in-ios-9-is-going-to-screw-up-way-more-than-just-ads/&quot;&gt;这篇文章&lt;/a&gt;提到了一些我们未来可能会遇到的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/crystal.png&quot; alt=&quot;crystal&quot;&gt;&lt;/p&gt;

&lt;p&gt;在 iOS 9 发布后，Peace，一个 Content Blocker，曾在 App Store 排名跻身前十。从用户的角度来说，如果一个网站由于被 Content Blocker 拦截了某些重要资源而不能正常工作，你可以长按重新加载按钮并且以不启用 Content Blocker 的方式重新加载这个网站（见下图，来自 MacWorld.com）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/macworld.png&quot; alt=&quot;disable content blocker&quot;&gt;&lt;/p&gt;

&lt;p&gt;Content Blocker 能隐藏元素，也有能力通过 CSS 选择器、域名、类型、或者 URL 来过滤并拦截某个文件的加载，&lt;a href=&quot;https://itunes.apple.com/us/app/purify-blocker-fast-clutter/id1030156203?ls=1&amp;amp;mt=8&quot;&gt;Purify Blocker&lt;/a&gt; 给用户提供了拦截某一种内容类型的进阶选项，比如 Web Fonts。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/purify.png&quot; alt=&quot;purify&quot;&gt;&lt;/p&gt;

&lt;h5&gt;WKWebView 的增强&lt;/h5&gt;

&lt;p&gt;UIWebView 已经被官方弃用，虽然它还在在那，不过它再也不会得到什么升级。与此相反，WKWebView 正在取代它的位置。一个最受期待的特性现在终于推出：加载本地文件到 WKWebView。因此，现在 Apache Cordova 应用与其他 web 内容都可以直接从 iOS 包中使用本地文件了，不再需要各种诡异的 hack 了。&lt;/p&gt;

&lt;p&gt;此外，还有一些新特性也一并推出。比如说，通过 WKWebsiteDataStore，Objective-C 或 Swift 有能力查询与管理 webview 的本地存储（比如 localStorage 或 IndexedDB）。这就允许我们将原有的数据存储替换成新的某些东西，比如说替换成一个不永久的（Chrome for iOS 的隐身模式就需要这种东西）&lt;/p&gt;

&lt;h5&gt;Universal Links（通用链接）&lt;/h5&gt;

&lt;p&gt;如果你既有一个网站，又有一个 native app，你现在可以通过 Universal Links 来增强用户体验。它允许你在操作系统内“占有”自己的域名，这样，一切指向你网站的链接都会被重定向到你的 app。&lt;/p&gt;

&lt;p&gt;目前，所有的 app 都是通过自定义 URI 来达到这个效果的，比如 &lt;code&gt;comgooglemaps://&lt;/code&gt; 就可以用来从网站或者其他原生 iOS 应用中打开 Google Maps。&lt;/p&gt;

&lt;p&gt;想要提供这个特性的话，你首先需要在 native app 中实现 Deep Linking（深度链接），让应用中的内容与 Safari 的 URL 吻合。然后，你需要在 Apple 的网站上关联你的域名，取得这个域名的 SSL 认证并且把签名后的 JSON 部署到该域名上。这是为了防止第三方的应用“占据”了属于你而不属于他们的域名，比如说 twitter.com 被非 Twitter 的其他应用占据掉。&lt;/p&gt;

&lt;p&gt;目前唯一的缺点是用户好像并不能决定到底以哪种方式来打开内容（使用 web 还是 app），不过我们可以观望一段时间看看它会如何发展。在不远的这段时间里，你可能会发现在网站或 Google 搜索里点击一个链接时会没有任何预警的就跳进了 native app 里。&lt;/p&gt;

&lt;h5&gt;App Search（应用搜索）&lt;/h5&gt;

&lt;p&gt;Apple 带着自己的 web 蜘蛛杀进了搜索的市场，而我们需要支持它得以在 Siri 与 Spotlight 中提升自己的曝光率。这在我们同时拥有网站与 app 时尤为重要，因为现在 Apple 会索引你网站的内容，但打开时却可能将用户带到了 app 里去。&lt;/p&gt;

&lt;p&gt;尽管这会开启 SEO 的新篇章，不过却相当容易。你需要使用一些标签标准，诸如 &lt;a href=&quot;http://schema.org/&quot;&gt;Web Schema&lt;/a&gt;、&lt;a href=&quot;http://applinks.org&quot;&gt;AppLinks&lt;/a&gt;、&lt;a href=&quot;http://ogp.me&quot;&gt;OpenGraph&lt;/a&gt; 或者 &lt;a href=&quot;https://dev.twitter.com/cards/mobile&quot;&gt;Twitter Cards&lt;/a&gt;，配合上 App Banner 与 &lt;code&gt;app-argument&lt;/code&gt;，如果你有你自己的 native app 的话。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;关于“让你的网页支持 Apple 搜索”的更多详情，请查阅 Apple 官方文档 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8-SW5&quot;&gt;Mark Up Web Content&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 刚刚发布了一个 &lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot;&gt;App Search Validation Tool（应用搜索验证工具）&lt;/a&gt;来帮助你搞清楚，需要向你的网站添加什么才能支持 App Search&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/appsearch-1024x467.png&quot; alt=&quot;App Search&quot;&gt;&lt;/p&gt;

&lt;h5&gt;CloudKit JS&lt;/h5&gt;

&lt;p&gt;如果你拥有一个 native app，你很可能会将用户数据保存在 iCloud 上。在过去，只有 iOS 与 Mac 应用被允许使用它。现在，通过 CloudKit JS，你的网站也可以连接上 iCloud 数据了。&lt;/p&gt;

&lt;h5&gt;Back Button&lt;/h5&gt;

&lt;p&gt;现在，当你链接到一个 native app 时（通过自定义 URI 或者 Universal Link），Safari 会询问用户是否想要使用 native app 打开这个链接（见下图）。如果用户同意了，这个应用将被打开，并且在左上角会有一个返回按钮可以返回 Safari ，返回到你的网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/back.png&quot; alt=&quot;backbutton&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;新的 API 支持&lt;/h3&gt;

&lt;h5&gt;Navigation Timing API&lt;/h5&gt;

&lt;p&gt;Navigation Timing API 在 iOS 9 迎来了回归。让我们回忆一下，这货添加于 8.0 却在一周后的 8.1 中去掉了。这对于 Web 性能是个好消息。通过这个 API，我们可以更精确的测量时间，还可以获得一系列有关加载过程的时间戳，它们对于追踪与在真实场景中做决策来改进用户体验都非常有用。&lt;/p&gt;

&lt;h5&gt;Picture in Picture&lt;/h5&gt;

&lt;p&gt;PiP API（被称为 Presentation Mode API）目前只支持 iOS，它允许我们手动让一个 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素进入或离开 PiP 模式如果 &lt;code&gt;video.webkitSupportsPresentationMode&lt;/code&gt; 是支持的。&lt;/p&gt;

&lt;p&gt;举个例子，我们可以在内嵌模式与 PiP 模式中切换：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;video.webkitSetPresentationMode(
    video.webkitPresentationMode === &quot;picture-in-picture&quot; ?
    &quot;inline&quot; : 
    &quot;picture-in-picture&quot;
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还可以通过新的 &lt;code&gt;onwebkitpresentationmodechanged&lt;/code&gt; 事件来检测 Presentation Mode（展示模式）的变化。&lt;/p&gt;

&lt;h5&gt;Backdrop CSS&lt;/h5&gt;

&lt;p&gt;iOS 7 与最近的 Mac OS 使用 Backdrop filter（背景滤镜）来模糊背景（指 native 开发），而在网站上实现这个却并不容易。&lt;/p&gt;

&lt;p&gt;iOS 9 上的 Safari 现在支持了来自 Filter Effect v2 spec（滤镜特效第二版规范）的 &lt;strong&gt;backdrop-filter&lt;/strong&gt;。比如说，我们可以使用一个半透明的背景并且对其背后的背景使用滤镜：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;header {
   background-color: rgba(255, 255, 255, 0.4);
   -webkit-backdrop-filter: blur(5px);
   backdrop-filter: blur(5px);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/backdrop.png&quot; alt=&quot;backdrop&quot;&gt;&lt;/p&gt;

&lt;h5&gt;CSS Scroll Snapping&lt;/h5&gt;

&lt;p&gt;在 web 上实现分页内容（比如相册跑马灯）总是非常麻烦，无论是使用 JavaScript 框架、touch 事件还是 hacking 滚动条等等。Apple 新添加了一个很赞的 CSS 特性叫做 CSS Scroll Snapping。这个特性新增了一系列的 CSS 属性让你定义规则或者不规则的 snap zone（停留区域），这样滚动的位置就会“啪”地一下停在这个区域，而非像以前一样可以停在任何地方。  &lt;/p&gt;

&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#photo-gallery{
    width: 100%;
    overflow-x: scroll;
    -webkit-scroll-snap-points-x: repeat(100%);
    -webkit-scroll-snap-type: mandatory;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;想要看个跑起来后的例子？笔者为大家准备了 webkit 的官方 &lt;a href=&quot;http://www.webkit.org/demos/scroll-snap/&quot;&gt;demo&lt;/a&gt;，不过这个属性目前只支持 iOS 9 Safari 哦，并不支持 webview&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;CSS Supports&lt;/h5&gt;

&lt;p&gt;CSS Supports，包括 CSS &lt;code&gt;@supports&lt;/code&gt; 与来自 CSS Conditional Rules Module Level 3 spec 的 JavaScript CSS Supports API 都在 iOS 上迎来降临。现在，我们可以针对某个 CSS 属性的特定值的支持情况来编写代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;@supports(-webkit-scroll-snap-type: mandatory) {
    /* we use it */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，使用 JavaScript：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;if (CSS.supports(&quot;-webkit-scroll-snap-type&quot;, &quot;mandatory&quot;)) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;一些细微的改进&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ECMAScript 6 的更完善支持：classed、computed properties、template literial 与 week sets&lt;/li&gt;
&lt;li&gt;新的 CSS Level4 伪类/元素选择器：&lt;code&gt;:not&lt;/code&gt;、&lt;code&gt;:matches&lt;/code&gt;、&lt;code&gt;:any-link&lt;/code&gt;、&lt;code&gt;:placeholder-shown&lt;/code&gt;、&lt;code&gt;:read-write&lt;/code&gt;、&lt;code&gt;:read-only&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Native app 现在可以通过 extension 来向 Safari 的 Shared Links（分享链接）窗口上注入信息&lt;/li&gt;
&lt;li&gt;大量无前缀 CSS 属性的支持（终于），比如 transition、animation、@keyframes、flex 与 columns&lt;/li&gt;
&lt;li&gt;Mac OS El Capitán 上的 Safari 9 提供了一个全新设计的 Web Inspector（Web 检查器）。幸运的是，iOS 9 的远程调试完全兼容 Mac OS 上的 Safari 8，所以你倒是不用急着升级你的 Mac OS&lt;/li&gt;
&lt;li&gt;iOS 9 通过 &lt;code&gt;-apple-font&lt;/code&gt; 加入了一些 Dynamic Fonts（动态字体），并且它们现在应用的是 Apple 的新字体：San Francisco，笔者的博客就已经用上它啦&lt;/li&gt;
&lt;li&gt;scrollingElement 现在可用了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input type=file&amp;gt;&lt;/code&gt; 现在允许你从 iCloud Drive 与已安装的第三方应用，比如 Google Drive 中选择文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/IMG_2017.png&quot; alt=&quot;input file&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你加载一个 HTTPS 协议的页面时，你不能混用 HTTP 与 HTTPS 的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Bugs&lt;/h3&gt;

&lt;p&gt;Bug 通常都要在几周之后才会显露出来，我也会持续跟进并更新这篇文章。目前为止，我的发现如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于 Home Screen webapps（添加至主屏的 web 应用），&lt;code&gt;apple-mobile-web-app-status-bar-style&lt;/code&gt; 这个 meta 标签不起作用了！所以你现在不能再像过去一样使用 &lt;code&gt;black-translucent&lt;/code&gt; 让你的 webapp 渲染在状态栏的后面了。（iOS 9.2 fixed 了这个 bug）&lt;/li&gt;
&lt;li&gt;Speech Synthesis API （语音综合 API）不再工作了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;仍在等待……&lt;/h3&gt;

&lt;p&gt;当 Mac 上的 Safari、桌面电脑与 Android 上的 Chrome 都已经为网站支持 Push Notification （通知推送）时，iOS 上的 Safari 仍然不支持这个特性。就 API 而言，我们仍然没有：WebRTC、getUserMedia、Service Worker、FileSystem API、Network Information API、Battery Status API、Vibration API 等等……你又在 iOS 上等待哪些特性呢？ &lt;/p&gt;

&lt;h3&gt;watchOS 与 tvOS&lt;/h3&gt;

&lt;p&gt;新发布的 watchOS 2.0 与 tvOS 9.0 都是基于 iOS 的操作系统，它们针对特定的设备发行（Apple Watch 与新的 Apple TV）。从用户的角度来说，那里并没有浏览器了。从开发者的角度，那里也没有 Webview 了。&lt;/p&gt;

&lt;p&gt;尽管有不少人抱怨（大部分都是针对 webview 的缺失），我并不能确定这是不是个坏主意。我猜测 Apple 会尝试通过 Siri 来将 “web” 带给 TV、手表、甚至 CarPlay 的用户。所以，如果你遵循了上述的 “App Search” 的步骤，你的内容将可能通过 Siri 在这些设备上以 widget（小部件）或者快捷回复的形式变得可以访问。&lt;/p&gt;

&lt;p&gt;对于 Apple TV ，它支持使用 JavaScript、DOM API 与 XMLHttpRequest 来让我们构建某种类似 Client-Server webapp 的东西。没有 HTML 和 CSS，这是什么把戏？其实它支持的叫 TVML，是一种基于 XML、为那些可以被渲染在 TV 屏幕上的特定内容而优化后的标签。这些标签只可以在来自应用商店的 native app 中渲染，但是这些 TVML 是由服务器端来生成的。&lt;/p&gt;

&lt;h3&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://www.mobilexweb.com/blog/ios9-safari-for-web-developers&quot;&gt;iOS 9, Safari and the Web: 3D Touch, new Responsive Web Design, Native integration and HTML5 APIs --- Breaking the Mobile Web&lt;/a&gt;&lt;br&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://clover.htmhub.com/2015/12/15/ios9-safari-web/</link>
        <guid isPermaLink="true">http://clover.htmhub.com/2015/12/15/ios9-safari-web/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>iOS</category>
        
        <category>译文</category>
        
        
      </item>
    
  </channel>
</rss>
